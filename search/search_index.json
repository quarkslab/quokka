{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quokka: A Fast and Accurate Binary Exporter","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Quokka is a binary exporter: from the disassembly of a program, it generates an export file that can be used without the disassembler.</p> <p>The main objective of Quokka is to enable to completely manipulate the binary without ever opening a disassembler after the initial step. Moreover, it abstracts the disassembler's API to expose a clean interface to the users.</p> <p>Quokka is heavily inspired by BinExport, the binary exporter used by BinDiff.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#python-plugin","title":"Python plugin","text":"<p>The plugin is built in the CI and available in the registry.</p> <p>It should be possible to install directly from PIP using this kind of commmand:</p> <pre><code>$ pip install quokka-project\n</code></pre>"},{"location":"#ida-plugin","title":"IDA Plugin","text":"<p>Note: The IDA plugin is not needed to read a <code>Quokka</code> generated file. It is only used to generate them.</p> <p>The plugin is built on the CI and available in the Release.</p> <p>To download the plugin, get the file named <code>quokka_plugin**.so</code>.</p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#export-a-file","title":"Export a file","text":"<p>Note</p> <p>This requires a working IDA installation.</p> <ul> <li>Either using command line: <pre><code>$ idat64 -OQuokkaAuto:true -A /path/to/hello.i64\n</code></pre></li> </ul> <p>Note: We are using <code>idat64</code> and not <code>ida64</code> to increase the export speed because we don't need the graphical interface.</p> <ul> <li>Using the plugin shortcut inside IDA: (by default) Alt+A</li> </ul>"},{"location":"#load-an-export-file","title":"Load an export file","text":"<pre><code>import quokka\n\n# Directly from the binary (requires the IDA plugin to be installed)\nls = quokka.Program.from_binary(\"/bin/ls\")\n\n# From the exported file\nls = quokka.Program(\"ls.quokka\",  # the exported file \n                    \"/bin/ls\")    # the original binary\n</code></pre>"},{"location":"#building","title":"Building","text":""},{"location":"#build","title":"Build","text":"<pre><code>user@host:~/quokka$ cmake -B build \\ # Where to build \n                          -S . \\ # Where are the sources\n                          -DIdaSdk_ROOT_DIR:STRING=path/to/ida_sdk \\ # Path to IDA SDK \n                          -DCMAKE_BUILD_TYPE:STRING=Release \\ # Build Type \n                          -DBUILD_TEST:BOOL=OFF # Don't build the tests\n\nuser@host:~/quokka$ cmake --build build -- -j 8\n</code></pre> <p>To install the plugin:</p> <pre><code>user@host:~/quokka$ cmake --install build\n</code></pre> <p>In any case, the plugin will also be in <code>build/quokka-install</code>. You can copy it to Ida plugin directory.</p> <pre><code>user@host:~/quokka$ cp build/quokka-install/quokka*64.so $IDA_BIN_DIR/plugins/\n</code></pre> <p>For more detailed information about building, see Building</p>"},{"location":"FAQ/","title":"FAQ","text":""},{"location":"FAQ/#what-is-quokka","title":"What is <code>quokka</code> ?","text":"<p><code>quokka</code> is a tool to manipulate the exported versions of your program.  The goal is to have an easy to understand, stable and scalable API to query the (disassembled) binary without relying on having IDA running in the background nor interacting with its API.</p> <p>As a bonus, once a binary has been exported, you can close IDA and work only with the exported file.</p>"},{"location":"FAQ/#why-not-use-directly-ida-api","title":"Why not use directly IDA API ?","text":"<p>IDA API has at least two drawbacks (for me) :</p> <ul> <li>you will need to learn its syntax and how it works:</li> </ul> <pre><code># IDA way\ninst = ida_ua.insn_t()\nida_ua.decode_insn(inst, 0xABCD)\nprint(inst.get_canon_mnem())\n\n## Quokka\ninst = program.get_instruction(0xABCD)\nprint(inst.mnemonic)\n</code></pre>"},{"location":"FAQ/#how-does-quokka-works","title":"How does <code>quokka</code> works ?","text":"<p>In short, it will write everything to a serialized binary format (namely  protobuf).</p>"},{"location":"FAQ/#what-is-exported","title":"What is exported ?","text":"<p>You may have a look at the protobuf format definition to understand exactly what is exported but the list here can  give you a nice overview.</p>"},{"location":"FAQ/#exported-features","title":"Exported features:","text":"<ul> <li>Meta information (file hash, name, detected compiler, calling convention)</li> <li>Segments</li> <li>Structures (structs, enumerations and unions)</li> <li>Comments (every comments attached to anything)</li> <li>Layout (where is the code/data/unknown)</li> <li>Functions and their associated Control Flow Graph</li> <li>Call Graph</li> <li>Instructions (and their operands / mnemonics)</li> <li>References (data and code xref)</li> <li>Data (bytes, strings, ...)</li> </ul>"},{"location":"FAQ/#what-is-not-exported","title":"What is not exported ?","text":"<p>Pretty much everything else but I think the most important here is the type information. It will be a nice addition but that's not the best part of IDA API. </p>"},{"location":"FAQ/#what-are-the-trade-off","title":"What are the trade-off ?","text":"<p>TODO(dm)</p>"},{"location":"FAQ/#contributing","title":"Contributing","text":"<p>Every PR is welcome.</p>"},{"location":"FAQ/#where-to-start","title":"Where to start ?","text":"<p>Grep the code for TODO, some are easy, some require more understanding of the  code.</p>"},{"location":"FAQ/#tips","title":"Tips","text":"<p>During development, you may want to use a soft link in the plugin directory coupled with the option to unload the plugin <code>PLUGIN_UNL</code></p> <pre><code>user@host:~/quokka/$ ln -sf $(pwd)build/src/quokka*64.so \\\n    /opt/ida/plugins/\n</code></pre>"},{"location":"contributing/","title":"Development - Contributing","text":""},{"location":"contributing/#developing","title":"Developing","text":"<p>Clone the repository and install it in a <code>virtualenv</code> in an editable mode with the developers dependencies.</p> <pre><code>$ python -m venv env\n$ source ./env/bin/activate\n$ cd quokka\n(env) $ pip install -e '.[dev]'\n(env) $ python -c \"import quokka; print(quokka.__version__)\" \n</code></pre>"},{"location":"contributing/#format-the-code","title":"Format the code","text":"<p>The project use the <code>black</code> formatter for the  Python code with the defaults settings.</p> <p>Running Black</p> <pre><code>(env) $ black bindings/python/\n</code></pre> <p>The C++ code is formatted using <code>clang-format</code>.</p>"},{"location":"contributing/#updating-the-protobuf-definition","title":"Updating the Protobuf definition","text":"<p>To update the Protobuf definition, follow this steps:</p> <ol> <li>&lt;!&gt; IMPORTANT &lt;!&gt; Open an issue on the official repository</li> <li>Update the <code>proto/quokka.proto</code> file with the new fields</li> <li>Increase the version number in <code>CMakeLists.txt</code> by :</li> <li>A major version if the change breaks backward compatibility</li> <li>A minor version otherwise</li> <li>Write the exporter code</li> <li>Update the python bindings accordingly</li> <li>Update the <code>__quokka_version__</code> in <code>bindings/python/__init__.py</code> to match     the one in step 3.</li> <li>Update the protobuf generated files for python using:    <code>python setup.py generate_py_protobufs</code></li> </ol>"},{"location":"contributing/#add-a-new-ida-version-sdk","title":"Add a new IDA Version / SDK","text":""},{"location":"contributing/#add-an-image-with-the-new-ida-version","title":"Add an image with the new IDA Version","text":"<p>For example, using <code>Version 7.7</code>:</p> <ol> <li>Go to <code>ci</code></li> <li>Copy installer to <code>ci/ida77/ida.run</code></li> <li>(Optional) Copy <code>~/.idapro/ida.reg</code> to <code>ci/ida77/ida.reg</code></li> <li>(Optional) Add the installation password in a file to remember it for next time</li> <li>Build the image     <pre><code>$ docker build --file build.dockerfile \\\n         --build-arg IDA_DIRECTORY=ida77 \\\n         --build-arg IDA_PASSWORD=&lt;install password&gt; \\\n         .\n</code></pre></li> <li>(Optional). If you did not copy a <code>ida.reg</code> file, you should run the     container first, open IDA (<code>/opt/ida/idat64</code>), accept the license and     save the container (using <code>docker commit</code>).</li> </ol>"},{"location":"contributing/#add-the-sdk-in-the-repo","title":"Add the SDK in the repo","text":"<ol> <li>Download the SDK from HexRays website</li> <li>Extract it</li> <li>Generate a password for the SDK archive.</li> <li>Compress the inner <code>idasdk77/</code> directory in an archive protected by the    password.</li> <li>Add the <code>idasdk77.zip</code> to the repository.</li> </ol>"},{"location":"contributing/#other-tips-and-tricks","title":"Other tips and tricks","text":"<p>Read the Dev's Tips &amp; Tricks page!</p>"},{"location":"dev/","title":"Devs Tips &amp; Tricks","text":""},{"location":"dev/#debug-the-plugin","title":"Debug the Plugin","text":"<p>First, generate a debug build using the option <code>CMAKE_BUILD_TYPE=Debug</code>. This will  decrease the performances but allow to debug the plugin easily.</p>"},{"location":"dev/#setup-for-clion","title":"Setup for CLion","text":"<p>It is possible to perform a <code>step-by-step</code> debug of the plugin while running with IDA. The following steps are using CLion but are  adaptable for other IDEs.</p> <ol> <li>First, configure the Profiles for the project. The two most important options     are the SDK Root directory and the IDA bin directory.    </li> <li>Create a Run/Debug configuration    </li> <li>Set the target to <code>quokka_plugin</code></li> <li>Set the executable to be your <code>idat</code> file</li> <li>Set arguments (the same you would use on the command line)</li> <li>Add some environment variables:<ul> <li>IDALOG=/path/to/file Save the IDA's output in a file</li> <li>TVHEADLESS=1 - Improve the speed</li> </ul> </li> <li>Set Build and Install as action before launch.</li> </ol> <p>If you set a breakpoint in the code, you can now debug your plugin by simply  running <code>Debug</code> in CLion interface.</p>"},{"location":"dev/#use-sanitizers","title":"Use Sanitizers","text":"<p>By using the <code>ENABLE_SANITIZERS</code> option in <code>CMake</code>, you enable  ASan.</p> <p>Of note, to run with IDA, you need to specify the path to Asan using <code>LD_PRELOAD</code>.</p>"},{"location":"dev/#running-tests","title":"Running Tests","text":""},{"location":"dev/#for-the-plugin","title":"For the plugin","text":"<p>The C++ tests are at best lackluster but the framework is here to improve them.</p> <p>To compile tests: <pre><code>user@host:~/quokka$ cmake -B build-tests \\ # Where to build \n                          -S . \\ # Where are the sources\n                          -DIdaSdk_ROOT_DIR:STRING=path/to/ida_sdk \\ # Path to IDA SDK \n                          -DCMAKE_BUILD_TYPE:STRING=Debug \\ # Build Type \n                          -DBUILD_TEST:BOOL=On\n</code></pre></p>"},{"location":"dev/#for-the-python-bindings","title":"For the Python bindings","text":"<p>The tests for the Python bindings are also limited but can be improved. To run them, use the following command.</p> <pre><code>user@host:~/quokka$ pytest tests/python\n</code></pre>"},{"location":"example/","title":"Examples","text":""},{"location":"example/#finding-the-string-difference-between-two-functions","title":"Finding the string difference between two functions","text":"<pre><code>import quokka\n\n# Let's get interested in this patch for the CVE-2018-9555:\n# https://android.googlesource.com/platform/system/bt/+/02fc52878d8dba16b860fbdf415b6e4425922b2c%5E%21/#F0\n\n# Load the vuln program using its export\nvuln = quokka.Program('vuln.Quokka',\n                          'vuln_bluetooth.so')\n\n# Load the fix program using its export\nfix = quokka.Program('fix.Quokka',\n                         'fix_bluetooth.so')\n\n# Assume we know that the patched function is \"l2c_lcc_proc_pdu\"\nvuln_function = vuln.get_function(\"l2c_lcc_proc_pdu\", approximative=True)\nfix_function = fix.get_function(\"l2c_lcc_proc_pdu\", approximative=True)\n\nassert (vuln_function and fix_function)\n\n# Vuln functions strings\nvuln_strings = vuln_function.strings\nfix_strings = fix_function.strings\n\ndiff_strings = [x for x in fix_strings if x not in vuln_strings]\nprint(diff_strings)\n\n# Output : ['%s: Invalid sdu_length: %d', '112321180']\n# Nice ! Indeed, the \"112321180\" is actually the android bug id that is added during the patch\n\n# Extract from the patch:\n#\n# +      L2CAP_TRACE_ERROR(\"%s: Invalid sdu_length: %d\", __func__, sdu_length);\n# +      android_errorWriteWithInfoLog(0x534e4554, \"112321180\", -1, NULL, 0);\n</code></pre>"},{"location":"features/","title":"Features","text":"<p>Quokka exports as much information from IDA as possible. The table below list the main exported elements.</p>"},{"location":"features/#exported-elements","title":"Exported elements","text":"Feature Exported Metadata Name Architecture ISA Compiler Layout Segments Code Layout Symbols Name Value Type Data Address Type Size Name Graphs Call Graph CFG Comments Address Type Content Functions Name Type Boundaries Instructions Mnemonic Operand Operand Type Bytes Address Expressions XRef (code, data) Basic Block Address Instructions Type Content Strings Address Content Data Structures Structures Enumerations"},{"location":"features/#other-features","title":"Other features","text":"<p>To ease Quokka usage in various worfklows, the tool also provides several additional features:</p> <ul> <li>Multiple export modes</li> <li>Capstone integration</li> <li>Pypcode integration</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#python-bindings","title":"Python Bindings","text":""},{"location":"installation/#system-requirements","title":"System requirements","text":"<ul> <li>python 3.9 is required. It should also work with higher versions and is   regularly developed with python 3.10.</li> </ul> <p>Note</p> <p>While the IDA plugin requires Linux, the Python bindings should also  work on other architectures. However, it has not yet been tested.</p>"},{"location":"installation/#installation_1","title":"Installation","text":""},{"location":"installation/#using-pip","title":"Using PIP","text":"<pre><code>$ pip install quokka-project\n</code></pre>"},{"location":"installation/#using-the-sources","title":"Using the sources","text":"<p>To have the latest version, you can directly download the source from GitHub and install it locally.</p> <pre><code>$ git clone git@github.com:quarkslab/quokka.git\n$ cd quokka\n$ python -m venv .quokka-env\n$ source .quokka-env/bin/activate\n(.quokka-env) $ pip install .\n</code></pre> <p>Note</p> <p>The previous snippet creates a virtualenv, which is a good practice to  manage Python dependencies.</p>"},{"location":"installation/#using-a-ci-wheel","title":"Using a CI wheel","text":"<p>CI wheels are available directly on the CI</p>"},{"location":"installation/#final-checks","title":"Final checks","text":"<p>To check the installation worked, run the following commands:</p> <pre><code>$ source .quokka-env/bin/activate\n(.quokka-env) $ python -c 'import quokka; print(quokka.__version__)'\n</code></pre>"},{"location":"installation/#ida-plugin","title":"IDA Plugin","text":""},{"location":"installation/#requirements","title":"Requirements","text":""},{"location":"installation/#ida-plugin_1","title":"IDA Plugin","text":"<p>Warning</p> <p>The plugin support for Windows is experimental.</p>"},{"location":"installation/#from-the-ci","title":"From the CI","text":"<p>The plugin is built on the CI and available in the Release.</p> <p>To download the plugin, get the file named <code>quokka_plugin**.so</code>.</p>"},{"location":"installation/#building","title":"Building","text":""},{"location":"installation/#requirements_1","title":"Requirements :","text":"<ul> <li>CMake (at least 3.13)</li> <li>A reasonable modern compiler supporting at least Cxx17</li> <li>IDA Sdk (version 7.3 or higher) 64 bits</li> <li>IDA (7.3 or higher)</li> </ul>"},{"location":"installation/#standard-build","title":"Standard build","text":"<p>The first step is to download the sources. You can clone the repository like in here</p> <p>To compile <code>quokka</code>, you first need to generate the configuration using <code>CMake</code>.</p> <pre><code>user@host:~$ cd quokka\nuser@host:~/quokka$ cmake -B build \\ # Where to build \n                          -S . \\ # Where are the sources\n                          -DIdaSdk_ROOT_DIR:STRING=path/to/ida_sdk \\ # Path to IDA SDK \n                          -DCMAKE_BUILD_TYPE:STRING=Release # Build Type\n</code></pre> <p>If the first step succeeded, you can now do the actual building.</p> <pre><code>user@host:~/quokka$ cmake --build build --target quokka_plugin -- -j  # use as many core as possible\n</code></pre>"},{"location":"installation/#build-on-windows","title":"Build On Windows","text":"<p>Warning</p> <p>This is only experimental.</p>"},{"location":"installation/#requirements_2","title":"Requirements","text":"<p>This procedure has only been tested with using a Windows Dev Machine:</p> <ul> <li>Windows 11 Entreprise</li> <li>Visual Studio 2022 Community Edition</li> <li>Git version 2.37.3 (to download Abseil)</li> <li>cmake version 3.24.1</li> </ul> <p>Optional: - ccache v4.6.3</p>"},{"location":"installation/#steps","title":"Steps","text":"<ol> <li>Configure the plugin</li> </ol> <p><code>console     PS C:\\Users\\User\\quokka&gt; cmake -B build -S . -DIdaSdk_ROOT_DIR=third_party/idasdk80 -A x64</code></p> <ol> <li> <p>Perform the build</p> <pre><code>PS C:\\Users\\User\\quokka&gt; cmake --build build --target quokka_plugin --config Release\n</code></pre> </li> <li> <p>Cross your fingers and hope.</p> <p><code>Quokka</code> for Windows is experimental and not tested. There are known issues with older Visual Studio versions and Ninja. Feel free to report any bug.</p> </li> </ol>"},{"location":"philosophy/","title":"Philosophy","text":"<p><code>Quokka</code> and its bindings were created in order to manipulate a binary without using IDA. To be usable, we needed something (reasonably) fast and compact. It leads to the following properties we try to enforce:</p> <ul> <li>Exhaustive   The plugin should export as much data as possible from IDA</li> <li>Compact   The export file should be as compact as possible to reduce disk usage.</li> <li>Fast   Waiting for the export should be kept as a minimum.</li> <li>Intuitive   The plugin should be usable without documentation with an intuitive interface.</li> </ul>"},{"location":"roadmap/","title":"Roadmap","text":"<p><code>Quokka</code> is not perfect and some features could be improved. The list below is not a Roadmap per se but more like a whishlist.</p> <p>Do not hesitate to open Issues for requesting features.</p>"},{"location":"roadmap/#export-information","title":"Export Information","text":"<ul> <li> Types Information <p>For the moment, Quokka does not export types information. This feature would be super useful for various analyses.</p> </li> <li> Stack Variable <p>IDA defines stack variables in the function. Exporting them could be valuable for some workflows </p> </li> <li> Decompiler <p>Hex-Rays generates a pseudo C-code from binary code. Exporting it as well could also be nice </p> </li> <li> Operands Data <p>While the operands are exported, it is hard to understand them outside IDA without having the disassembler  documentation. Exporting information on them could be interesting.</p> </li> </ul>"},{"location":"roadmap/#refactor","title":"Refactor","text":"<ul> <li> <p> Rewrite the Reference Manager</p> <p>The <code>Reference Manager</code> is hard to understand, to maintain and to use. Plus, it has some performances issues. It has to be rewritten to be improved while not losing any functionalities.</p> </li> <li> <p> Remove the interface for Function Chunks</p> <p>A Function Chunk is an IDA abstraction for function parts. However, it is meaningless to expose them in the user    interface because users do not care about them.</p> </li> <li> <p> Use <code>weakref</code> for Program</p> <p><code>Program</code> has backref in most items in <code>Quokka</code>. However, we should use <code>weakref</code> to allow the garbage collector to  do its magic when cleaning some parts of the program.</p> </li> </ul>"},{"location":"roadmap/#disassemblers","title":"Disassemblers","text":"<ul> <li> Quokka for Ghidra / Binary Ninja <p>While IDA works nicely, some researchers have moved to other disassemblers. Having an export working for Binary Ninja and Ghidra could help Quokka adoption!</p> </li> </ul>"},{"location":"roadmap/#misc","title":"Misc","text":"<ul> <li> Support Fat binaries <p>IDA supports disassembling Fat Binaries but Quokka will only export the first one. One nice feature would be to  select which one to export </p> </li> <li> Verify the support for unknown architectures <p>Quokka should export any binary but it has been barely tested with other architectures.</p> </li> </ul>"},{"location":"roadmap/#documentation","title":"Documentation","text":"<ul> <li> Document Export Modes <p>Quokka has three export modes, but only one is properly documented (NORMAL)</p> </li> </ul>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#export-plugin","title":"Export plugin","text":"<p>Note</p> <p>This requires a working IDA installation.</p> <ul> <li>Either using command line: <pre><code>$ idat64 -OQuokkaAuto:true -A /path/to/hello.i64\n</code></pre></li> </ul> <p>Note: We are using <code>idat64</code> and not <code>ida64</code> to increase the export speed because we don't need the graphical interface.</p> <ul> <li>Using the plugin shortcut inside IDA: (by default) Alt+A</li> </ul>"},{"location":"usage/#export-options","title":"Export Options","text":"<p>To pass option to an IDA plugin, use the <code>-O</code> switch on the command line. Ex: <code>-OQuokka&lt;OPTION_NAME&gt;:&lt;OPTION_VALUE&gt;</code>.</p>"},{"location":"usage/#log-log-level","title":"Log - Log level","text":"<ul> <li>Usage: <code>-OQuokkaLog:&lt;LEVEL&gt;</code></li> <li>Values: Debug,Info,Error</li> </ul> <p>This option toggle the reporting of the exporter.</p> <p>Note: The debug log level also prints the line and the function.</p>"},{"location":"usage/#file-output-filename","title":"File - Output filename","text":"<ul> <li>Usage: <code>-OQuokkaFile:&lt;NAME&gt;</code></li> <li>Values: A path where the user is allowed to write</li> </ul> <p>Use this option to override the file written by quokka. If none is given, .quokka is used."},{"location":"usage/#auto-auto-mode","title":"Auto - Auto mode","text":"<ul> <li>Usage: <code>-OQuokkaAuto:&lt;NON_EMPTY_STRING&gt;</code></li> </ul> <p>Use this option to launch quokka directly from the command line.</p>"},{"location":"usage/#export-level","title":"Export Level","text":"<ul> <li>Usage: <code>-OQuokkaMode:&lt;MODE&gt;</code></li> <li>Values: LIGHT, NORMAL, FULL</li> </ul> <p>Controls the export level for the instructions:</p> <ul> <li>If the <code>Light</code> mode is selected, only the block starting addresses will be  exported.</li> <li>For <code>Normal</code>, the instructions with all IDA values will be exported.    However, it is challenging to interpret them because you have to read IDA API.</li> <li>For <code>Full</code>, the instruction and the string representation of the    instruction is exported.</li> </ul> <p>Example:</p> Light modeNormal modeFull mode <pre><code>prog.proto.instructions == []\n</code></pre> <pre><code>prog.proto.instructions[0] = \n  size: 3\n  mnemonic_index: 3\n  operand_index: 1\n  operand_index: 6\n</code></pre> <pre><code>prog.proto.instructions[0] =\n  size: 3\n  mnemonic_index: 3\n  operand_index: 1\n  operand_index: 6\n  operand_strings: 1\n  operand_strings: 6\n</code></pre> <p>How to choose a mode?</p> <p>By default, use the <code>Normal</code> mode. If you know you are going to ask for another disassembler for specific bytes  (or have reversed the IDA way of storing data), consider using the <code>Light</code>  mode. Finally, if you have an exotic architecture, you may be interested in the full disassembly: in this case, use the <code>Full</code> mode.</p>"},{"location":"reference/python/SUMMARY/","title":"SUMMARY","text":"<ul> <li>addresser</li> <li>instruction</li> <li>function</li> <li>program</li> <li>exc</li> <li>segment</li> <li>types</li> <li>utils</li> <li>version</li> <li>structure</li> <li>reference</li> <li>data</li> <li>block</li> <li>executable</li> <li>analysis<ul> <li>env</li> <li>calling_convention</li> <li>arch</li> <li>utils</li> <li>replacer</li> </ul> </li> <li>backends<ul> <li>pypcode</li> <li>capstone</li> </ul> </li> </ul>"},{"location":"reference/python/addresser/","title":"addresser","text":"<p>Addresser : handle addresses management</p>"},{"location":"reference/python/addresser/#quokka.addresser.Addresser","title":"<code>Addresser</code>","text":"<p>Class for managing addresses.</p> <p>Parameters:</p> Name Type Description Default <code>program</code> <code>Program</code> <p>A backref to the program</p> required <code>base_address</code> <code>AddressT</code> <p>Program's base address</p> required <p>Attributes:</p> Name Type Description <code>logger</code> <p>A logger instance</p> <code>program</code> <code>Program</code> <p>Program reference</p> <code>base_address</code> <code>AddressT</code> <p>Program base address</p> Source code in <code>quokka/addresser.py</code> <pre><code>class Addresser:\n    \"\"\"Class for managing addresses.\n\n    Arguments:\n        program: A backref to the program\n        base_address: Program's base address\n\n    Attributes:\n        logger: A logger instance\n        program: Program reference\n        base_address: Program base address\n\n    \"\"\"\n\n    def __init__(self, program: quokka.Program, base_address: AddressT):\n        \"\"\"Constructor\"\"\"\n        self.logger = logging.getLogger(__name__)\n        self.program: quokka.Program = program\n        self.base_address: AddressT = base_address\n\n    def absolute(self, offset: int) -&gt; AddressT:\n        \"\"\"Converts an offset in the file to an absolute address\n\n        Arguments:\n            offset: Offset in the file\n\n        Returns:\n            An absolute address\n        \"\"\"\n        return self.base_address + offset\n\n    def file(self, offset: int) -&gt; int:\n        \"\"\"Converts a program offset to a file offset.\n\n        Arguments:\n            offset: A virtual address\n\n        Returns:\n            A file offset\n        \"\"\"\n        try:\n            segment = self.program.get_segment(offset)\n        except KeyError as exc:\n            raise quokka.NotInFileError(\"Unable to find the segment\") from exc\n\n        if segment.file_offset != -1:\n            return offset + segment.file_offset\n\n        raise quokka.NotInFileError(\"Unable to find the offset in the file\")\n</code></pre>"},{"location":"reference/python/addresser/#quokka.addresser.Addresser.__init__","title":"<code>__init__(program, base_address)</code>","text":"<p>Constructor</p> Source code in <code>quokka/addresser.py</code> <pre><code>def __init__(self, program: quokka.Program, base_address: AddressT):\n    \"\"\"Constructor\"\"\"\n    self.logger = logging.getLogger(__name__)\n    self.program: quokka.Program = program\n    self.base_address: AddressT = base_address\n</code></pre>"},{"location":"reference/python/addresser/#quokka.addresser.Addresser.absolute","title":"<code>absolute(offset)</code>","text":"<p>Converts an offset in the file to an absolute address</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>Offset in the file</p> required <p>Returns:</p> Type Description <code>AddressT</code> <p>An absolute address</p> Source code in <code>quokka/addresser.py</code> <pre><code>def absolute(self, offset: int) -&gt; AddressT:\n    \"\"\"Converts an offset in the file to an absolute address\n\n    Arguments:\n        offset: Offset in the file\n\n    Returns:\n        An absolute address\n    \"\"\"\n    return self.base_address + offset\n</code></pre>"},{"location":"reference/python/addresser/#quokka.addresser.Addresser.file","title":"<code>file(offset)</code>","text":"<p>Converts a program offset to a file offset.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>A virtual address</p> required <p>Returns:</p> Type Description <code>int</code> <p>A file offset</p> Source code in <code>quokka/addresser.py</code> <pre><code>def file(self, offset: int) -&gt; int:\n    \"\"\"Converts a program offset to a file offset.\n\n    Arguments:\n        offset: A virtual address\n\n    Returns:\n        A file offset\n    \"\"\"\n    try:\n        segment = self.program.get_segment(offset)\n    except KeyError as exc:\n        raise quokka.NotInFileError(\"Unable to find the segment\") from exc\n\n    if segment.file_offset != -1:\n        return offset + segment.file_offset\n\n    raise quokka.NotInFileError(\"Unable to find the offset in the file\")\n</code></pre>"},{"location":"reference/python/block/","title":"block","text":"<p>Methods to use and deal with blocks in a binary.</p>"},{"location":"reference/python/block/#quokka.block.Block","title":"<code>Block</code>","text":"<p>               Bases: <code>MutableMapping</code></p> <p>Basic Block class</p> <p>A basic block is a sequence of instructions without any (basic) incoming flows disrupting it (except calls returns).</p> <p>While blocks may be serialized in the exported file, a new instance of this class is created for each block in the program (so they all have an unique address).</p> <p>Parameters:</p> Name Type Description Default <code>block_idx</code> <code>Index</code> <p>Index in the protobuf file of the block</p> required <code>start_address</code> <code>AddressT</code> <p>Starting address of the block</p> required <code>chunk</code> <code>Chunk</code> <p>Parent chunk (e.g. function) of the block.</p> required <p>Attributes:</p> Name Type Description <code>proto_index</code> <code>Index</code> <p>Index inside the protobuf</p> <code>parent</code> <code>Chunk</code> <p>A reference to the parent Chunk</p> <code>program</code> <code>Program</code> <p>A reference to the parent Program</p> <code>start</code> <code>int</code> <p>Start address</p> <code>fake</code> <code>bool</code> <p>Is it a fake block (e.g. belongs to a fake chunk)</p> <code>type</code> <code>BlockType</code> <p>Block type</p> <code>address_to_index</code> <code>Dict[AddressT, Index]</code> <p>A mapping of addresses to instruction indexes</p> <code>end</code> <code>int</code> <p>End address</p> <code>comments</code> <code>Dict[AddressT, str]</code> <p>List of comments attached to the block</p> <code>references</code> <code>Dict[str, List[int]]</code> <p>References mapping attached to the block (TODO(dm): remove me?)</p> Source code in <code>quokka/block.py</code> <pre><code>class Block(MutableMapping):\n    \"\"\"Basic Block class\n\n    A basic block is a sequence of instructions without any (basic) incoming flows\n    disrupting it (except calls returns).\n\n    While blocks may be serialized in the exported file, a new instance of this class is\n    created for each block in the program (so they all have an unique address).\n\n    Arguments:\n        block_idx: Index in the protobuf file of the block\n        start_address: Starting address of the block\n        chunk: Parent chunk (e.g. function) of the block.\n\n    Attributes:\n        proto_index: Index inside the protobuf\n        parent: A reference to the parent Chunk\n        program: A reference to the parent Program\n        start: Start address\n        fake: Is it a fake block (e.g. belongs to a fake chunk)\n        type: Block type\n        address_to_index: A mapping of addresses to instruction indexes\n        end: End address\n        comments: List of comments attached to the block\n        references: References mapping attached to the block (TODO(dm): remove me?)\n    \"\"\"\n\n    def __init__(\n        self,\n        block_idx: Index,\n        start_address: AddressT,\n        chunk: quokka.Chunk,\n    ):\n        \"\"\"Constructor\"\"\"\n        self.proto_index: Index = block_idx\n        self.parent: quokka.Chunk = chunk\n        self.program: quokka.Program = chunk.program\n\n        block: \"quokka.pb.Quokka.FunctionChunk.Block\"\n        block = self.program.proto.function_chunks[chunk.proto_index].blocks[block_idx]\n\n        self.start: int = start_address\n        self.fake: bool = block.is_fake\n        self.type: BlockType = BlockType.from_proto(block.block_type)\n\n        self.address_to_index: Dict[AddressT, Index] = {}\n        self._raw_dict: Dict[AddressT, Index] = {}\n\n        current_address: AddressT = self.start\n        for instruction_index, instruction_proto_index in enumerate(\n            block.instructions_index\n        ):\n            self.address_to_index[current_address] = instruction_index\n            self._raw_dict[current_address] = instruction_proto_index\n            current_address += self.program.proto.instructions[\n                instruction_proto_index\n            ].size\n\n        self.end: int = current_address\n\n        self.comments: Dict[AddressT, str] = {}\n        self.references: Dict[str, List[int]] = {\"src\": [], \"dst\": []}\n\n    def __setitem__(self, k: AddressT, v: Index) -&gt; None:\n        \"\"\"Update the instructions mapping\"\"\"\n        self._raw_dict.__setitem__(k, v)\n\n    def __delitem__(self, v: AddressT) -&gt; None:\n        \"\"\"Remove an instruction from the mapping\"\"\"\n        self._raw_dict.__delitem__(v)\n\n    def add_comment(self, addr: AddressT, value: str) -&gt; None:\n        \"\"\"Set the comment at `addr`.\n\n        Arguments:\n            addr: Comment address\n            value: Comment value\n        \"\"\"\n        self.comments[addr] = value\n\n    @cached_property\n    def strings(self) -&gt; List[str]:\n        \"\"\"Compute the list of strings used in this block.\"\"\"\n\n        strings: Set[str] = set()\n\n        for reference in self.program.references.resolve_block_references(\n            self.parent.proto_index,\n            self.proto_index,\n            ReferenceType.DATA,\n            towards=True,\n        ):\n            reference_source = reference.source\n            if (\n                isinstance(reference_source, quokka.data.Data)\n                and reference_source.type == DataType.ASCII\n            ):\n                strings.add(reference_source.value)\n\n        return list(strings)\n\n    def __getitem__(self, address: AddressT) -&gt; quokka.Instruction:\n        \"\"\"Retrieve an instruction at `address`.\"\"\"\n        item = self._raw_dict.__getitem__(address)\n        return quokka.Instruction(\n            proto_index=item,\n            inst_index=self.address_to_index[address],\n            address=address,\n            block=self,\n        )\n\n    def __len__(self) -&gt; int:\n        \"\"\"Number of instruction in the block\"\"\"\n        return len(self._raw_dict)\n\n    def __iter__(self) -&gt; Iterator:\n        \"\"\"Return an iterator over the instruction list\"\"\"\n        return iter(self._raw_dict)\n\n    @property\n    def data_references(self):\n        \"\"\"Return (and compute if needed) the data referenced by this block.\"\"\"\n        data_references: List[quokka.Data] = []\n        for instruction in self.values():\n            data_references.extend(instruction.data_references)\n\n        return data_references\n\n    @property\n    def size(self) -&gt; int:\n        \"\"\"Size of the block.\n\n        This number is the number of instruction * the size of an instruction for\n        architecture with fixed length instructions (e.g. ARM).\n        \"\"\"\n        return self.end - self.start\n\n    @cached_property\n    def constants(self) -&gt; List[int]:\n        \"\"\"Constants used by the block\"\"\"\n        constants: List[int] = []\n        for instruction in self.values():\n            constants.extend(instruction.constants)\n\n        return constants\n\n    @property\n    def instructions(self) -&gt; Iterator[Instruction]:\n        \"\"\"Accessor of the block instructions\"\"\"\n        return iter(self.values())\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Block Representation\"\"\"\n        return (\n            f\"&lt;Block at 0x{self.start:x} ({self.type}) with {len(self)} instructions&gt;\"\n        )\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Hash of the block.\n\n        The proto index is guaranteed to be unique so we can use it as an hash and\n        forget about un-hashable types.\n\n        TODO(dm):\n            Check this\n        \"\"\"\n        return self.proto_index\n\n    def successors(self) -&gt; Iterator[AddressT]:\n        \"\"\"(Addresses of the) Successors of the current block.\"\"\"\n        return self.parent.graph.successors(self.start)\n\n    def predecessors(self) -&gt; Iterator[AddressT]:\n        \"\"\"(Addresses of) Predecessors of the current block\"\"\"\n        return self.parent.graph.predecessors(self.start)\n\n    @property\n    def last_instruction(self) -&gt; quokka.Instruction:\n        \"\"\"Direct accessor of the last instruction in the block\"\"\"\n        deque = collections.deque(self.instructions, maxlen=1)\n        return deque.pop()\n\n    @cached_property\n    def bytes(self) -&gt; bytes:\n        \"\"\"Retrieve the block bytes\n\n        All bytes for the block are read at once in the file but the result is not\n        cached.\n        \"\"\"\n        try:\n            file_offset: int = self.program.addresser.file(self.start)\n        except quokka.NotInFileError:\n            logger.warning(\"Trying to get the bytes for a block not in file.\")\n            return b\"\"\n\n        # Read all block at once\n        block_bytes = self.program.executable.read_bytes(\n            offset=file_offset,\n            size=self.size,\n        )\n\n        return block_bytes\n\n    @cached_property\n    def pcode_insts(self) -&gt; List[pypcode.PcodeOp]:\n        \"\"\"Generate PCode instructions for the block\n\n        This method will call the backend Pypcode and generate the instruction for the\n        whole block, updating all the instruction inside the block as well.\n\n        However, all instructions will from now be attached to the block itself, and not\n        the instructions so the list may differ after some optimizations (e.g.\n        len(self.pcode_insts) != sum(len(inst.pcode_insts) for inst in block.values()) )\n\n        Returns:\n            A list of PCode instructions\n\n        \"\"\"\n        from quokka.backends.pypcode import pypcode_decode_block\n\n        return pypcode_decode_block(self)\n</code></pre>"},{"location":"reference/python/block/#quokka.block.Block.bytes","title":"<code>bytes</code>  <code>cached</code> <code>property</code>","text":"<p>Retrieve the block bytes</p> <p>All bytes for the block are read at once in the file but the result is not cached.</p>"},{"location":"reference/python/block/#quokka.block.Block.constants","title":"<code>constants</code>  <code>cached</code> <code>property</code>","text":"<p>Constants used by the block</p>"},{"location":"reference/python/block/#quokka.block.Block.data_references","title":"<code>data_references</code>  <code>property</code>","text":"<p>Return (and compute if needed) the data referenced by this block.</p>"},{"location":"reference/python/block/#quokka.block.Block.instructions","title":"<code>instructions</code>  <code>property</code>","text":"<p>Accessor of the block instructions</p>"},{"location":"reference/python/block/#quokka.block.Block.last_instruction","title":"<code>last_instruction</code>  <code>property</code>","text":"<p>Direct accessor of the last instruction in the block</p>"},{"location":"reference/python/block/#quokka.block.Block.pcode_insts","title":"<code>pcode_insts</code>  <code>cached</code> <code>property</code>","text":"<p>Generate PCode instructions for the block</p> <p>This method will call the backend Pypcode and generate the instruction for the whole block, updating all the instruction inside the block as well.</p> <p>However, all instructions will from now be attached to the block itself, and not the instructions so the list may differ after some optimizations (e.g. len(self.pcode_insts) != sum(len(inst.pcode_insts) for inst in block.values()) )</p> <p>Returns:</p> Type Description <code>List[PcodeOp]</code> <p>A list of PCode instructions</p>"},{"location":"reference/python/block/#quokka.block.Block.size","title":"<code>size</code>  <code>property</code>","text":"<p>Size of the block.</p> <p>This number is the number of instruction * the size of an instruction for architecture with fixed length instructions (e.g. ARM).</p>"},{"location":"reference/python/block/#quokka.block.Block.strings","title":"<code>strings</code>  <code>cached</code> <code>property</code>","text":"<p>Compute the list of strings used in this block.</p>"},{"location":"reference/python/block/#quokka.block.Block.__delitem__","title":"<code>__delitem__(v)</code>","text":"<p>Remove an instruction from the mapping</p> Source code in <code>quokka/block.py</code> <pre><code>def __delitem__(self, v: AddressT) -&gt; None:\n    \"\"\"Remove an instruction from the mapping\"\"\"\n    self._raw_dict.__delitem__(v)\n</code></pre>"},{"location":"reference/python/block/#quokka.block.Block.__getitem__","title":"<code>__getitem__(address)</code>","text":"<p>Retrieve an instruction at <code>address</code>.</p> Source code in <code>quokka/block.py</code> <pre><code>def __getitem__(self, address: AddressT) -&gt; quokka.Instruction:\n    \"\"\"Retrieve an instruction at `address`.\"\"\"\n    item = self._raw_dict.__getitem__(address)\n    return quokka.Instruction(\n        proto_index=item,\n        inst_index=self.address_to_index[address],\n        address=address,\n        block=self,\n    )\n</code></pre>"},{"location":"reference/python/block/#quokka.block.Block.__hash__","title":"<code>__hash__()</code>","text":"<p>Hash of the block.</p> <p>The proto index is guaranteed to be unique so we can use it as an hash and forget about un-hashable types.</p> <p>TODO(dm):     Check this</p> Source code in <code>quokka/block.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Hash of the block.\n\n    The proto index is guaranteed to be unique so we can use it as an hash and\n    forget about un-hashable types.\n\n    TODO(dm):\n        Check this\n    \"\"\"\n    return self.proto_index\n</code></pre>"},{"location":"reference/python/block/#quokka.block.Block.__init__","title":"<code>__init__(block_idx, start_address, chunk)</code>","text":"<p>Constructor</p> Source code in <code>quokka/block.py</code> <pre><code>def __init__(\n    self,\n    block_idx: Index,\n    start_address: AddressT,\n    chunk: quokka.Chunk,\n):\n    \"\"\"Constructor\"\"\"\n    self.proto_index: Index = block_idx\n    self.parent: quokka.Chunk = chunk\n    self.program: quokka.Program = chunk.program\n\n    block: \"quokka.pb.Quokka.FunctionChunk.Block\"\n    block = self.program.proto.function_chunks[chunk.proto_index].blocks[block_idx]\n\n    self.start: int = start_address\n    self.fake: bool = block.is_fake\n    self.type: BlockType = BlockType.from_proto(block.block_type)\n\n    self.address_to_index: Dict[AddressT, Index] = {}\n    self._raw_dict: Dict[AddressT, Index] = {}\n\n    current_address: AddressT = self.start\n    for instruction_index, instruction_proto_index in enumerate(\n        block.instructions_index\n    ):\n        self.address_to_index[current_address] = instruction_index\n        self._raw_dict[current_address] = instruction_proto_index\n        current_address += self.program.proto.instructions[\n            instruction_proto_index\n        ].size\n\n    self.end: int = current_address\n\n    self.comments: Dict[AddressT, str] = {}\n    self.references: Dict[str, List[int]] = {\"src\": [], \"dst\": []}\n</code></pre>"},{"location":"reference/python/block/#quokka.block.Block.__iter__","title":"<code>__iter__()</code>","text":"<p>Return an iterator over the instruction list</p> Source code in <code>quokka/block.py</code> <pre><code>def __iter__(self) -&gt; Iterator:\n    \"\"\"Return an iterator over the instruction list\"\"\"\n    return iter(self._raw_dict)\n</code></pre>"},{"location":"reference/python/block/#quokka.block.Block.__len__","title":"<code>__len__()</code>","text":"<p>Number of instruction in the block</p> Source code in <code>quokka/block.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Number of instruction in the block\"\"\"\n    return len(self._raw_dict)\n</code></pre>"},{"location":"reference/python/block/#quokka.block.Block.__repr__","title":"<code>__repr__()</code>","text":"<p>Block Representation</p> Source code in <code>quokka/block.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Block Representation\"\"\"\n    return (\n        f\"&lt;Block at 0x{self.start:x} ({self.type}) with {len(self)} instructions&gt;\"\n    )\n</code></pre>"},{"location":"reference/python/block/#quokka.block.Block.__setitem__","title":"<code>__setitem__(k, v)</code>","text":"<p>Update the instructions mapping</p> Source code in <code>quokka/block.py</code> <pre><code>def __setitem__(self, k: AddressT, v: Index) -&gt; None:\n    \"\"\"Update the instructions mapping\"\"\"\n    self._raw_dict.__setitem__(k, v)\n</code></pre>"},{"location":"reference/python/block/#quokka.block.Block.add_comment","title":"<code>add_comment(addr, value)</code>","text":"<p>Set the comment at <code>addr</code>.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>AddressT</code> <p>Comment address</p> required <code>value</code> <code>str</code> <p>Comment value</p> required Source code in <code>quokka/block.py</code> <pre><code>def add_comment(self, addr: AddressT, value: str) -&gt; None:\n    \"\"\"Set the comment at `addr`.\n\n    Arguments:\n        addr: Comment address\n        value: Comment value\n    \"\"\"\n    self.comments[addr] = value\n</code></pre>"},{"location":"reference/python/block/#quokka.block.Block.predecessors","title":"<code>predecessors()</code>","text":"<p>(Addresses of) Predecessors of the current block</p> Source code in <code>quokka/block.py</code> <pre><code>def predecessors(self) -&gt; Iterator[AddressT]:\n    \"\"\"(Addresses of) Predecessors of the current block\"\"\"\n    return self.parent.graph.predecessors(self.start)\n</code></pre>"},{"location":"reference/python/block/#quokka.block.Block.successors","title":"<code>successors()</code>","text":"<p>(Addresses of the) Successors of the current block.</p> Source code in <code>quokka/block.py</code> <pre><code>def successors(self) -&gt; Iterator[AddressT]:\n    \"\"\"(Addresses of the) Successors of the current block.\"\"\"\n    return self.parent.graph.successors(self.start)\n</code></pre>"},{"location":"reference/python/data/","title":"data","text":"<p>Data management.</p> <p>A data is a piece of information that isn't code.</p>"},{"location":"reference/python/data/#quokka.data.Data","title":"<code>Data</code>","text":"<p>Base class for data.</p> <p>All data have at least a type and a value. They are referenced inside the program by and to other data and code.</p> <p>Parameters:</p> Name Type Description Default <code>proto_index</code> <code>Index</code> <p>Index in the protobuf</p> required <code>data</code> <code>'quokka.pb.Quokka.Data'</code> <p>Protobuf value of the data.</p> required <code>program</code> <code>Program</code> <p>Program backref</p> required <p>Attributes:</p> Name Type Description <code>proto_index</code> <code>Index</code> <p>Index in the protobuf</p> <code>address</code> <code>AddressT</code> <p>Data address</p> <code>type</code> <code>'DataType'</code> <p>Data type</p> <code>program</code> <code>Program</code> <p>Reference to the Program</p> <code>is_initialized</code> <code>bool</code> <p>Is the data initialized?</p> <code>size</code> <code>Optional[int]</code> <p>Data size (depends on the type usually)</p> <code>name</code> <code>Optional[str]</code> <p>Data name (if any)</p> Source code in <code>quokka/data.py</code> <pre><code>class Data:\n    \"\"\"Base class for data.\n\n    All data have at least a type and a value.\n    They are referenced inside the program by and to other data and code.\n\n    Parameters:\n        proto_index: Index in the protobuf\n        data: Protobuf value of the data.\n        program: Program backref\n\n    Attributes:\n        proto_index: Index in the protobuf\n        address: Data address\n        type: Data type\n        program: Reference to the Program\n        is_initialized: Is the data initialized?\n        size: Data size (depends on the type usually)\n        name: Data name (if any)\n    \"\"\"\n\n    def __init__(\n        self, proto_index: Index, data: \"quokka.pb.Quokka.Data\", program: quokka.Program\n    ):\n        \"\"\"Constructor\"\"\"\n        self.proto_index: Index = proto_index\n        self.address: AddressT = program.addresser.absolute(data.offset)\n        self.type: \"DataType\" = DataType.from_proto(data.type)\n        self.program: quokka.Program = program\n\n        self.is_initialized: bool = not data.not_initialized\n\n        self.size: Optional[int] = (\n            data.size if data.WhichOneof(\"DataSize\") != \"no_size\" else None\n        )\n        self._value: Optional[str] = (\n            self.program.proto.string_table[data.value_index]\n            if data.value_index &gt; 0\n            else None\n        )\n        self.name: Optional[str] = (\n            self.program.proto.string_table[data.name_index]\n            if data.name_index &gt; 0\n            else None\n        )\n\n    def __eq__(self, other: Any) -&gt; bool:\n        \"\"\"Check equality between two Data instances\"\"\"\n        return type(other) is type(self) and other.proto_index == self.proto_index\n\n    @property\n    def value(self) -&gt; Any:\n        \"\"\"Data value.\n\n        The value is read in the program binary file.\n        \"\"\"\n\n        # Uninitialized memory\n        if not self.is_initialized:\n            return None\n\n        address = self.program.addresser.file(self.address)\n\n        if self.type in (\n            DataType.ALIGN,\n            DataType.POINTER,\n            DataType.STRUCT,\n            DataType.UNKNOWN,\n        ):\n            return self._value\n\n        if self.type == DataType.ASCII:\n            try:\n                return self.program.executable.read_data(\n                    address, self.type, size=self.size\n                )\n            except quokka.exc.NotInFileError:\n                logger.error(\"Try to read a string which is not in file\")\n                return \"\"\n        else:\n            return self.program.executable.read_data(address, self.type)\n\n    @property\n    def references(self) -&gt; List[quokka.Reference]:\n        \"\"\"References to/from this data\"\"\"\n        return self.program.references.resolve_data(self.proto_index)\n\n    @property\n    def code_references(self) -&gt; List[quokka.Reference]:\n        \"\"\"Returns code referencing this Data\"\"\"\n        return [ref for ref in self.references if isinstance(ref.destination, tuple)]\n\n    @property\n    def data_references(self) -&gt; List[quokka.Reference]:\n        \"\"\"Returns data references to/from this Data\"\"\"\n        return [ref for ref in self.references if isinstance(ref.destination, Data)]\n</code></pre>"},{"location":"reference/python/data/#quokka.data.Data.code_references","title":"<code>code_references</code>  <code>property</code>","text":"<p>Returns code referencing this Data</p>"},{"location":"reference/python/data/#quokka.data.Data.data_references","title":"<code>data_references</code>  <code>property</code>","text":"<p>Returns data references to/from this Data</p>"},{"location":"reference/python/data/#quokka.data.Data.references","title":"<code>references</code>  <code>property</code>","text":"<p>References to/from this data</p>"},{"location":"reference/python/data/#quokka.data.Data.value","title":"<code>value</code>  <code>property</code>","text":"<p>Data value.</p> <p>The value is read in the program binary file.</p>"},{"location":"reference/python/data/#quokka.data.Data.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Check equality between two Data instances</p> Source code in <code>quokka/data.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    \"\"\"Check equality between two Data instances\"\"\"\n    return type(other) is type(self) and other.proto_index == self.proto_index\n</code></pre>"},{"location":"reference/python/data/#quokka.data.Data.__init__","title":"<code>__init__(proto_index, data, program)</code>","text":"<p>Constructor</p> Source code in <code>quokka/data.py</code> <pre><code>def __init__(\n    self, proto_index: Index, data: \"quokka.pb.Quokka.Data\", program: quokka.Program\n):\n    \"\"\"Constructor\"\"\"\n    self.proto_index: Index = proto_index\n    self.address: AddressT = program.addresser.absolute(data.offset)\n    self.type: \"DataType\" = DataType.from_proto(data.type)\n    self.program: quokka.Program = program\n\n    self.is_initialized: bool = not data.not_initialized\n\n    self.size: Optional[int] = (\n        data.size if data.WhichOneof(\"DataSize\") != \"no_size\" else None\n    )\n    self._value: Optional[str] = (\n        self.program.proto.string_table[data.value_index]\n        if data.value_index &gt; 0\n        else None\n    )\n    self.name: Optional[str] = (\n        self.program.proto.string_table[data.name_index]\n        if data.name_index &gt; 0\n        else None\n    )\n</code></pre>"},{"location":"reference/python/data/#quokka.data.DataHolder","title":"<code>DataHolder</code>","text":"<p>               Bases: <code>Mapping</code></p> <p>Data bucket</p> <p>All the data of the program are referenced in this bucket and allow to store them only once.</p> <p>Attributes:</p> Name Type Description <code>proto_data</code> <p>The protobuf data themselves</p> <code>program</code> <code>Program</code> <p>A reference to the Program</p> <p>Parameters:</p> Name Type Description Default <code>proto</code> <p>The protobuf data</p> required <code>program</code> <code>Program</code> <p>The program</p> required TODO <p>Type hinting for proto parameter (RepeatedCompositeFieldContainer)</p> Source code in <code>quokka/data.py</code> <pre><code>class DataHolder(Mapping):\n    \"\"\"Data bucket\n\n    All the data of the program are referenced in this bucket and allow to store them\n    only once.\n\n    Attributes:\n        proto_data: The protobuf data themselves\n        program: A reference to the Program\n\n    Arguments:\n        proto: The protobuf data\n        program: The program\n\n    TODO:\n        Type hinting for proto parameter (RepeatedCompositeFieldContainer)\n    \"\"\"\n\n    def __init__(self, proto, program: quokka.Program):\n        \"\"\"Init method\n\n        Arguments:\n            proto: List of data in the protobuf\n            program: Backref to the program\n        \"\"\"\n        self.proto_data = proto.data\n        self.program: quokka.Program = program\n\n    def __setitem__(self, key: Index, value: Data) -&gt; None:\n        \"\"\"Set a data\"\"\"\n        raise ValueError(\"Should not be accessed\")\n\n    def __delitem__(self, value: Index) -&gt; None:\n        \"\"\"Remove a data from the bucket\"\"\"\n        raise ValueError(\"Should not be accessed\")\n\n    def __getitem__(self, key: Index) -&gt; Data:\n        \"\"\"Get a data from the bucket.\n\n        Arguments:\n            key: Data Index\n\n        Returns:\n            A Data\n        \"\"\"\n        return Data(key, self.proto_data[key], self.program)\n\n    def get_data(self, address: AddressT) -&gt; Data:\n        \"\"\"Find a data by address\n\n        Iterates over the data to find the one at a specified offset\n\n        Arguments:\n            address: Offset to query\n\n        Returns:\n            A Data\n\n        Raises:\n            ValueError: if no data is found\n        \"\"\"\n\n        # We have to iterate over every data because they are not sorted by offset\n        for index, data_proto in enumerate(self.proto_data):\n            if data_proto.offset + self.program.base_address == address:\n                return self[index]\n\n        raise ValueError(f\"No data at offset 0x{address:x}\")\n\n    def __len__(self) -&gt; int:\n        \"\"\"Number of data in the program\"\"\"\n        return len(self.proto_data)\n\n    def __iter__(self):\n        \"\"\"Do not allow the iteration over the data\"\"\"\n        raise ValueError(\"Should not be accessed\")\n</code></pre>"},{"location":"reference/python/data/#quokka.data.DataHolder.__delitem__","title":"<code>__delitem__(value)</code>","text":"<p>Remove a data from the bucket</p> Source code in <code>quokka/data.py</code> <pre><code>def __delitem__(self, value: Index) -&gt; None:\n    \"\"\"Remove a data from the bucket\"\"\"\n    raise ValueError(\"Should not be accessed\")\n</code></pre>"},{"location":"reference/python/data/#quokka.data.DataHolder.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Get a data from the bucket.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Index</code> <p>Data Index</p> required <p>Returns:</p> Type Description <code>Data</code> <p>A Data</p> Source code in <code>quokka/data.py</code> <pre><code>def __getitem__(self, key: Index) -&gt; Data:\n    \"\"\"Get a data from the bucket.\n\n    Arguments:\n        key: Data Index\n\n    Returns:\n        A Data\n    \"\"\"\n    return Data(key, self.proto_data[key], self.program)\n</code></pre>"},{"location":"reference/python/data/#quokka.data.DataHolder.__init__","title":"<code>__init__(proto, program)</code>","text":"<p>Init method</p> <p>Parameters:</p> Name Type Description Default <code>proto</code> <p>List of data in the protobuf</p> required <code>program</code> <code>Program</code> <p>Backref to the program</p> required Source code in <code>quokka/data.py</code> <pre><code>def __init__(self, proto, program: quokka.Program):\n    \"\"\"Init method\n\n    Arguments:\n        proto: List of data in the protobuf\n        program: Backref to the program\n    \"\"\"\n    self.proto_data = proto.data\n    self.program: quokka.Program = program\n</code></pre>"},{"location":"reference/python/data/#quokka.data.DataHolder.__iter__","title":"<code>__iter__()</code>","text":"<p>Do not allow the iteration over the data</p> Source code in <code>quokka/data.py</code> <pre><code>def __iter__(self):\n    \"\"\"Do not allow the iteration over the data\"\"\"\n    raise ValueError(\"Should not be accessed\")\n</code></pre>"},{"location":"reference/python/data/#quokka.data.DataHolder.__len__","title":"<code>__len__()</code>","text":"<p>Number of data in the program</p> Source code in <code>quokka/data.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Number of data in the program\"\"\"\n    return len(self.proto_data)\n</code></pre>"},{"location":"reference/python/data/#quokka.data.DataHolder.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Set a data</p> Source code in <code>quokka/data.py</code> <pre><code>def __setitem__(self, key: Index, value: Data) -&gt; None:\n    \"\"\"Set a data\"\"\"\n    raise ValueError(\"Should not be accessed\")\n</code></pre>"},{"location":"reference/python/data/#quokka.data.DataHolder.get_data","title":"<code>get_data(address)</code>","text":"<p>Find a data by address</p> <p>Iterates over the data to find the one at a specified offset</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>AddressT</code> <p>Offset to query</p> required <p>Returns:</p> Type Description <code>Data</code> <p>A Data</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if no data is found</p> Source code in <code>quokka/data.py</code> <pre><code>def get_data(self, address: AddressT) -&gt; Data:\n    \"\"\"Find a data by address\n\n    Iterates over the data to find the one at a specified offset\n\n    Arguments:\n        address: Offset to query\n\n    Returns:\n        A Data\n\n    Raises:\n        ValueError: if no data is found\n    \"\"\"\n\n    # We have to iterate over every data because they are not sorted by offset\n    for index, data_proto in enumerate(self.proto_data):\n        if data_proto.offset + self.program.base_address == address:\n            return self[index]\n\n    raise ValueError(f\"No data at offset 0x{address:x}\")\n</code></pre>"},{"location":"reference/python/exc/","title":"exc","text":"<p>Exceptions for quokka.</p> <p>All exceptions must derive from the QuokkaError.</p>"},{"location":"reference/python/exc/#quokka.exc.CapstoneError","title":"<code>CapstoneError</code>","text":"<p>               Bases: <code>QuokkaError</code></p> <p>Exceptions used for Capstone integration</p> Source code in <code>quokka/exc.py</code> <pre><code>class CapstoneError(QuokkaError):\n    \"\"\"Exceptions used for Capstone integration\"\"\"\n</code></pre>"},{"location":"reference/python/exc/#quokka.exc.ChunkMissingError","title":"<code>ChunkMissingError</code>","text":"<p>               Bases: <code>QuokkaError</code></p> <p>Raised when a chunk has not been found</p> Source code in <code>quokka/exc.py</code> <pre><code>class ChunkMissingError(QuokkaError):\n    \"\"\"Raised when a chunk has not been found\"\"\"\n</code></pre>"},{"location":"reference/python/exc/#quokka.exc.FunctionMissingError","title":"<code>FunctionMissingError</code>","text":"<p>               Bases: <code>QuokkaError</code></p> <p>Raised when a function has not been found</p> Source code in <code>quokka/exc.py</code> <pre><code>class FunctionMissingError(QuokkaError):\n    \"\"\"Raised when a function has not been found\"\"\"\n</code></pre>"},{"location":"reference/python/exc/#quokka.exc.InstructionError","title":"<code>InstructionError</code>","text":"<p>               Bases: <code>QuokkaError</code></p> <p>Raised when serious errors in Instructions handling</p> Source code in <code>quokka/exc.py</code> <pre><code>class InstructionError(QuokkaError):\n    \"\"\"Raised when serious errors in Instructions handling\"\"\"\n</code></pre>"},{"location":"reference/python/exc/#quokka.exc.NotInFileError","title":"<code>NotInFileError</code>","text":"<p>               Bases: <code>QuokkaError</code></p> <p>Raised when trying to read a string outside the file</p> Source code in <code>quokka/exc.py</code> <pre><code>class NotInFileError(QuokkaError):\n    \"\"\"Raised when trying to read a string outside the file\"\"\"\n</code></pre>"},{"location":"reference/python/exc/#quokka.exc.PypcodeError","title":"<code>PypcodeError</code>","text":"<p>               Bases: <code>QuokkaError</code></p> <p>Main exception for pypcode integration</p> Source code in <code>quokka/exc.py</code> <pre><code>class PypcodeError(QuokkaError):\n    \"\"\"Main exception for pypcode integration\"\"\"\n</code></pre>"},{"location":"reference/python/exc/#quokka.exc.QuokkaError","title":"<code>QuokkaError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception in Quokka</p> Source code in <code>quokka/exc.py</code> <pre><code>class QuokkaError(Exception):\n    \"\"\"Base exception in Quokka\"\"\"\n</code></pre>"},{"location":"reference/python/exc/#quokka.exc.ThunkMissingError","title":"<code>ThunkMissingError</code>","text":"<p>               Bases: <code>QuokkaError</code></p> <p>Raised when a thunk has not been found</p> Source code in <code>quokka/exc.py</code> <pre><code>class ThunkMissingError(QuokkaError):\n    \"\"\"Raised when a thunk has not been found\"\"\"\n</code></pre>"},{"location":"reference/python/executable/","title":"executable","text":"<p>Executable: management of the binary file in itself.</p>"},{"location":"reference/python/executable/#quokka.executable.Executable","title":"<code>Executable</code>","text":"<p>The executable class is used to interact with the binary file.</p> <p>It handles access to the binary file itself (not the exported) for reads.</p> <p>Note: The binary is read only once and stored in memory. This is done for performance purposes but does not cope well with low RAM systems and/or huge binaries.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path towards the executable file</p> required <code>endianness</code> <code>Endianness</code> <p>How are stored the data</p> required <p>Attributes:</p> Name Type Description <code>exec_file</code> <code>Path</code> <p>Path towards the executable file</p> <code>endianness</code> <code>Endianness</code> <p>Binary endianness</p> <code>content</code> <code>bytes</code> <p>Bytes of the binary</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file is not found</p> Source code in <code>quokka/executable.py</code> <pre><code>class Executable:\n    \"\"\"The executable class is used to interact with the binary file.\n\n    It handles access to the binary file itself (not the exported) for reads.\n\n    Note: The binary is read only once and stored in memory. This is done for\n    performance purposes but does not cope well with low RAM systems and/or huge\n    binaries.\n\n    Arguments:\n        path: Path towards the executable file\n        endianness: How are stored the data\n\n    Attributes:\n        exec_file: Path towards the executable file\n        endianness: Binary endianness\n        content: Bytes of the binary\n\n    Raises:\n        ValueError: If the file is not found\n    \"\"\"\n\n    def __init__(self, path: Union[str, pathlib.Path], endianness: Endianness):\n        \"\"\"Constructor\"\"\"\n        try:\n            with open(path, \"rb\") as file:\n                self.content: bytes = file.read()\n\n        except FileNotFoundError:\n            raise ValueError(\"File not found\")\n\n        self.exec_file: pathlib.Path = pathlib.Path(path)\n        self.endianness: Endianness = endianness\n\n    def read(self, offset: int, size: int) -&gt; bytes:\n        \"\"\"Read `size` at `offset` in the file.\n\n        This method should not be used directly and considered as part of a private API.\n        The preferred method are read_bytes / read_string .\n\n        Arguments:\n            offset: File offset\n            size: Read size\n\n        Returns:\n            The content that has been read\n\n        Raises:\n            ValueError: when the value is not in the file\n        \"\"\"\n        try:\n            return self.content[offset : offset + size]\n        except IndexError as exc:\n            raise ValueError(f\"Content not found at offset {offset}\") from exc\n\n    def read_string(self, offset: int, size: Optional[int] = None) -&gt; str:\n        \"\"\"Read a string in the file.\n\n        If the size is not given, Quokka will try to read the string until the\n        first null byte. That works only for null-terminated strings.\n\n        If the string is null terminated, remove the trailing 0.\n\n        Arguments:\n            offset: String file offset\n            size: String size if known.\n\n        Returns:\n            The decoded string\n\n        Raises:\n          ValueError: If the string is not found nor decoded.\n        \"\"\"\n\n        if size is not None:\n            try:\n                string = self.read(offset, size).decode(\"utf-8\")\n            except UnicodeDecodeError as exc:\n                raise ValueError(\"Unable to read or decode the string.\") from exc\n\n        else:\n            try:\n                null_byte = self.content.index(b\"\\x00\", offset)\n            except ValueError as exc:\n                raise ValueError(\n                    \"String is not null-terminated and size was not given\"\n                ) from exc\n\n            string = self.content[offset:null_byte].decode(\"utf-8\")\n\n        # FIX: When returning a single character string, it does not end with a '\\0'\n        if len(string) &gt; 1 and string.endswith(\"\\x00\"):\n            return string[:-1]\n\n        return string\n\n    def read_data(\n        self, offset: int, data_type: DataType, size: Optional[int] = None\n    ) -&gt; Union[int, float, str]:\n        \"\"\"Read the data value.\n\n        If the size is not specified, it is inferred from the data type.\n\n        Arguments:\n            offset: Data file offset\n            data_type: Data type\n            size: Read size\n\n        Returns:\n            The data value\n        \"\"\"\n\n        # Read an int of size `read_size`\n        def read_int(read_size: int) -&gt; int:\n            \"\"\"Read an integer from the binary\"\"\"\n            return int.from_bytes(self.read_bytes(offset, read_size), endianness)\n\n        endianness: Literal[\"big\", \"little\"]\n        if self.endianness == Endianness.BIG_ENDIAN:\n            endianness = \"big\"\n            endianness_sign = \"&gt;\"\n        else:\n            endianness = \"little\"\n            endianness_sign = \"&lt;\"\n\n        if data_type == DataType.ASCII:\n            if size is None:\n                raise ValueError(\"No size specified when reading a DataType.ASCII\")\n            return self.read_string(offset, size)\n        elif data_type == DataType.BYTE:\n            return read_int(1 if size is None else size)\n        elif data_type == DataType.WORD:\n            return read_int(2 if size is None else size)\n        elif data_type == DataType.DOUBLE_WORD:\n            return read_int(4 if size is None else size)\n        elif data_type == DataType.QUAD_WORD:\n            return read_int(8 if size is None else size)\n        elif data_type == DataType.OCTO_WORD:\n            return read_int(16 if size is None else size)\n        elif data_type == DataType.FLOAT:\n            s = 4 if size is None else size\n            return struct.unpack(f\"{endianness_sign}f\", self.read_bytes(offset, s))\n        elif data_type == DataType.DOUBLE:\n            s = 8 if size is None else size\n            return struct.unpack(f\"{endianness_sign}d\", self.read_bytes(offset, s))\n        else:\n            raise NotImplementedError(\n                f\"Cannot read {data_type}. DataType not implemented.\"\n            )\n\n    def read_bytes(self, offset: int, size: int) -&gt; bytes:\n        \"\"\"Read one (or more) byte(s) in the file at `offset`.\n\n        This is mostly used to read instructions.\n\n        Arguments:\n            offset: File offset to read\n            size: Number of bytes to read\n\n        Returns:\n            The bytes values\n        \"\"\"\n        return self.read(offset, size)\n</code></pre>"},{"location":"reference/python/executable/#quokka.executable.Executable.__init__","title":"<code>__init__(path, endianness)</code>","text":"<p>Constructor</p> Source code in <code>quokka/executable.py</code> <pre><code>def __init__(self, path: Union[str, pathlib.Path], endianness: Endianness):\n    \"\"\"Constructor\"\"\"\n    try:\n        with open(path, \"rb\") as file:\n            self.content: bytes = file.read()\n\n    except FileNotFoundError:\n        raise ValueError(\"File not found\")\n\n    self.exec_file: pathlib.Path = pathlib.Path(path)\n    self.endianness: Endianness = endianness\n</code></pre>"},{"location":"reference/python/executable/#quokka.executable.Executable.read","title":"<code>read(offset, size)</code>","text":"<p>Read <code>size</code> at <code>offset</code> in the file.</p> <p>This method should not be used directly and considered as part of a private API. The preferred method are read_bytes / read_string .</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>File offset</p> required <code>size</code> <code>int</code> <p>Read size</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The content that has been read</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>when the value is not in the file</p> Source code in <code>quokka/executable.py</code> <pre><code>def read(self, offset: int, size: int) -&gt; bytes:\n    \"\"\"Read `size` at `offset` in the file.\n\n    This method should not be used directly and considered as part of a private API.\n    The preferred method are read_bytes / read_string .\n\n    Arguments:\n        offset: File offset\n        size: Read size\n\n    Returns:\n        The content that has been read\n\n    Raises:\n        ValueError: when the value is not in the file\n    \"\"\"\n    try:\n        return self.content[offset : offset + size]\n    except IndexError as exc:\n        raise ValueError(f\"Content not found at offset {offset}\") from exc\n</code></pre>"},{"location":"reference/python/executable/#quokka.executable.Executable.read_bytes","title":"<code>read_bytes(offset, size)</code>","text":"<p>Read one (or more) byte(s) in the file at <code>offset</code>.</p> <p>This is mostly used to read instructions.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>File offset to read</p> required <code>size</code> <code>int</code> <p>Number of bytes to read</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The bytes values</p> Source code in <code>quokka/executable.py</code> <pre><code>def read_bytes(self, offset: int, size: int) -&gt; bytes:\n    \"\"\"Read one (or more) byte(s) in the file at `offset`.\n\n    This is mostly used to read instructions.\n\n    Arguments:\n        offset: File offset to read\n        size: Number of bytes to read\n\n    Returns:\n        The bytes values\n    \"\"\"\n    return self.read(offset, size)\n</code></pre>"},{"location":"reference/python/executable/#quokka.executable.Executable.read_data","title":"<code>read_data(offset, data_type, size=None)</code>","text":"<p>Read the data value.</p> <p>If the size is not specified, it is inferred from the data type.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>Data file offset</p> required <code>data_type</code> <code>DataType</code> <p>Data type</p> required <code>size</code> <code>Optional[int]</code> <p>Read size</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[int, float, str]</code> <p>The data value</p> Source code in <code>quokka/executable.py</code> <pre><code>def read_data(\n    self, offset: int, data_type: DataType, size: Optional[int] = None\n) -&gt; Union[int, float, str]:\n    \"\"\"Read the data value.\n\n    If the size is not specified, it is inferred from the data type.\n\n    Arguments:\n        offset: Data file offset\n        data_type: Data type\n        size: Read size\n\n    Returns:\n        The data value\n    \"\"\"\n\n    # Read an int of size `read_size`\n    def read_int(read_size: int) -&gt; int:\n        \"\"\"Read an integer from the binary\"\"\"\n        return int.from_bytes(self.read_bytes(offset, read_size), endianness)\n\n    endianness: Literal[\"big\", \"little\"]\n    if self.endianness == Endianness.BIG_ENDIAN:\n        endianness = \"big\"\n        endianness_sign = \"&gt;\"\n    else:\n        endianness = \"little\"\n        endianness_sign = \"&lt;\"\n\n    if data_type == DataType.ASCII:\n        if size is None:\n            raise ValueError(\"No size specified when reading a DataType.ASCII\")\n        return self.read_string(offset, size)\n    elif data_type == DataType.BYTE:\n        return read_int(1 if size is None else size)\n    elif data_type == DataType.WORD:\n        return read_int(2 if size is None else size)\n    elif data_type == DataType.DOUBLE_WORD:\n        return read_int(4 if size is None else size)\n    elif data_type == DataType.QUAD_WORD:\n        return read_int(8 if size is None else size)\n    elif data_type == DataType.OCTO_WORD:\n        return read_int(16 if size is None else size)\n    elif data_type == DataType.FLOAT:\n        s = 4 if size is None else size\n        return struct.unpack(f\"{endianness_sign}f\", self.read_bytes(offset, s))\n    elif data_type == DataType.DOUBLE:\n        s = 8 if size is None else size\n        return struct.unpack(f\"{endianness_sign}d\", self.read_bytes(offset, s))\n    else:\n        raise NotImplementedError(\n            f\"Cannot read {data_type}. DataType not implemented.\"\n        )\n</code></pre>"},{"location":"reference/python/executable/#quokka.executable.Executable.read_string","title":"<code>read_string(offset, size=None)</code>","text":"<p>Read a string in the file.</p> <p>If the size is not given, Quokka will try to read the string until the first null byte. That works only for null-terminated strings.</p> <p>If the string is null terminated, remove the trailing 0.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>String file offset</p> required <code>size</code> <code>Optional[int]</code> <p>String size if known.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The decoded string</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the string is not found nor decoded.</p> Source code in <code>quokka/executable.py</code> <pre><code>def read_string(self, offset: int, size: Optional[int] = None) -&gt; str:\n    \"\"\"Read a string in the file.\n\n    If the size is not given, Quokka will try to read the string until the\n    first null byte. That works only for null-terminated strings.\n\n    If the string is null terminated, remove the trailing 0.\n\n    Arguments:\n        offset: String file offset\n        size: String size if known.\n\n    Returns:\n        The decoded string\n\n    Raises:\n      ValueError: If the string is not found nor decoded.\n    \"\"\"\n\n    if size is not None:\n        try:\n            string = self.read(offset, size).decode(\"utf-8\")\n        except UnicodeDecodeError as exc:\n            raise ValueError(\"Unable to read or decode the string.\") from exc\n\n    else:\n        try:\n            null_byte = self.content.index(b\"\\x00\", offset)\n        except ValueError as exc:\n            raise ValueError(\n                \"String is not null-terminated and size was not given\"\n            ) from exc\n\n        string = self.content[offset:null_byte].decode(\"utf-8\")\n\n    # FIX: When returning a single character string, it does not end with a '\\0'\n    if len(string) &gt; 1 and string.endswith(\"\\x00\"):\n        return string[:-1]\n\n    return string\n</code></pre>"},{"location":"reference/python/function/","title":"function","text":"<p>Functions and chunk management</p>"},{"location":"reference/python/function/#quokka.function.Chunk","title":"<code>Chunk</code>","text":"<p>               Bases: <code>MutableMapping</code>, <code>Iterable</code></p> <p>Chunk object</p> <p>A chunk is an IDA specific item that is used for code reuse across functions.</p> <p>Parameters:</p> Name Type Description Default <code>chunk_idx</code> <code>Index</code> <p>Index of the chunk in the protobuf</p> required <code>program</code> <code>Program</code> <p>Backref to the program</p> required <code>accepted_addresses</code> <code>List[AddressT]</code> <p>A list of address for blocks heads. Used only for fake chunks.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>program</code> <code>Program</code> <p>Program reference</p> <code>proto_index</code> <code>Index</code> <p>Index inside the protobuf</p> <code>start</code> <code>AddressT</code> <p>Start address</p> <code>fake</code> <code>bool</code> <p>Is the chunk fake?</p> <code>index_to_address</code> <code>Dict[int, int]</code> <p>Mapping from index to block starting address</p> <code>chunk_type</code> <code>FunctionType</code> <p>Chunk type</p> <code>chunk</code> <p>Proto information</p> Source code in <code>quokka/function.py</code> <pre><code>class Chunk(MutableMapping, Iterable):\n    \"\"\"Chunk object\n\n    A chunk is an IDA specific item that is used for code reuse across functions.\n\n    Arguments:\n        chunk_idx: Index of the chunk in the protobuf\n        program: Backref to the program\n        accepted_addresses: A list of address for blocks heads. Used only\n            for fake chunks.\n\n    Attributes:\n        program: Program reference\n        proto_index: Index inside the protobuf\n        start: Start address\n        fake: Is the chunk fake?\n        index_to_address: Mapping from index to block starting address\n        chunk_type: Chunk type\n        chunk: Proto information\n    \"\"\"\n\n    def __init__(\n        self,\n        chunk_idx: Index,\n        program: quokka.Program,\n        accepted_addresses: List[AddressT] = None,\n    ):\n        \"\"\"Constructor\"\"\"\n        self.program: quokka.Program = program\n\n        self.proto_index: Index = chunk_idx\n        chunk = self.program.proto.function_chunks[chunk_idx]\n\n        self.start: AddressT = self.program.addresser.absolute(chunk.offset_start)\n\n        self.fake: bool = chunk.is_fake\n        self._raw_dict: Dict[AddressT, Index] = {}\n\n        self._graph: Optional[\"networkx.DiGraph\"] = None\n\n        self.index_to_address: Dict[int, int] = {}\n        self.chunk = chunk\n\n        self.chunk_type: FunctionType = FunctionType.NORMAL\n\n        for block_index, block in enumerate(self.chunk.blocks):\n            block_address: int = self.start + block.offset_start\n\n            if (\n                accepted_addresses is not None\n                and block_address not in accepted_addresses\n            ):\n                continue\n\n            self.index_to_address[block_index] = block_address\n            self._raw_dict[block_address] = block_index\n\n        if self.index_to_address:\n            # We only update the start when we have a fake chunk (because it may have\n            # been split out)\n            if chunk.is_fake:\n                self.start = min(self.index_to_address.values())\n\n            assert self.start == min(\n                self.index_to_address.values()\n            ), \"Wrong start of Chunk\"\n\n    def __len__(self) -&gt; int:\n        \"\"\"Number of blocks in the chunk\"\"\"\n        return len(self._raw_dict)\n\n    def __iter__(self) -&gt; Iterator:\n        \"\"\"Iterator over the blocks\"\"\"\n        return self._raw_dict.__iter__()\n\n    def __setitem__(self, k: AddressT, v: Index) -&gt; None:\n        \"\"\"Set block\"\"\"\n        self._raw_dict.__setitem__(k, v)\n\n    def __delitem__(self, k: int) -&gt; None:\n        \"\"\"Remove a block\"\"\"\n        self._raw_dict.__delitem__(k)\n\n    def __getitem__(self, address: AddressT) -&gt; quokka.Block:\n        \"\"\"Lazy loader for blocks\"\"\"\n        index: Index = self._raw_dict.__getitem__(address)\n        return quokka.block.Block(index, address, self)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Chunk representation\"\"\"\n        return f\"&lt;Chunk at 0x{self.start:x} with {len(self)} block(s)&gt;\"\n\n    @property\n    def block_ranges(self) -&gt; List[Tuple[AddressT, AddressT]]:\n        \"\"\"Returns the sorted list of block ranges.\n\n        A block range is a tuple (block.start, block.end).\n        \"\"\"\n        block_ranges = []\n        for block in self.values():\n            block_ranges.append((block.start, block.end))\n\n        block_ranges = sorted(block_ranges)\n        return block_ranges\n\n    @cached_property\n    def graph(self) -&gt; \"networkx.DiGraph\":\n        \"\"\"Return the CFG of the chunk as DiGraph object\"\"\"\n        graph = networkx.DiGraph()\n        graph.add_nodes_from(n for n in self._raw_dict)\n\n        for edge in self.program.proto.function_chunks[self.proto_index].edges:\n            if (\n                edge.source.block_id not in self.index_to_address\n                or edge.destination.block_id not in self.index_to_address\n            ):\n                continue\n            graph.add_edge(\n                self.index_to_address[edge.source.block_id],\n                self.index_to_address[edge.destination.block_id],\n                condition=EdgeType.from_proto(edge.edge_type),\n            )\n\n        return graph\n\n    @cached_property\n    def strings(self) -&gt; List[str]:\n        \"\"\"Return the strings used in the chunk\"\"\"\n\n        strings = set()\n        for block in self.values():\n            strings.update(block.strings)\n\n        return list(strings)\n\n    @cached_property\n    def constants(self) -&gt; List[int]:\n        \"\"\"Return the constants used in the chunk\"\"\"\n        constants = []\n        for block in self.values():\n            constants.extend(block.constants)\n\n        return constants\n\n    @property\n    def data_references(self) -&gt; List[quokka.Data]:\n        \"\"\"Returns the data reference in the chunk\"\"\"\n        data_references: List[quokka.Data] = []\n        for instruction in self.values():\n            data_references.extend(instruction.data_references)\n\n        return data_references\n\n    @cached_property\n    def end(self) -&gt; AddressT:\n        \"\"\"Compute the end address of a chunk\"\"\"\n        try:\n            max_block = max(self.keys())\n            return self[max_block].end\n        except ValueError:\n            return self.start + 1\n\n    @cached_property\n    def size(self) -&gt; int:\n        \"\"\"Return the size of a chunk\"\"\"\n        return self.end - self.start\n\n    @property\n    def calls(self) -&gt; List[quokka.Chunk]:\n        \"\"\"Return the list of calls made by this chunk.\n        The semantic of a \"call\" is to jump or call to the **starting** chunk of a function.\n        Beware that this might lead to different results than the program call graph.\n\n        Note: The list is not deduplicated so a target may occur multiple time.\n        \"\"\"\n\n        calls = []\n        for inst_instance in self.program.references.resolve_calls(self, towards=False):\n            chunk = (\n                inst_instance[0] if isinstance(inst_instance, tuple) else inst_instance\n            )\n            # Check that the chunk is the **starting** chunk of a function\n            if chunk.start in self.program:\n                calls.append(chunk)\n\n        return calls\n\n    @property\n    def callers(self) -&gt; List[Chunk]:\n        \"\"\"Return the list of callers of this chunk.\"\"\"\n\n        callers = []\n        for inst_instance in self.program.references.resolve_calls(self, towards=True):\n            if isinstance(inst_instance, tuple):\n                callers.append(inst_instance[0])\n            else:\n                callers.append(inst_instance)\n\n        return callers\n\n    @cached_property\n    def out_degree(self) -&gt; int:\n        \"\"\"Compute the chunk out degree\n\n        Get the out degree of a chunk (e.g. the number of distinct chunks called by\n        this one).\n\n        Returns:\n            Number of distinct out edges\n        \"\"\"\n        return len(set(self.calls))\n\n    @cached_property\n    def in_degree(self) -&gt; int:\n        \"\"\"Compute the chunk in degree\n\n        Get the in-degree of a chunk. This is the number of distinct incoming edges.\n\n        returns:\n            Chunk in-degree\n        \"\"\"\n        return len(set(self.callers))\n\n    @property\n    def instructions(self) -&gt; Generator:\n        \"\"\"Iterator over instructions in the chunk\"\"\"\n        return (inst for block in self.values() for inst in block.instructions)\n\n    def in_chunk(self, address: AddressT) -&gt; bool:\n        \"\"\"Check if an address belongs to the chunk.\"\"\"\n        if len(self.block_ranges) == 0:\n            return False\n\n        if address &lt; min(self.block_ranges)[0] or address &gt; max(self.block_ranges)[1]:\n            return False\n\n        for start, end in self.block_ranges:\n            if start &lt;= address &lt; end:\n                return True\n\n        return False\n\n    def get_instruction(self, address: AddressT) -&gt; quokka.Instruction:\n        \"\"\"Get the instruction at `address`\"\"\"\n        if not self.in_chunk(address):\n            raise IndexError(f\"Unable to find the instruction at 0x{address:x}\")\n\n        for block in self.values():\n            if block.start &lt;= address &lt; block.end:\n                return block[address]\n\n        raise IndexError(f\"Unable to find the instruction at 0x{address:x}\")\n\n    def get_block(self, address: AddressT) -&gt; quokka.Block:\n        \"\"\"Get the block at `address`\"\"\"\n        return self.__getitem__(address)\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Override hash method to return an unique index\"\"\"\n        return self.start\n\n    @cached_property\n    def name(self) -&gt; str:\n        \"\"\"Chunk name.\n\n        The chunk name is the one of its parent if it exists or is empty otherwise.\n\n        Returns:\n            Chunk name\n        \"\"\"\n        try:\n            return self.program.get_first_function_by_chunk(self).name\n        except quokka.exc.FunctionMissingError:\n            return \"\"\n</code></pre>"},{"location":"reference/python/function/#quokka.function.Chunk.block_ranges","title":"<code>block_ranges</code>  <code>property</code>","text":"<p>Returns the sorted list of block ranges.</p> <p>A block range is a tuple (block.start, block.end).</p>"},{"location":"reference/python/function/#quokka.function.Chunk.callers","title":"<code>callers</code>  <code>property</code>","text":"<p>Return the list of callers of this chunk.</p>"},{"location":"reference/python/function/#quokka.function.Chunk.calls","title":"<code>calls</code>  <code>property</code>","text":"<p>Return the list of calls made by this chunk. The semantic of a \"call\" is to jump or call to the starting chunk of a function. Beware that this might lead to different results than the program call graph.</p> <p>Note: The list is not deduplicated so a target may occur multiple time.</p>"},{"location":"reference/python/function/#quokka.function.Chunk.constants","title":"<code>constants</code>  <code>cached</code> <code>property</code>","text":"<p>Return the constants used in the chunk</p>"},{"location":"reference/python/function/#quokka.function.Chunk.data_references","title":"<code>data_references</code>  <code>property</code>","text":"<p>Returns the data reference in the chunk</p>"},{"location":"reference/python/function/#quokka.function.Chunk.end","title":"<code>end</code>  <code>cached</code> <code>property</code>","text":"<p>Compute the end address of a chunk</p>"},{"location":"reference/python/function/#quokka.function.Chunk.graph","title":"<code>graph</code>  <code>cached</code> <code>property</code>","text":"<p>Return the CFG of the chunk as DiGraph object</p>"},{"location":"reference/python/function/#quokka.function.Chunk.in_degree","title":"<code>in_degree</code>  <code>cached</code> <code>property</code>","text":"<p>Compute the chunk in degree</p> <p>Get the in-degree of a chunk. This is the number of distinct incoming edges.</p> <p>Returns:</p> Type Description <code>int</code> <p>Chunk in-degree</p>"},{"location":"reference/python/function/#quokka.function.Chunk.instructions","title":"<code>instructions</code>  <code>property</code>","text":"<p>Iterator over instructions in the chunk</p>"},{"location":"reference/python/function/#quokka.function.Chunk.name","title":"<code>name</code>  <code>cached</code> <code>property</code>","text":"<p>Chunk name.</p> <p>The chunk name is the one of its parent if it exists or is empty otherwise.</p> <p>Returns:</p> Type Description <code>str</code> <p>Chunk name</p>"},{"location":"reference/python/function/#quokka.function.Chunk.out_degree","title":"<code>out_degree</code>  <code>cached</code> <code>property</code>","text":"<p>Compute the chunk out degree</p> <p>Get the out degree of a chunk (e.g. the number of distinct chunks called by this one).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of distinct out edges</p>"},{"location":"reference/python/function/#quokka.function.Chunk.size","title":"<code>size</code>  <code>cached</code> <code>property</code>","text":"<p>Return the size of a chunk</p>"},{"location":"reference/python/function/#quokka.function.Chunk.strings","title":"<code>strings</code>  <code>cached</code> <code>property</code>","text":"<p>Return the strings used in the chunk</p>"},{"location":"reference/python/function/#quokka.function.Chunk.__delitem__","title":"<code>__delitem__(k)</code>","text":"<p>Remove a block</p> Source code in <code>quokka/function.py</code> <pre><code>def __delitem__(self, k: int) -&gt; None:\n    \"\"\"Remove a block\"\"\"\n    self._raw_dict.__delitem__(k)\n</code></pre>"},{"location":"reference/python/function/#quokka.function.Chunk.__getitem__","title":"<code>__getitem__(address)</code>","text":"<p>Lazy loader for blocks</p> Source code in <code>quokka/function.py</code> <pre><code>def __getitem__(self, address: AddressT) -&gt; quokka.Block:\n    \"\"\"Lazy loader for blocks\"\"\"\n    index: Index = self._raw_dict.__getitem__(address)\n    return quokka.block.Block(index, address, self)\n</code></pre>"},{"location":"reference/python/function/#quokka.function.Chunk.__hash__","title":"<code>__hash__()</code>","text":"<p>Override hash method to return an unique index</p> Source code in <code>quokka/function.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Override hash method to return an unique index\"\"\"\n    return self.start\n</code></pre>"},{"location":"reference/python/function/#quokka.function.Chunk.__init__","title":"<code>__init__(chunk_idx, program, accepted_addresses=None)</code>","text":"<p>Constructor</p> Source code in <code>quokka/function.py</code> <pre><code>def __init__(\n    self,\n    chunk_idx: Index,\n    program: quokka.Program,\n    accepted_addresses: List[AddressT] = None,\n):\n    \"\"\"Constructor\"\"\"\n    self.program: quokka.Program = program\n\n    self.proto_index: Index = chunk_idx\n    chunk = self.program.proto.function_chunks[chunk_idx]\n\n    self.start: AddressT = self.program.addresser.absolute(chunk.offset_start)\n\n    self.fake: bool = chunk.is_fake\n    self._raw_dict: Dict[AddressT, Index] = {}\n\n    self._graph: Optional[\"networkx.DiGraph\"] = None\n\n    self.index_to_address: Dict[int, int] = {}\n    self.chunk = chunk\n\n    self.chunk_type: FunctionType = FunctionType.NORMAL\n\n    for block_index, block in enumerate(self.chunk.blocks):\n        block_address: int = self.start + block.offset_start\n\n        if (\n            accepted_addresses is not None\n            and block_address not in accepted_addresses\n        ):\n            continue\n\n        self.index_to_address[block_index] = block_address\n        self._raw_dict[block_address] = block_index\n\n    if self.index_to_address:\n        # We only update the start when we have a fake chunk (because it may have\n        # been split out)\n        if chunk.is_fake:\n            self.start = min(self.index_to_address.values())\n\n        assert self.start == min(\n            self.index_to_address.values()\n        ), \"Wrong start of Chunk\"\n</code></pre>"},{"location":"reference/python/function/#quokka.function.Chunk.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterator over the blocks</p> Source code in <code>quokka/function.py</code> <pre><code>def __iter__(self) -&gt; Iterator:\n    \"\"\"Iterator over the blocks\"\"\"\n    return self._raw_dict.__iter__()\n</code></pre>"},{"location":"reference/python/function/#quokka.function.Chunk.__len__","title":"<code>__len__()</code>","text":"<p>Number of blocks in the chunk</p> Source code in <code>quokka/function.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Number of blocks in the chunk\"\"\"\n    return len(self._raw_dict)\n</code></pre>"},{"location":"reference/python/function/#quokka.function.Chunk.__setitem__","title":"<code>__setitem__(k, v)</code>","text":"<p>Set block</p> Source code in <code>quokka/function.py</code> <pre><code>def __setitem__(self, k: AddressT, v: Index) -&gt; None:\n    \"\"\"Set block\"\"\"\n    self._raw_dict.__setitem__(k, v)\n</code></pre>"},{"location":"reference/python/function/#quokka.function.Chunk.__str__","title":"<code>__str__()</code>","text":"<p>Chunk representation</p> Source code in <code>quokka/function.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Chunk representation\"\"\"\n    return f\"&lt;Chunk at 0x{self.start:x} with {len(self)} block(s)&gt;\"\n</code></pre>"},{"location":"reference/python/function/#quokka.function.Chunk.get_block","title":"<code>get_block(address)</code>","text":"<p>Get the block at <code>address</code></p> Source code in <code>quokka/function.py</code> <pre><code>def get_block(self, address: AddressT) -&gt; quokka.Block:\n    \"\"\"Get the block at `address`\"\"\"\n    return self.__getitem__(address)\n</code></pre>"},{"location":"reference/python/function/#quokka.function.Chunk.get_instruction","title":"<code>get_instruction(address)</code>","text":"<p>Get the instruction at <code>address</code></p> Source code in <code>quokka/function.py</code> <pre><code>def get_instruction(self, address: AddressT) -&gt; quokka.Instruction:\n    \"\"\"Get the instruction at `address`\"\"\"\n    if not self.in_chunk(address):\n        raise IndexError(f\"Unable to find the instruction at 0x{address:x}\")\n\n    for block in self.values():\n        if block.start &lt;= address &lt; block.end:\n            return block[address]\n\n    raise IndexError(f\"Unable to find the instruction at 0x{address:x}\")\n</code></pre>"},{"location":"reference/python/function/#quokka.function.Chunk.in_chunk","title":"<code>in_chunk(address)</code>","text":"<p>Check if an address belongs to the chunk.</p> Source code in <code>quokka/function.py</code> <pre><code>def in_chunk(self, address: AddressT) -&gt; bool:\n    \"\"\"Check if an address belongs to the chunk.\"\"\"\n    if len(self.block_ranges) == 0:\n        return False\n\n    if address &lt; min(self.block_ranges)[0] or address &gt; max(self.block_ranges)[1]:\n        return False\n\n    for start, end in self.block_ranges:\n        if start &lt;= address &lt; end:\n            return True\n\n    return False\n</code></pre>"},{"location":"reference/python/function/#quokka.function.Function","title":"<code>Function</code>","text":"<p>               Bases: <code>dict</code></p> <p>Function object</p> <p>This class represents a binary function within the Program.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>'quokka.pb.Quokka.Function'</code> <p>Protobuf data</p> required <code>program</code> <code>Program</code> <p>Program reference</p> required <p>Attributes:</p> Name Type Description <code>start</code> <code>int</code> <p>Start address</p> <code>name</code> <code>str</code> <p>Function name</p> <code>mangled_name</code> <code>str</code> <p>Function mangled name (it might be equal to the function name)</p> <code>program</code> <code>Program</code> <p>Program reference</p> <code>type</code> <code>'FunctionType'</code> <p>Function type</p> <code>index_to_address</code> <code>Dict[int, int]</code> <p>Mapping of Chunks to Protobuf indexes</p> <code>func</code> <p>Protobuf data</p> Source code in <code>quokka/function.py</code> <pre><code>class Function(dict):\n    \"\"\"Function object\n\n    This class represents a binary function within the Program.\n\n    Arguments:\n        func: Protobuf data\n        program: Program reference\n\n    Attributes:\n        start: Start address\n        name: Function name\n        mangled_name: Function mangled name (it might be equal to the function name)\n        program: Program reference\n        type: Function type\n        index_to_address: Mapping of Chunks to Protobuf indexes\n        func: Protobuf data\n    \"\"\"\n\n    def __init__(self, func: \"quokka.pb.Quokka.Function\", program: quokka.Program):\n        \"\"\"Constructor\"\"\"\n        super(dict, self).__init__()\n        self.start: int = program.addresser.absolute(func.offset)\n        self.name: str = func.name\n        self.mangled_name: str = func.mangled_name or func.name\n\n        self.program: quokka.Program = program\n\n        self.type: \"FunctionType\" = FunctionType.from_proto(func.function_type)\n        if self.type == FunctionType.NORMAL:\n            segment = self.program.get_segment(self.start)\n            if segment and segment.type == SegmentType.EXTERN:\n                self.type = FunctionType.EXTERN\n\n        self.index_to_address: Dict[int, int] = {}\n        for chunk_index in func.function_chunks_index:\n            chunk = self.program.get_chunk(chunk_index)\n\n            if not isinstance(chunk, quokka.function.Chunk):\n                logger.error(\"Found a super chunk in a function which is not possible\")\n                continue\n\n            if chunk.chunk_type not in {FunctionType.NORMAL, self.type}:\n                logger.error(\n                    \"All the chunks of the function are supposed to have the same \"\n                    \"type. It is not the case here.\"\n                )\n\n            chunk.chunk_type = self.type\n            self[chunk.start] = chunk\n\n            self.index_to_address[chunk_index] = chunk.start\n\n        self.func = func\n\n        self._data_references: List[quokka.Data] = None\n\n    def get_block(self, address: AddressT) -&gt; quokka.Block:\n        \"\"\"Get the block at `address`\"\"\"\n        for chunk in self.values():\n            try:\n                return chunk[address]\n            except KeyError:\n                pass\n\n        raise KeyError(f\"Unable to find the block at address 0x{address:x}\")\n\n    def get_instruction(self, address: AddressT) -&gt; quokka.Instruction:\n        \"\"\"Get the instruction at `address`\"\"\"\n        for chunk in self.values():\n            if chunk.in_chunk(address):\n                return chunk.get_instruction(address)\n\n        raise IndexError(f\"Unable to find the instruction at 0x{address:x}\")\n\n    @cached_property\n    def strings(self) -&gt; List[str]:\n        \"\"\"Return the list of strings used in the function\"\"\"\n        strings = set()\n        for chunk in self.values():\n            strings.update(chunk.strings)\n\n        return list(strings)\n\n    @property\n    def data_references(self):\n        \"\"\"Lists data references used in the function\"\"\"\n        data_references: List[quokka.Data] = []\n        for instruction in self.values():\n            data_references.extend(instruction.data_references)\n\n        return data_references\n\n    @cached_property\n    def constants(self) -&gt; List[int]:\n        \"\"\"Lists constants used in the function\"\"\"\n        constants: List[int] = []\n        for chunk in self.values():\n            constants.extend(chunk.constants)\n\n        return constants\n\n    @cached_property\n    def graph(self) -&gt; \"networkx.DiGraph\":\n        \"\"\"Compute the Control Flow Graph for the function\"\"\"\n        graph = networkx.DiGraph()\n        for chunk in self.values():\n            graph = networkx.algorithms.operators.compose(graph, chunk.graph)\n\n        for edge in self.func.chunk_edges:\n            source_chunk = self.program.get_chunk(\n                edge.source.chunk_id, edge.source.block_id\n            )\n            dest_chunk = self.program.get_chunk(\n                edge.destination.chunk_id, edge.destination.block_id\n            )\n\n            graph.add_edge(\n                source_chunk.index_to_address[edge.source.block_id],\n                dest_chunk.index_to_address[edge.destination.block_id],\n                condition=EdgeType.from_proto(edge.edge_type),\n            )\n\n        return graph\n\n    @cached_property\n    def end(self) -&gt; int:\n        \"\"\"Get the last address of the function\"\"\"\n        max_chunk = max(self.keys())\n        return self[max_chunk].end\n\n    @property\n    def calls(self) -&gt; List[Chunk]:\n        \"\"\"Retrieve the function calls (the ones called by the function)\"\"\"\n        targets = []\n        for chunk in self.values():\n            targets.extend(chunk.calls)\n\n        return targets\n\n    @property\n    def callers(self) -&gt; List[Chunk]:\n        \"\"\"Retrieve the function callers (the ones calling this function)\"\"\"\n        sources = []\n        for chunk in self.values():\n            sources.extend(chunk.callers)\n\n        return sources\n\n    @property\n    def instructions(self):\n        \"\"\"Yields the function instruction\"\"\"\n        return itertools.chain.from_iterable(\n            chunk.instructions for chunk in self.values()\n        )\n\n    def in_func(self, address: AddressT) -&gt; bool:\n        \"\"\"Check if the `address` belongs to this function.\"\"\"\n        for chunk in self.values():\n            if chunk.in_chunk(address):\n                return True\n\n        return False\n\n    @cached_property\n    def out_degree(self) -&gt; int:\n        \"\"\"Function out degree\"\"\"\n        return len(set(self.calls))\n\n    @cached_property\n    def in_degree(self) -&gt; int:\n        \"\"\"Function in degree\"\"\"\n        return self[self.start].in_degree\n\n    @property\n    def blocks(self) -&gt; dict[AddressT, quokka.Block]:\n        \"\"\"Returns a dictionary which is used to reference all basic blocks\n        by their address.\n        Calling this function will also load the CFG.\n        \"\"\"\n        return {addr: self.get_block(addr) for addr in self.graph.nodes}\n\n    def __hash__(self) -&gt; int:  # type: ignore\n        \"\"\"Hash value\"\"\"\n        return self.start\n\n    def __str__(self) -&gt; str:\n        \"\"\"Function representation\"\"\"\n        return f\"&lt;Function {self.name} at 0x{self.start:x}&gt;\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Function representation\"\"\"\n        return self.__str__()\n</code></pre>"},{"location":"reference/python/function/#quokka.function.Function.blocks","title":"<code>blocks</code>  <code>property</code>","text":"<p>Returns a dictionary which is used to reference all basic blocks by their address. Calling this function will also load the CFG.</p>"},{"location":"reference/python/function/#quokka.function.Function.callers","title":"<code>callers</code>  <code>property</code>","text":"<p>Retrieve the function callers (the ones calling this function)</p>"},{"location":"reference/python/function/#quokka.function.Function.calls","title":"<code>calls</code>  <code>property</code>","text":"<p>Retrieve the function calls (the ones called by the function)</p>"},{"location":"reference/python/function/#quokka.function.Function.constants","title":"<code>constants</code>  <code>cached</code> <code>property</code>","text":"<p>Lists constants used in the function</p>"},{"location":"reference/python/function/#quokka.function.Function.data_references","title":"<code>data_references</code>  <code>property</code>","text":"<p>Lists data references used in the function</p>"},{"location":"reference/python/function/#quokka.function.Function.end","title":"<code>end</code>  <code>cached</code> <code>property</code>","text":"<p>Get the last address of the function</p>"},{"location":"reference/python/function/#quokka.function.Function.graph","title":"<code>graph</code>  <code>cached</code> <code>property</code>","text":"<p>Compute the Control Flow Graph for the function</p>"},{"location":"reference/python/function/#quokka.function.Function.in_degree","title":"<code>in_degree</code>  <code>cached</code> <code>property</code>","text":"<p>Function in degree</p>"},{"location":"reference/python/function/#quokka.function.Function.instructions","title":"<code>instructions</code>  <code>property</code>","text":"<p>Yields the function instruction</p>"},{"location":"reference/python/function/#quokka.function.Function.out_degree","title":"<code>out_degree</code>  <code>cached</code> <code>property</code>","text":"<p>Function out degree</p>"},{"location":"reference/python/function/#quokka.function.Function.strings","title":"<code>strings</code>  <code>cached</code> <code>property</code>","text":"<p>Return the list of strings used in the function</p>"},{"location":"reference/python/function/#quokka.function.Function.__hash__","title":"<code>__hash__()</code>","text":"<p>Hash value</p> Source code in <code>quokka/function.py</code> <pre><code>def __hash__(self) -&gt; int:  # type: ignore\n    \"\"\"Hash value\"\"\"\n    return self.start\n</code></pre>"},{"location":"reference/python/function/#quokka.function.Function.__init__","title":"<code>__init__(func, program)</code>","text":"<p>Constructor</p> Source code in <code>quokka/function.py</code> <pre><code>def __init__(self, func: \"quokka.pb.Quokka.Function\", program: quokka.Program):\n    \"\"\"Constructor\"\"\"\n    super(dict, self).__init__()\n    self.start: int = program.addresser.absolute(func.offset)\n    self.name: str = func.name\n    self.mangled_name: str = func.mangled_name or func.name\n\n    self.program: quokka.Program = program\n\n    self.type: \"FunctionType\" = FunctionType.from_proto(func.function_type)\n    if self.type == FunctionType.NORMAL:\n        segment = self.program.get_segment(self.start)\n        if segment and segment.type == SegmentType.EXTERN:\n            self.type = FunctionType.EXTERN\n\n    self.index_to_address: Dict[int, int] = {}\n    for chunk_index in func.function_chunks_index:\n        chunk = self.program.get_chunk(chunk_index)\n\n        if not isinstance(chunk, quokka.function.Chunk):\n            logger.error(\"Found a super chunk in a function which is not possible\")\n            continue\n\n        if chunk.chunk_type not in {FunctionType.NORMAL, self.type}:\n            logger.error(\n                \"All the chunks of the function are supposed to have the same \"\n                \"type. It is not the case here.\"\n            )\n\n        chunk.chunk_type = self.type\n        self[chunk.start] = chunk\n\n        self.index_to_address[chunk_index] = chunk.start\n\n    self.func = func\n\n    self._data_references: List[quokka.Data] = None\n</code></pre>"},{"location":"reference/python/function/#quokka.function.Function.__repr__","title":"<code>__repr__()</code>","text":"<p>Function representation</p> Source code in <code>quokka/function.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Function representation\"\"\"\n    return self.__str__()\n</code></pre>"},{"location":"reference/python/function/#quokka.function.Function.__str__","title":"<code>__str__()</code>","text":"<p>Function representation</p> Source code in <code>quokka/function.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Function representation\"\"\"\n    return f\"&lt;Function {self.name} at 0x{self.start:x}&gt;\"\n</code></pre>"},{"location":"reference/python/function/#quokka.function.Function.get_block","title":"<code>get_block(address)</code>","text":"<p>Get the block at <code>address</code></p> Source code in <code>quokka/function.py</code> <pre><code>def get_block(self, address: AddressT) -&gt; quokka.Block:\n    \"\"\"Get the block at `address`\"\"\"\n    for chunk in self.values():\n        try:\n            return chunk[address]\n        except KeyError:\n            pass\n\n    raise KeyError(f\"Unable to find the block at address 0x{address:x}\")\n</code></pre>"},{"location":"reference/python/function/#quokka.function.Function.get_instruction","title":"<code>get_instruction(address)</code>","text":"<p>Get the instruction at <code>address</code></p> Source code in <code>quokka/function.py</code> <pre><code>def get_instruction(self, address: AddressT) -&gt; quokka.Instruction:\n    \"\"\"Get the instruction at `address`\"\"\"\n    for chunk in self.values():\n        if chunk.in_chunk(address):\n            return chunk.get_instruction(address)\n\n    raise IndexError(f\"Unable to find the instruction at 0x{address:x}\")\n</code></pre>"},{"location":"reference/python/function/#quokka.function.Function.in_func","title":"<code>in_func(address)</code>","text":"<p>Check if the <code>address</code> belongs to this function.</p> Source code in <code>quokka/function.py</code> <pre><code>def in_func(self, address: AddressT) -&gt; bool:\n    \"\"\"Check if the `address` belongs to this function.\"\"\"\n    for chunk in self.values():\n        if chunk.in_chunk(address):\n            return True\n\n    return False\n</code></pre>"},{"location":"reference/python/function/#quokka.function.SuperChunk","title":"<code>SuperChunk</code>","text":"<p>               Bases: <code>MutableMapping</code></p> <p>SuperChunk: fake functions</p> <p>A SuperChunk is an abstract construction that has no other meaning that serve as a candidate (or fake) function.</p> <p>Indeed, super chunks are created when a chunk (or a fake chunk) have multiple non-connected components.</p> <p>A superchunk keeps a mapping of chunk index to chunk instance and implements most of a function interface.</p> <p>Parameters:</p> Name Type Description Default <code>initial_chunk</code> <code>Chunk</code> <p>The chunk to split</p> required <code>components</code> <code>Generator</code> <p>The various non-connected components</p> required <p>Attributes:</p> Name Type Description <code>proto_idx</code> <code>Index</code> <p>Initial chunk proto index</p> <code>addresses</code> <code>Dict[AddressT, int]</code> <p>All addresses belonging to the chunk with the instruction index</p> <code>chunks</code> <code>Dict[Index, Chunk]</code> <p>Mapping of chunks within the SuperChunk</p> <code>starts</code> <code>Dict[AddressT, Chunk]</code> <p>Mapping of chunk starts to chunks</p> Source code in <code>quokka/function.py</code> <pre><code>class SuperChunk(MutableMapping):\n    \"\"\"SuperChunk: fake functions\n\n    A SuperChunk is an abstract construction that has no other meaning that serve as\n    a candidate (or fake) function.\n\n    Indeed, super chunks are created when a chunk (or a fake chunk) have multiple\n    non-connected components.\n\n    A superchunk keeps a mapping of chunk index to chunk instance and implements most\n    of a function interface.\n\n    Arguments:\n        initial_chunk: The chunk to split\n        components: The various non-connected components\n\n    Attributes:\n        proto_idx: Initial chunk proto index\n        addresses: All addresses belonging to the chunk with the instruction index\n        chunks: Mapping of chunks within the SuperChunk\n        starts: Mapping of chunk starts to chunks\n    \"\"\"\n\n    def __init__(self, initial_chunk: Chunk, components: Generator):\n        \"\"\"Init method\n\n        Arguments:\n            initial_chunk: Original chunk to split\n            components: A generator of sets for each component of the graph\n        \"\"\"\n        self.proto_idx: Index = initial_chunk.proto_index\n        self.addresses: Dict[AddressT, int] = {}\n\n        self.chunks: Dict[Index, Chunk] = {}\n        self.starts: Dict[AddressT, Chunk] = {}\n\n        for index, component in enumerate(components):\n            self.addresses.update({block_addr: index for block_addr in component})\n            chunk = Chunk(initial_chunk.proto_index, initial_chunk.program, component)\n            self.chunks[index] = chunk\n            self.starts[min(component)] = chunk\n\n        # We need to keep this mapping sorted to improve efficiency\n        self.addresses = {k: self.addresses[k] for k in sorted(self.addresses)}\n\n    def __setitem__(self, k: Index, v: Chunk) -&gt; None:\n        \"\"\"Set a chunk\"\"\"\n        self.chunks.__setitem__(k, v)\n\n    def __delitem__(self, v: Index) -&gt; None:\n        \"\"\"Delete a chunk\"\"\"\n        self.chunks.__delitem__(v)\n\n    def __getitem__(self, k: Index) -&gt; Chunk:\n        \"\"\"Get a chunk\"\"\"\n        return self.chunks.__getitem__(k)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Number of chunk\"\"\"\n        return self.chunks.__len__()\n\n    def __iter__(self) -&gt; Iterator[Index]:\n        \"\"\"Iterator over chunk\"\"\"\n        return self.chunks.__iter__()\n\n    def __str__(self) -&gt; str:\n        \"\"\"SuperChunk representation\"\"\"\n        return f\"&lt;SuperChunk with {len(self.starts)} chunks(s)&gt;\"\n\n    def get_chunk(self, address: AddressT) -&gt; Chunk:\n        \"\"\"Return a chunk by an address.\n\n        To resolve an address and retrieve the appropriate chunk, we enumerate the\n        chunks and look within the blocks.\n\n        Arguments:\n            address: Address to query\n\n        Raises:\n            IndexError: When no chunk is found\n\n        \"\"\"\n        if address in self.addresses:\n            return self.chunks[self.addresses[address]]\n\n        if address &lt; min(self.addresses):\n            raise IndexError(\"Address is before the chunk\")\n\n        # TODO(dm) CHECK OR FIXME\n        chunk_index = self.addresses[min(self.addresses)]\n        for blocks_head, chunk_index in self.addresses.items():\n            if blocks_head &gt; address:\n                break\n\n        candidate_chunk = self.chunks[chunk_index]\n        if candidate_chunk.in_chunk(address):\n            return candidate_chunk\n\n        raise IndexError(\"Address does not belong in this SuperChunk\")\n\n    def get_chunk_by_index(self, chunk_index: Index, block_index: Index) -&gt; Chunk:\n        \"\"\"Return a chunk by its index\n\n        This must be reimplemented because the chunk_index is unique for the proto but\n        there are multiple chunks existing with the same index because of a SuperChunk.\n\n        Arguments:\n            chunk_index: Chunk index\n            block_index: Block index\n\n        Raises:\n            ChunkMissingError: if the chunk is not found\n\n        \"\"\"\n        if chunk_index != self.proto_idx:\n            raise quokka.exc.ChunkMissingError(\"Wrong chunk index\")\n\n        for chunk in self.chunks.values():\n            if chunk.index_to_address.get(block_index, None) is not None:\n                return chunk\n\n        raise quokka.exc.ChunkMissingError(\n            \"Unable to find the correct chunk for this block\"\n        )\n\n    def in_chunk(self, address: AddressT) -&gt; bool:\n        \"\"\"Check if address belongs to this SuperChunk\"\"\"\n        if address &lt; min(self.starts):\n            return False\n\n        for chunk in self.chunks.values():\n            if chunk.in_chunk(address):\n                return True\n\n        return False\n\n    def get_instruction(self, address: AddressT) -&gt; quokka.Instruction:\n        \"\"\"Get the instruction at `address`\"\"\"\n        for chunk in self.chunks.values():\n            if chunk.in_chunk(address):\n                return chunk.get_instruction(address)\n\n        raise IndexError(f\"Unable to find the instruction at 0x{address:x}\")\n</code></pre>"},{"location":"reference/python/function/#quokka.function.SuperChunk.__delitem__","title":"<code>__delitem__(v)</code>","text":"<p>Delete a chunk</p> Source code in <code>quokka/function.py</code> <pre><code>def __delitem__(self, v: Index) -&gt; None:\n    \"\"\"Delete a chunk\"\"\"\n    self.chunks.__delitem__(v)\n</code></pre>"},{"location":"reference/python/function/#quokka.function.SuperChunk.__getitem__","title":"<code>__getitem__(k)</code>","text":"<p>Get a chunk</p> Source code in <code>quokka/function.py</code> <pre><code>def __getitem__(self, k: Index) -&gt; Chunk:\n    \"\"\"Get a chunk\"\"\"\n    return self.chunks.__getitem__(k)\n</code></pre>"},{"location":"reference/python/function/#quokka.function.SuperChunk.__init__","title":"<code>__init__(initial_chunk, components)</code>","text":"<p>Init method</p> <p>Parameters:</p> Name Type Description Default <code>initial_chunk</code> <code>Chunk</code> <p>Original chunk to split</p> required <code>components</code> <code>Generator</code> <p>A generator of sets for each component of the graph</p> required Source code in <code>quokka/function.py</code> <pre><code>def __init__(self, initial_chunk: Chunk, components: Generator):\n    \"\"\"Init method\n\n    Arguments:\n        initial_chunk: Original chunk to split\n        components: A generator of sets for each component of the graph\n    \"\"\"\n    self.proto_idx: Index = initial_chunk.proto_index\n    self.addresses: Dict[AddressT, int] = {}\n\n    self.chunks: Dict[Index, Chunk] = {}\n    self.starts: Dict[AddressT, Chunk] = {}\n\n    for index, component in enumerate(components):\n        self.addresses.update({block_addr: index for block_addr in component})\n        chunk = Chunk(initial_chunk.proto_index, initial_chunk.program, component)\n        self.chunks[index] = chunk\n        self.starts[min(component)] = chunk\n\n    # We need to keep this mapping sorted to improve efficiency\n    self.addresses = {k: self.addresses[k] for k in sorted(self.addresses)}\n</code></pre>"},{"location":"reference/python/function/#quokka.function.SuperChunk.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterator over chunk</p> Source code in <code>quokka/function.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Index]:\n    \"\"\"Iterator over chunk\"\"\"\n    return self.chunks.__iter__()\n</code></pre>"},{"location":"reference/python/function/#quokka.function.SuperChunk.__len__","title":"<code>__len__()</code>","text":"<p>Number of chunk</p> Source code in <code>quokka/function.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Number of chunk\"\"\"\n    return self.chunks.__len__()\n</code></pre>"},{"location":"reference/python/function/#quokka.function.SuperChunk.__setitem__","title":"<code>__setitem__(k, v)</code>","text":"<p>Set a chunk</p> Source code in <code>quokka/function.py</code> <pre><code>def __setitem__(self, k: Index, v: Chunk) -&gt; None:\n    \"\"\"Set a chunk\"\"\"\n    self.chunks.__setitem__(k, v)\n</code></pre>"},{"location":"reference/python/function/#quokka.function.SuperChunk.__str__","title":"<code>__str__()</code>","text":"<p>SuperChunk representation</p> Source code in <code>quokka/function.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"SuperChunk representation\"\"\"\n    return f\"&lt;SuperChunk with {len(self.starts)} chunks(s)&gt;\"\n</code></pre>"},{"location":"reference/python/function/#quokka.function.SuperChunk.get_chunk","title":"<code>get_chunk(address)</code>","text":"<p>Return a chunk by an address.</p> <p>To resolve an address and retrieve the appropriate chunk, we enumerate the chunks and look within the blocks.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>AddressT</code> <p>Address to query</p> required <p>Raises:</p> Type Description <code>IndexError</code> <p>When no chunk is found</p> Source code in <code>quokka/function.py</code> <pre><code>def get_chunk(self, address: AddressT) -&gt; Chunk:\n    \"\"\"Return a chunk by an address.\n\n    To resolve an address and retrieve the appropriate chunk, we enumerate the\n    chunks and look within the blocks.\n\n    Arguments:\n        address: Address to query\n\n    Raises:\n        IndexError: When no chunk is found\n\n    \"\"\"\n    if address in self.addresses:\n        return self.chunks[self.addresses[address]]\n\n    if address &lt; min(self.addresses):\n        raise IndexError(\"Address is before the chunk\")\n\n    # TODO(dm) CHECK OR FIXME\n    chunk_index = self.addresses[min(self.addresses)]\n    for blocks_head, chunk_index in self.addresses.items():\n        if blocks_head &gt; address:\n            break\n\n    candidate_chunk = self.chunks[chunk_index]\n    if candidate_chunk.in_chunk(address):\n        return candidate_chunk\n\n    raise IndexError(\"Address does not belong in this SuperChunk\")\n</code></pre>"},{"location":"reference/python/function/#quokka.function.SuperChunk.get_chunk_by_index","title":"<code>get_chunk_by_index(chunk_index, block_index)</code>","text":"<p>Return a chunk by its index</p> <p>This must be reimplemented because the chunk_index is unique for the proto but there are multiple chunks existing with the same index because of a SuperChunk.</p> <p>Parameters:</p> Name Type Description Default <code>chunk_index</code> <code>Index</code> <p>Chunk index</p> required <code>block_index</code> <code>Index</code> <p>Block index</p> required <p>Raises:</p> Type Description <code>ChunkMissingError</code> <p>if the chunk is not found</p> Source code in <code>quokka/function.py</code> <pre><code>def get_chunk_by_index(self, chunk_index: Index, block_index: Index) -&gt; Chunk:\n    \"\"\"Return a chunk by its index\n\n    This must be reimplemented because the chunk_index is unique for the proto but\n    there are multiple chunks existing with the same index because of a SuperChunk.\n\n    Arguments:\n        chunk_index: Chunk index\n        block_index: Block index\n\n    Raises:\n        ChunkMissingError: if the chunk is not found\n\n    \"\"\"\n    if chunk_index != self.proto_idx:\n        raise quokka.exc.ChunkMissingError(\"Wrong chunk index\")\n\n    for chunk in self.chunks.values():\n        if chunk.index_to_address.get(block_index, None) is not None:\n            return chunk\n\n    raise quokka.exc.ChunkMissingError(\n        \"Unable to find the correct chunk for this block\"\n    )\n</code></pre>"},{"location":"reference/python/function/#quokka.function.SuperChunk.get_instruction","title":"<code>get_instruction(address)</code>","text":"<p>Get the instruction at <code>address</code></p> Source code in <code>quokka/function.py</code> <pre><code>def get_instruction(self, address: AddressT) -&gt; quokka.Instruction:\n    \"\"\"Get the instruction at `address`\"\"\"\n    for chunk in self.chunks.values():\n        if chunk.in_chunk(address):\n            return chunk.get_instruction(address)\n\n    raise IndexError(f\"Unable to find the instruction at 0x{address:x}\")\n</code></pre>"},{"location":"reference/python/function/#quokka.function.SuperChunk.in_chunk","title":"<code>in_chunk(address)</code>","text":"<p>Check if address belongs to this SuperChunk</p> Source code in <code>quokka/function.py</code> <pre><code>def in_chunk(self, address: AddressT) -&gt; bool:\n    \"\"\"Check if address belongs to this SuperChunk\"\"\"\n    if address &lt; min(self.starts):\n        return False\n\n    for chunk in self.chunks.values():\n        if chunk.in_chunk(address):\n            return True\n\n    return False\n</code></pre>"},{"location":"reference/python/function/#quokka.function.dereference_thunk","title":"<code>dereference_thunk(item, caller=False)</code>","text":"<p>Dereference a thunk</p> <p>This method is used to resolve a thunk calls / callers. As thunk function only have 1 relation : FUNC (call x) -&gt; THUNK X -&gt; X , it disrupts the call graph and heuristics based on graph degrees.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Union[Function, Chunk]</code> <p>Either a function or a chunk</p> required <code>caller</code> <code>bool</code> <p>True if we want to find the callers (e.g. the functions that call item)     False if we want to find the callee (e.g. function that are called by     item)</p> <code>False</code> <p>Raises:</p> Type Description <code>ThunkMissingError</code> <p>When no thunk has been found</p> <code>FunctionMissingError</code> <p>When no function has been found</p> Source code in <code>quokka/function.py</code> <pre><code>def dereference_thunk(item: Union[Function, Chunk], caller: bool = False) -&gt; Function:\n    \"\"\"Dereference a thunk\n\n    This method is used to resolve a thunk calls / callers. As thunk function only have\n    1 relation : FUNC (call x) -&gt; THUNK X -&gt; X , it disrupts the call graph and\n    heuristics based on graph degrees.\n\n    Arguments:\n        item: Either a function or a chunk\n        caller: True if we want to find the callers (e.g. the functions that call item)\n                False if we want to find the callee (e.g. function that are called by\n                item)\n\n    Raises:\n        ThunkMissingError: When no thunk has been found\n        FunctionMissingError: When no function has been found\n    \"\"\"\n    if isinstance(item, quokka.function.Chunk):\n        function = item.program.get_first_function_by_chunk(item)\n    else:\n        function = item\n\n    # Do not try to (de)reference if we do not meet the prerequisites\n    if caller is False and function.type != FunctionType.THUNK:\n        # Only dereference THUNK function\n        return function\n\n    if caller is True and function.in_degree != 1:\n        # Only try to reference function with in_degree == 1\n        return function\n\n    target = \"calls\" if caller is False else \"callers\"\n    reference = getattr(function, target)\n\n    try:\n        candidate = function.program.get_first_function_by_chunk(reference[0])\n    except (IndexError, quokka.exc.FunctionMissingError) as exc:\n        if caller is True and reference[0].in_degree == 0:\n            raise quokka.exc.ThunkMissingError(\"Error while finding thunk\") from exc\n\n        # This will appear when the referenced target is a chunk coming from a\n        # fake chunk for instance\n        # logger.debug(\"Unable to find the (de)reference of the thunk function\")\n        raise quokka.exc.FunctionMissingError(\n            \"Missing func referenced by thunk\"\n        ) from exc\n\n    if candidate.type == FunctionType.THUNK and caller is not True:\n        # Recursive call for multi layered THUNK\n        return dereference_thunk(candidate, caller)\n\n    if caller and candidate.type != FunctionType.THUNK:\n        return function\n\n    return candidate\n</code></pre>"},{"location":"reference/python/function/#quokka.function.get_degrees","title":"<code>get_degrees(item)</code>","text":"<p>Compute the {in, out} degrees of an item (Function/Chunk)</p> Source code in <code>quokka/function.py</code> <pre><code>def get_degrees(item: Union[Chunk, Function]) -&gt; Tuple[int, int]:\n    \"\"\"Compute the {in, out} degrees of an item (Function/Chunk)\"\"\"\n    in_degree = item.in_degree\n    try:\n        in_func = quokka.function.dereference_thunk(item, True)\n        in_degree = in_func.in_degree\n    except quokka.exc.ThunkMissingError:\n        in_degree = 0\n    except quokka.exc.FunctionMissingError:\n        pass\n\n    try:\n        out_func: Union[Function, Chunk] = quokka.function.dereference_thunk(\n            item, False\n        )\n    except quokka.exc.FunctionMissingError:\n        out_func = item\n\n    return in_degree, out_func.out_degree\n</code></pre>"},{"location":"reference/python/instruction/","title":"instruction","text":"<p>Methods to deal with instructions and operands within a binary</p>"},{"location":"reference/python/instruction/#quokka.instruction.Instruction","title":"<code>Instruction</code>","text":"<p>Instruction class</p> <p>An instruction is the binary bread-and-butter. This class abstract some elements and offer various backends integration if needed.</p> <p>Parameters:</p> Name Type Description Default <code>proto_index</code> <code>Index</code> <p>Protobuf index of the instruction</p> required <code>inst_index</code> <code>int</code> <p>Instruction index in the parent block</p> required <code>address</code> <code>AddressT</code> <p>Instruction address</p> required <code>block</code> <code>Block</code> <p>Parent block reference</p> required <p>Attributes:</p> Name Type Description <code>program</code> <code>Program</code> <p>Reference to the program</p> <code>parent</code> <code>Block</code> <p>Parent block</p> <code>proto_index</code> <code>Index</code> <p>Protobuf index of the instruction</p> <code>inst_tuple</code> <p>A tuple composed of the (chunk_index, block_index, inst_index). This uniquely identify an instruction within the program.</p> <code>thumb</code> <p>is the instruction thumb?</p> <code>index</code> <code>int</code> <p>Instruction index in the parent block</p> Source code in <code>quokka/instruction.py</code> <pre><code>class Instruction:\n    \"\"\"Instruction class\n\n    An instruction is the binary bread-and-butter.\n    This class abstract some elements and offer various backends integration if needed.\n\n    Arguments:\n        proto_index: Protobuf index of the instruction\n        inst_index: Instruction index in the parent block\n        address: Instruction address\n        block: Parent block reference\n\n    Attributes:\n        program: Reference to the program\n        parent: Parent block\n        proto_index: Protobuf index of the instruction\n        inst_tuple: A tuple composed of the (chunk_index, block_index, inst_index). This\n            uniquely identify an instruction within the program.\n        thumb: is the instruction thumb?\n        index: Instruction index in the parent block\n    \"\"\"\n\n    def __init__(\n        self,\n        proto_index: Index,\n        inst_index: int,\n        address: AddressT,\n        block: quokka.Block,\n    ):\n        self.program: quokka.Program = block.program\n        self.parent: quokka.Block = block\n        self.proto_index: Index = proto_index\n\n        self.inst_tuple = (block.parent.proto_index, block.proto_index, inst_index)\n\n        instruction = self.program.proto.instructions[proto_index]\n\n        self.size = instruction.size\n        self.thumb = instruction.is_thumb\n\n        self.index: int = inst_index\n\n        # TODO(dm) Sometimes, IDA merge two instruction in one\n        #  (e.g. 0x1ab16 of d53a), deal with that\n        self.address: AddressT = address\n\n    @cached_property\n    def mnemonic(self) -&gt; str:\n        \"\"\"Return the mnemonic for the instruction.\n\n        First, try to use capstone because it's prettier\n        Otherwise, fallback to the IDA mnemonic which is better than nothing.\n\n        Returns:\n            A string representation of the mnemonic\n        \"\"\"\n        if self.cs_inst is not None:\n            return self.cs_inst.mnemonic\n\n        instruction = self.program.proto.instructions[self.proto_index]\n        return self.program.proto.mnemonics[instruction.mnemonic_index]\n\n    @cached_property\n    def cs_inst(self) -&gt; Optional[capstone.CsInsn]:\n        \"\"\"Load an instruction from Capstone backend\n\n        If the decoding fails, the result won't be cached, and it will be attempted\n        again.\n\n        Returns:\n            A Capstone instruction\n\n        \"\"\"\n        return quokka.backends.capstone_decode_instruction(self)\n\n    @cached_property\n    def pcode_insts(self) -&gt; Sequence[pypcode.PcodeOp]:\n        \"\"\"Retrieve the PcodeOps associated to the instruction\n\n        Returns:\n            A sequence of PCode instructions\n        \"\"\"\n        from quokka.backends.pypcode import pypcode_decode_instruction\n\n        return pypcode_decode_instruction(self)\n\n    @cached_property\n    def string(self) -&gt; Optional[str]:\n        \"\"\"String used by the instruction (if any)\"\"\"\n        for data in self.data_references:\n            if isinstance(data, quokka.data.Data) and data.type == DataType.ASCII:\n                return data.value\n\n        return None\n\n    @property\n    def references(self) -&gt; Dict[ReferenceType, List[ReferenceTarget]]:\n        \"\"\"Returns all the references towards the instruction\"\"\"\n\n        ref = defaultdict(list)\n        for reference in self.program.references.resolve_inst_instance(\n            self.inst_tuple, towards=True\n        ):\n            ref[reference.type].append(reference.source)\n        return ref\n\n    @property\n    def data_references(self) -&gt; List[ReferenceTarget]:\n        \"\"\"Returns all data reference to this instruction\"\"\"\n        return self.references[ReferenceType.DATA]\n\n    @property\n    def struct_references(self) -&gt; List[ReferenceTarget]:\n        \"\"\"Returns all struct reference to this instruction\"\"\"\n        return self.references[ReferenceType.STRUC]\n\n    @property\n    def enum_references(self) -&gt; List[ReferenceTarget]:\n        \"\"\"Returns all enum reference to this instruction\"\"\"\n        return self.references[ReferenceType.ENUM]\n\n    @property\n    def call_references(self) -&gt; List[ReferenceTarget]:\n        \"\"\"Returns all call reference to this instruction\"\"\"\n        return self.references[ReferenceType.CALL]\n\n    @property\n    def operands(self) -&gt; List[Operand]:\n        \"\"\"Retrieve the instruction operands and initialize them with Capstone\"\"\"\n        operands: List[Operand] = []\n\n        inst = self.program.proto.instructions[self.proto_index]\n\n        try:\n            capstone_operands = len(self.cs_inst.operands)\n        except AttributeError:\n            capstone_operands = 0\n\n        operand_count = max(capstone_operands, len(inst.operand_index))\n\n        for idx in range(operand_count):\n            try:\n                operand_index = inst.operand_index[idx]\n            except IndexError:\n                # logger.debug('Less IDA operands than capstone')\n                continue\n\n            details = None\n            try:\n                details = self.cs_inst.operands[idx]\n            except (IndexError, quokka.exc.InstructionError):\n                # logger.debug('Missing an IDA operand for capstone')\n                pass\n\n            # TODO(dm): Allow partial operands with only half of the data\n            if operand_index != -1:\n                operands.append(\n                    Operand(\n                        self.program.proto.operands[operand_index],\n                        capstone_operand=details,\n                        program=self.program,\n                    )\n                )\n\n        return operands\n\n    @cached_property\n    def call_target(self) -&gt; quokka.Chunk:\n        \"\"\"Find the call target of an instruction if any exists\"\"\"\n        call_target = False\n\n        candidates = set()\n        for reference in self.program.references.resolve_inst_instance(\n            self.inst_tuple, ReferenceType.CALL, towards=False\n        ):\n            # FIX: in Quokka a bug existed where the call target could be data\n            if isinstance(reference.destination, tuple):\n                candidates.add(reference.destination[0])  # A chunk\n            elif isinstance(reference.destination, quokka.Chunk):\n                candidates.add(reference.destination)\n\n        try:\n            call_target = candidates.pop()\n        except KeyError:\n            pass\n\n        if candidates:\n            logger.warning(\n                f\"We found multiple candidate targets for 0x{self.address:x}\"\n            )\n\n        return call_target\n\n    @property\n    def has_call(self) -&gt; bool:\n        \"\"\"Check if the instruction has a call target\"\"\"\n        return self.call_target is not False\n\n    @cached_property\n    def constants(self) -&gt; List[int]:\n        \"\"\"Fast accessor for instructions constant not using Capstone.\"\"\"\n        constants = []\n        for op_index in self.program.proto.instructions[self.proto_index].operand_index:\n            operand: quokka.pb.Quokka.Operand = self.program.proto.operands[op_index]\n            if operand.type == 5:\n                # FIX: This bug is due to IDA mislabelling operands for some\n                #   operations like ADRP on ARM where the operand points to a\n                #   memory area (2) but the type is CONSTANT (5).\n                #   The behavior is inconsistent with LEA on Intel arch where\n                #   the operand is properly labelled (either 2 or 5).\n                if not self.data_references:\n                    constants.append(operand.value)\n\n        return constants\n\n    def __str__(self) -&gt; str:\n        \"\"\"String representation of the instruction\n\n        First, try by capstone because it's prettier\n        Otherwise, fallback to the mnemonic which is better than nothing.\n\n        Returns:\n            A string representation of the mnemonic\n        \"\"\"\n\n        # First, try with the operand strings (case MODE FULL)\n        inst = self.program.proto.instructions[self.proto_index]\n        if self.program.mode == ExporterMode.FULL:\n            operands = \", \".join(\n                self.program.proto.operand_table[x] for x in inst.operand_strings\n            )\n            return f\"&lt;Inst {self.mnemonic} {operands}&gt;\"\n\n        # Second tentative, use capstone\n        if self.cs_inst is not None:\n            return f\"&lt;{self.cs_inst.mnemonic} {self.cs_inst.op_str}&gt;\"\n\n        # Finally, just use the mnemonic\n        return f\"&lt;Inst {self.mnemonic}&gt;\"\n\n    @cached_property\n    def bytes(self) -&gt; bytes:\n        \"\"\"Read the program binary to find the bytes associated to the instruction.\n\n        This is not cached as it is already in memory.\n\n        Returns:\n            Bytes associated to the instruction\n        \"\"\"\n        try:\n            file_offset = self.program.addresser.file(self.address)\n        except quokka.exc.NotInFileError:\n            return b\"\"\n\n        return self.program.executable.read_bytes(\n            offset=file_offset,\n            size=self.size,\n        )\n</code></pre>"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.bytes","title":"<code>bytes</code>  <code>cached</code> <code>property</code>","text":"<p>Read the program binary to find the bytes associated to the instruction.</p> <p>This is not cached as it is already in memory.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>Bytes associated to the instruction</p>"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.call_references","title":"<code>call_references</code>  <code>property</code>","text":"<p>Returns all call reference to this instruction</p>"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.call_target","title":"<code>call_target</code>  <code>cached</code> <code>property</code>","text":"<p>Find the call target of an instruction if any exists</p>"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.constants","title":"<code>constants</code>  <code>cached</code> <code>property</code>","text":"<p>Fast accessor for instructions constant not using Capstone.</p>"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.cs_inst","title":"<code>cs_inst</code>  <code>cached</code> <code>property</code>","text":"<p>Load an instruction from Capstone backend</p> <p>If the decoding fails, the result won't be cached, and it will be attempted again.</p> <p>Returns:</p> Type Description <code>Optional[CsInsn]</code> <p>A Capstone instruction</p>"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.data_references","title":"<code>data_references</code>  <code>property</code>","text":"<p>Returns all data reference to this instruction</p>"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.enum_references","title":"<code>enum_references</code>  <code>property</code>","text":"<p>Returns all enum reference to this instruction</p>"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.has_call","title":"<code>has_call</code>  <code>property</code>","text":"<p>Check if the instruction has a call target</p>"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.mnemonic","title":"<code>mnemonic</code>  <code>cached</code> <code>property</code>","text":"<p>Return the mnemonic for the instruction.</p> <p>First, try to use capstone because it's prettier Otherwise, fallback to the IDA mnemonic which is better than nothing.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the mnemonic</p>"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.operands","title":"<code>operands</code>  <code>property</code>","text":"<p>Retrieve the instruction operands and initialize them with Capstone</p>"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.pcode_insts","title":"<code>pcode_insts</code>  <code>cached</code> <code>property</code>","text":"<p>Retrieve the PcodeOps associated to the instruction</p> <p>Returns:</p> Type Description <code>Sequence[PcodeOp]</code> <p>A sequence of PCode instructions</p>"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.references","title":"<code>references</code>  <code>property</code>","text":"<p>Returns all the references towards the instruction</p>"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.string","title":"<code>string</code>  <code>cached</code> <code>property</code>","text":"<p>String used by the instruction (if any)</p>"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.struct_references","title":"<code>struct_references</code>  <code>property</code>","text":"<p>Returns all struct reference to this instruction</p>"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.__str__","title":"<code>__str__()</code>","text":"<p>String representation of the instruction</p> <p>First, try by capstone because it's prettier Otherwise, fallback to the mnemonic which is better than nothing.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the mnemonic</p> Source code in <code>quokka/instruction.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"String representation of the instruction\n\n    First, try by capstone because it's prettier\n    Otherwise, fallback to the mnemonic which is better than nothing.\n\n    Returns:\n        A string representation of the mnemonic\n    \"\"\"\n\n    # First, try with the operand strings (case MODE FULL)\n    inst = self.program.proto.instructions[self.proto_index]\n    if self.program.mode == ExporterMode.FULL:\n        operands = \", \".join(\n            self.program.proto.operand_table[x] for x in inst.operand_strings\n        )\n        return f\"&lt;Inst {self.mnemonic} {operands}&gt;\"\n\n    # Second tentative, use capstone\n    if self.cs_inst is not None:\n        return f\"&lt;{self.cs_inst.mnemonic} {self.cs_inst.op_str}&gt;\"\n\n    # Finally, just use the mnemonic\n    return f\"&lt;Inst {self.mnemonic}&gt;\"\n</code></pre>"},{"location":"reference/python/instruction/#quokka.instruction.Operand","title":"<code>Operand</code>","text":"<p>Operand object</p> <p>An operand is an \"argument\" for an instruction. This class represent them but is rather lackluster at the moment.</p> <p>Parameters:</p> Name Type Description Default <code>proto_operand</code> <code>'quokka.pb.Quokka.Operand'</code> <p>Protobuf data</p> required <code>capstone_operand</code> <p>Capstone data (if any)</p> <code>None</code> <code>program</code> <code>Union[None, Program]</code> <p>Program reference</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>program</code> <code>Program</code> <p>Program reference</p> <code>type</code> <code>int</code> <p>Operand type</p> <code>flags</code> <code>int</code> <p>Operand flags</p> <code>address</code> <code>Optional[int]</code> <p>Operand address</p> <code>value_type</code> <p>IDA value type</p> <code>reg_id</code> <p>IDA register ID (if applicable)</p> <code>details</code> <p>Capstone details</p> Source code in <code>quokka/instruction.py</code> <pre><code>class Operand:\n    \"\"\"Operand object\n\n    An operand is an \"argument\" for an instruction.\n    This class represent them but is rather lackluster at the moment.\n\n    Arguments:\n        proto_operand: Protobuf data\n        capstone_operand: Capstone data (if any)\n        program: Program reference\n\n    Attributes:\n        program: Program reference\n        type: Operand type\n        flags: Operand flags\n        address: Operand address\n        value_type: IDA value type\n        reg_id: IDA register ID (if applicable)\n        details: Capstone details\n    \"\"\"\n\n    # Operand rewrite to integrate capstone information as well\n\n    def __init__(\n        self,\n        proto_operand: \"quokka.pb.Quokka.Operand\",\n        capstone_operand=None,\n        program: Union[None, quokka.Program] = None,\n    ):\n        \"\"\"Constructor\"\"\"\n        self.program: quokka.Program = program\n\n        self.type: int = proto_operand.type\n        self.flags: int = proto_operand.flags  # TODO(dm)\n\n        self.address: Optional[int] = (\n            proto_operand.address if proto_operand.address != 0 else None\n        )\n\n        self.value_type = proto_operand.value_type\n        self.reg_id = proto_operand.register_id\n\n        self._value = proto_operand.value\n\n        self.details = capstone_operand\n\n    @property\n    def value(self) -&gt; Any:\n        \"\"\"Returns the operand value\n        Warning: this is only implemented for constant operand (in IDA).\n\n        Returns:\n            The operand value\n\n        \"\"\"\n        if self.type == 5:  # Type: IDA constant\n            return self._value\n\n        raise NotImplementedError\n\n    def is_constant(self) -&gt; bool:\n        \"\"\"Check if the operand is a constant\"\"\"\n        return self.type == 5\n</code></pre>"},{"location":"reference/python/instruction/#quokka.instruction.Operand.value","title":"<code>value</code>  <code>property</code>","text":"<p>Returns the operand value Warning: this is only implemented for constant operand (in IDA).</p> <p>Returns:</p> Type Description <code>Any</code> <p>The operand value</p>"},{"location":"reference/python/instruction/#quokka.instruction.Operand.__init__","title":"<code>__init__(proto_operand, capstone_operand=None, program=None)</code>","text":"<p>Constructor</p> Source code in <code>quokka/instruction.py</code> <pre><code>def __init__(\n    self,\n    proto_operand: \"quokka.pb.Quokka.Operand\",\n    capstone_operand=None,\n    program: Union[None, quokka.Program] = None,\n):\n    \"\"\"Constructor\"\"\"\n    self.program: quokka.Program = program\n\n    self.type: int = proto_operand.type\n    self.flags: int = proto_operand.flags  # TODO(dm)\n\n    self.address: Optional[int] = (\n        proto_operand.address if proto_operand.address != 0 else None\n    )\n\n    self.value_type = proto_operand.value_type\n    self.reg_id = proto_operand.register_id\n\n    self._value = proto_operand.value\n\n    self.details = capstone_operand\n</code></pre>"},{"location":"reference/python/instruction/#quokka.instruction.Operand.is_constant","title":"<code>is_constant()</code>","text":"<p>Check if the operand is a constant</p> Source code in <code>quokka/instruction.py</code> <pre><code>def is_constant(self) -&gt; bool:\n    \"\"\"Check if the operand is a constant\"\"\"\n    return self.type == 5\n</code></pre>"},{"location":"reference/python/program/","title":"program","text":"<p>Program</p> <p>This is the main class of Quokka. It deals with the most common abstraction, the Program.</p>"},{"location":"reference/python/program/#quokka.program.Program","title":"<code>Program</code>","text":"<p>               Bases: <code>dict</code></p> <p>Program</p> <p>The program is <code>quokka</code> main abstraction. It represents the full binary and is in itself a mapping of functions.</p> <p>Parameters:</p> Name Type Description Default <code>export_file</code> <code>Union[Path, str]</code> <p>Path towards the export file (e.g. .quokka)</p> required <code>exec_path</code> <code>Union[Path, str]</code> <p>Path towards the binary file</p> required <p>Attributes:</p> Name Type Description <code>proto</code> <code>Quokka</code> <p>Contains the protobuf data. This should not be used directly. However, if you don't find another way of accessing some information, feel  free to open an issue.</p> <code>export_file</code> <code>Path</code> <p>The path to the export file (e.g. the .quokka)</p> <code>mode</code> <code>ExporterMode</code> <p>Export mode (LIGHT, NORMAL or FULL)</p> <code>base_address</code> <code>AddressT</code> <p>Program base address</p> <code>addresser</code> <p>Utility to convert the program offsets into file-offsets</p> <code>isa</code> <code>ArchEnum</code> <p>Instruction set</p> <code>address_size</code> <code>int</code> <p>Default pointer size</p> <code>arch</code> <code>Type[QuokkaArch]</code> <p>Program architecture</p> <code>endianness</code> <code>Endianness</code> <p>Program endianness</p> <code>chunks</code> <code>Dict[int, Union[Chunk, SuperChunk]]</code> <p>A mapping of chunks</p> <code>executable</code> <p>An object to manage the binary file</p> <code>references</code> <p>The reference manager</p> <code>data_holder</code> <p>The data manager</p> <code>fun_names</code> <code>Dict[str, Function]</code> <p>A mapping of function names to functions</p> <p>Raises:</p> Type Description <code>QuokkaError</code> <p>If the loading is not successful.</p> Source code in <code>quokka/program.py</code> <pre><code>class Program(dict):\n    \"\"\"Program\n\n    The program is `quokka` main abstraction.\n    It represents the full binary and is in itself a mapping of functions.\n\n    Arguments:\n        export_file: Path towards the export file (e.g. .quokka)\n        exec_path: Path towards the binary file\n\n    Attributes:\n        proto: Contains the protobuf data. This should not be used directly. However, if\n            you don't find another way of accessing some information, feel  free to\n            open an issue.\n        export_file: The path to the export file (e.g. the .quokka)\n        mode: Export mode (LIGHT, NORMAL or FULL)\n        base_address: Program base address\n        addresser: Utility to convert the program offsets into file-offsets\n        isa: Instruction set\n        address_size: Default pointer size\n        arch: Program architecture\n        endianness: Program endianness\n        chunks: A mapping of chunks\n        executable: An object to manage the binary file\n        references: The reference manager\n        data_holder: The data manager\n        fun_names: A mapping of function names to functions\n\n    Raises:\n        QuokkaError: If the loading is not successful.\n\n    \"\"\"\n\n    logger: logging.Logger = logging.getLogger(__name__)\n\n    def __init__(\n        self, export_file: Union[pathlib.Path, str], exec_path: Union[pathlib.Path, str]\n    ):\n        \"\"\"Constructor\"\"\"\n        super(dict, self).__init__()\n\n        self.proto: quokka.pb.Quokka = quokka.pb.Quokka()\n        self.export_file: pathlib.Path = pathlib.Path(export_file)\n        with open(self.export_file, \"rb\") as fd:\n            self.proto.ParseFromString(fd.read())\n\n        # Export mode\n        self.mode: ExporterMode = ExporterMode.from_proto(self.proto.exporter_meta.mode)\n\n        # Version checking\n        # A change in the major version might break backward compatibility\n        proto_version = quokka.parse_version(self.proto.exporter_meta.version)\n        current_version = quokka.parse_version(quokka.__version__)\n        if proto_version[0] != current_version[0]:\n            self.logger.warning(\n                \"The exported file has been generated by a different version of Quokka.\"\n                f\" The file has been generated by Quokka {self.proto.exporter_meta.version}\"\n                f\" while you are using {quokka.__version__}\"\n            )\n        elif self.proto.exporter_meta.version != quokka.__version__:\n            self.logger.debug(\n                \"Version mismatch detected but still compatible with the exported file.\"\n                f\" The file has been generated by Quokka {self.proto.exporter_meta.version}\"\n                f\" while you are using {quokka.__version__}\"\n            )\n\n        # Check if the hashes matches between the export file and the exec\n        if not quokka.check_hash(self.proto.meta.hash, pathlib.Path(exec_path)):\n            self.logger.error(\"Hash does not match with file.\")\n            raise quokka.QuokkaError(\"Hash mismatch\")\n\n        self.base_address: AddressT = self.proto.meta.base_addr\n        self.addresser = quokka.Addresser(self, self.base_address)\n\n        self.isa: quokka.analysis.ArchEnum = quokka.get_isa(self.proto.meta.isa)\n        self.address_size: int = quokka.convert_address_size(\n            self.proto.meta.address_size\n        )\n        self.arch: Type[quokka.analysis.QuokkaArch] = quokka.get_arch(\n            self.isa, self.address_size\n        )\n\n        self.endianness: Endianness = Endianness.from_proto(self.proto.meta.endianess)\n\n        self.chunks: Dict[int, Union[quokka.Chunk, quokka.SuperChunk]] = {}\n\n        self.executable = quokka.Executable(exec_path, self.endianness)\n        self.references = quokka.References(self)\n        self.data_holder = quokka.DataHolder(self.proto, self)\n\n        # Chunks\n        for chunk_index, _ in enumerate(self.proto.function_chunks):\n            chunk = quokka.Chunk(chunk_index, program=self)\n\n            if chunk.fake:\n                chunk = quokka.analysis.split_chunk(chunk)\n\n            self.chunks[chunk_index] = chunk\n\n        # Functions\n        self.fun_names: Dict[str, quokka.Function] = {}\n        for func in self.proto.functions:\n            function = quokka.Function(func, self)\n            self[function.start] = function\n            if function.name not in self.fun_names:\n                self.fun_names[function.name] = function\n            else:\n                if function.type == self.fun_names[function.name]:\n                    self.logger.warning(\"Found two functions with the same name.\")\n                else:\n                    if function.type == FunctionType.NORMAL:\n                        self.fun_names[function.name] = function\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Hash of the Program (use the hash from the exported file)\"\"\"\n        return int(self.proto.meta.hash.hash_value, 16)\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Returns the underlying binary name\"\"\"\n        return self.proto.meta.executable_name\n\n    @property\n    def hash(self) -&gt; str:\n        \"\"\"Returns the hash value of the binary (either sha256 or MD5).\"\"\"\n        return self.proto.meta.hash.hash_value\n\n    @cached_property\n    def capstone(self) -&gt; capstone.Cs:\n        \"\"\"Compute a capstone context\"\"\"\n        return quokka.backends.get_capstone_context(self.arch, self.endianness)\n\n    @cached_property\n    def call_graph(self) -&gt; networkx.DiGraph:\n        \"\"\"Compute the Call Graph of the binary\n\n        Every node in the call graph is a chunk (and not a function).\n\n        :return: A Call Graph (a networkx DiGraph)\n        \"\"\"\n        call_graph: \"networkx.DiGraph\" = networkx.DiGraph()\n\n        chunk: Union[quokka.Chunk, quokka.SuperChunk]\n        for chunk in self.chunks.values():\n            if isinstance(chunk, quokka.Chunk):\n                call_graph.add_node(chunk.start)\n                call_graph.add_edges_from(product((chunk.start,), chunk.calls))\n            else:  # Super Chunks\n                for small_chunk in chunk.starts.values():\n                    call_graph.add_edges_from(\n                        product((small_chunk,), small_chunk.calls)\n                    )\n\n        return call_graph\n\n    @cached_property\n    def pypcode(self) -&gt; pypcode.Context:\n        \"\"\"Generate the Pypcode context.\"\"\"\n        from quokka.backends.pypcode import get_pypcode_context\n\n        return get_pypcode_context(self.arch, self.endianness)\n\n    @cached_property\n    def structures(self) -&gt; List[quokka.Structure]:\n        \"\"\"Structures accessor\n\n        Allows to retrieve the different structures of a program (as defined by the\n        disassembler).\n\n        Returns:\n            A list of structures\n        \"\"\"\n        structures = [\n            quokka.Structure(structure, self) for structure in self.proto.structs\n        ]\n        return structures\n\n    @property\n    def strings(self) -&gt; Iterable[str]:\n        \"\"\"Program strings\n\n        Retrieves all the strings used in the program.\n\n        Returns:\n            A list of strings.\n        \"\"\"\n        # Do not use the empty string (the first one)\n        return self.proto.string_table[1:]\n\n    @cached_property\n    def segments(self) -&gt; List[quokka.Segment]:\n        \"\"\"Returns the list of segments defined in the program.\"\"\"\n        return [quokka.Segment(segment, self) for segment in self.proto.segments]\n\n    def get_instruction(self, address: AddressT) -&gt; quokka.Instruction:\n        \"\"\"Get an instruction by its address\n\n        Note: the address must be the head of the instruction.\n\n        TODO(dm): Improve the algorithm because the chunks are sorted (use bisect)\n\n        Arguments:\n            address: AddressT: Address to query\n\n        Returns:\n            A `quokka.Instruction`\n\n        Raises:\n            IndexError: When no instruction is found at this address\n        \"\"\"\n        for chunk in self.chunks.values():\n            if chunk.in_chunk(address):\n                try:\n                    return chunk.get_instruction(address)\n                except IndexError:\n                    pass\n\n        raise IndexError(f\"No instruction at address 0x{address:x}\")\n\n    def get_function(\n        self, name: str, approximative: bool = True, normal: bool = False\n    ) -&gt; quokka.Function:\n        \"\"\"Find a function in a program by its name\n\n        Arguments:\n            name: Function name\n            approximative: Should the name exactly match or allow partial matches?\n            normal: Return only FunctionType.NORMAL functions\n\n        Returns:\n            A function matching the research criteria\n\n        Raises:\n            ValueError: When no function is found\n        \"\"\"\n        if approximative is False:\n            try:\n                return self.fun_names[name]\n            except KeyError as exc:\n                raise ValueError(\"Missing function\") from exc\n\n        for function_name, function in self.fun_names.items():\n            # TODO(dm) Improve this\n            if name in function.name and (\n                not normal or function.type == FunctionType.NORMAL\n            ):\n                return self.fun_names[function_name]\n\n        raise ValueError(\"Unable to find an appropriate function\")\n\n    def get_segment(self, address: AddressT) -&gt; quokka.Segment:\n        \"\"\"Get a `Segment` by an address\n\n        The address must be in [segment.start, segment.end) to be found.\n\n        Arguments:\n            address: Segment's address\n\n        Returns:\n            The corresponding Segment\n\n        Raises:\n            KeyError: When the segment is not found\n        \"\"\"\n        for segment in self.segments:\n            if segment.in_segment(address):\n                return segment\n\n        raise KeyError(f\"No segment has been found for address {address:#x}\")\n\n    @cached_property\n    def func_chunk_index(self) -&gt; Dict[Index, List[quokka.Function]]:\n        \"\"\"Returns the list of functions attached to a chunk.\n\n        This method allows to find all the functions using a specific chunk.\n        However, it is mostly an internal method and should not be directly used by a\n        user. Instead, use `get_function_by_chunk`.\n\n        Returns:\n            A mapping of ChunkIndex to a list of Function.\n        \"\"\"\n        func_chunk_index = collections.defaultdict(list)\n        for function in self.values():\n            for chunk_proto_index in function.index_to_address:\n                func_chunk_index[chunk_proto_index].append(function)\n\n        return func_chunk_index\n\n    def get_function_by_chunk(self, chunk: quokka.Chunk) -&gt; List[quokka.Function]:\n        \"\"\"Retrieves all the functions where `chunk` belongs.\n\n        Arguments:\n            chunk: Chunk to search for\n\n        Returns:\n            A list of corresponding functions\n\n        Raises:\n            IndexError: When no function is found for the chunk.\n\n        \"\"\"\n        functions = self.func_chunk_index[chunk.proto_index]\n        if not functions:\n            raise IndexError(\n                \"No function has been found for the chunk. \"\n                \"This is probably a Quokka bug and should be reported.\"\n            )\n\n        return functions\n\n    def get_first_function_by_chunk(\n        self, chunk: quokka.Chunk\n    ) -&gt; Optional[quokka.Function]:\n        \"\"\"Return the first function found when searching for a chunk.\n\n        Arguments:\n            chunk: Chunk belonging to the function\n\n        Returns:\n          A function in which `chunk` belongs\n\n        Raises:\n            FunctionMissingError: No function has been found for the chunk\n        \"\"\"\n        try:\n            return self.get_function_by_chunk(chunk)[0]\n        except IndexError:\n            raise quokka.FunctionMissingError(\"Missing function from chunk\")\n\n    def get_chunk(\n        self, chunk_index: Index, block_index: Optional[Index] = None\n    ) -&gt; quokka.Chunk:\n        \"\"\"Get a `Chunk`\n\n        If the candidate Chunk is a SuperChunk, this method will resolve it to find the\n        appropriate chunk (given a block index).\n\n        Arguments:\n            chunk_index: Chunk index\n            block_index: Used to resolve SuperChunks\n\n        Returns:\n            A Chunk matching the criteria\n\n        Raises:\n            ChunkMissingError: When no chunk has been found\n        \"\"\"\n        chunk = self.chunks.get(chunk_index, None)\n        if isinstance(chunk, quokka.Chunk):\n            return chunk\n\n        if isinstance(chunk, quokka.SuperChunk):\n            if block_index is None:\n                raise quokka.ChunkMissingError(\n                    \"Unable to find the chunk requested because its a super chunk\"\n                )\n\n            return chunk.get_chunk_by_index(chunk_index, block_index)\n\n        raise quokka.ChunkMissingError(\"Unable to find the chunk, index unknown\")\n\n    def iter_chunk(\n        self, chunk_types: Optional[List[FunctionType]] = None\n    ) -&gt; Iterator[quokka.Chunk]:\n        \"\"\"Iterate over all the chunks in the program.\n\n        If a `SuperChunk` is found, it will split it and return individual chunks.\n        By default, it iterates over all the chunks, even extern functions.\n\n        Arguments:\n            chunk_types: Allow list of chunk types. By default, it retrieves every\n                chunk.\n\n        Yields:\n            All the chunks in the program.\n        \"\"\"\n\n        if chunk_types is None:\n            chunk_types = list(FunctionType)\n\n        chunk: quokka.Chunk\n        for chunk in self.chunks.values():\n            if isinstance(chunk, quokka.SuperChunk):\n                inner_chunk: quokka.Chunk\n                for inner_chunk in chunk.values():\n                    if inner_chunk.chunk_type in chunk_types:\n                        yield inner_chunk\n            else:\n                if chunk.chunk_type in chunk_types:\n                    yield chunk\n\n    def read_bytes(self, v_addr: AddressT, size: int) -&gt; bytes:\n        \"\"\"Read raw bytes from a virtual address\n\n        Arguments:\n            v_addr: Virtual address of the data to read\n            size: Size of the data to read\n\n        Returns:\n            The raw data at the specified address\n        \"\"\"\n\n        if (offset := v_addr - self.base_address) &lt; 0:\n            raise ValueError(\"Address outside virtual address space.\")\n        return self.executable.read_bytes(offset, size)\n\n    def get_data(self, address: AddressT) -&gt; quokka.Data:\n        \"\"\"Get data by address\n\n        Arguments:\n            address: Address to query\n\n        Returns:\n            A data at the address\n        \"\"\"\n        return self.data_holder.get_data(address)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Program representation\"\"\"\n        return self.__str__()\n\n    def __str__(self) -&gt; str:\n        \"\"\"Program representation\"\"\"\n        return f\"&lt;Program {self.executable.exec_file.name} ({self.arch.__name__})&gt;\"\n\n    @staticmethod\n    def from_binary(\n        exec_path: Union[pathlib.Path, str],\n        output_file: Optional[Union[pathlib.Path, str]] = None,\n        database_file: Optional[Union[pathlib.Path, str]] = None,\n        debug: bool = False,\n        timeout: Optional[int] = 600,\n    ) -&gt; Optional[Program]:\n        \"\"\"Generate an export file directly from the binary.\n\n        This methods will export `exec_path` directly using Quokka IDA's plugin if\n        installed.\n\n        Arguments:\n            exec_path: Binary to export.\n            output_file: Where to store the result (by default: near the executable)\n            database_file: Where to store IDA database (by default: near the executable)\n            timeout: How long should we wait for the export to finish (default: 10 min)\n            debug: Activate the debug output\n\n        Returns:\n            A |`Program` instance or None if\n\n        Raises:\n            FileNotFoundError: If the executable is not found\n        \"\"\"\n\n        exec_path = pathlib.Path(exec_path)\n        if not exec_path.is_file():\n            raise FileNotFoundError(\"Missing exec file\")\n\n        if output_file is None:\n            output_file = exec_path.parent / f\"{exec_path.name}.quokka\"\n        else:\n            output_file = pathlib.Path(output_file)\n\n        if output_file.is_file():\n            return Program(output_file, exec_path)\n\n        exec_file = exec_path\n        if database_file is None:\n            database_file = exec_file.parent / f\"{exec_file.name}.i64\"\n        else:\n            database_file = pathlib.Path(database_file)\n\n        additional_options = []\n        if not database_file.is_file():\n            additional_options.append(f'-o{database_file.with_suffix(\"\")}')\n        else:\n            exec_file = database_file\n\n        # Search for the IDA Pro executable\n        ida_path = find_ida_executable()\n        if not ida_path:\n            Program.logger.warning(f\"IDA executable not found\")\n            return None\n\n        try:\n            cmd = (\n                [\n                    ida_path,\n                    \"-OQuokkaAuto:true\",\n                    f\"-OQuokkaFile:{output_file}\",\n                ]\n                + additional_options\n                + [\"-A\", f\"{exec_file!s}\"]\n            )\n\n            Program.logger.info(\"%s\", \" \".join(cmd))\n            result = subprocess.run(\n                cmd,\n                stderr=subprocess.PIPE,\n                stdout=subprocess.PIPE,\n                env={\n                    \"TVHEADLESS\": \"1\",\n                    \"HOME\": os.environ[\"HOME\"],\n                    \"PATH\": os.environ.get(\"PATH\", \"\"),\n                    \"TERM\": \"xterm\",  # problem with libcurses\n                },\n                timeout=timeout,\n                check=True,\n            )\n            if debug or result.returncode != 0:\n                Program.logger.debug(result.stderr)\n\n        except subprocess.CalledProcessError:\n            return None\n\n        if not output_file.is_file():\n            return None\n\n        return Program(output_file, exec_path)\n</code></pre>"},{"location":"reference/python/program/#quokka.program.Program.call_graph","title":"<code>call_graph</code>  <code>cached</code> <code>property</code>","text":"<p>Compute the Call Graph of the binary</p> <p>Every node in the call graph is a chunk (and not a function).</p> <p>:return: A Call Graph (a networkx DiGraph)</p>"},{"location":"reference/python/program/#quokka.program.Program.capstone","title":"<code>capstone</code>  <code>cached</code> <code>property</code>","text":"<p>Compute a capstone context</p>"},{"location":"reference/python/program/#quokka.program.Program.func_chunk_index","title":"<code>func_chunk_index</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the list of functions attached to a chunk.</p> <p>This method allows to find all the functions using a specific chunk. However, it is mostly an internal method and should not be directly used by a user. Instead, use <code>get_function_by_chunk</code>.</p> <p>Returns:</p> Type Description <code>Dict[Index, List[Function]]</code> <p>A mapping of ChunkIndex to a list of Function.</p>"},{"location":"reference/python/program/#quokka.program.Program.hash","title":"<code>hash</code>  <code>property</code>","text":"<p>Returns the hash value of the binary (either sha256 or MD5).</p>"},{"location":"reference/python/program/#quokka.program.Program.name","title":"<code>name</code>  <code>property</code>","text":"<p>Returns the underlying binary name</p>"},{"location":"reference/python/program/#quokka.program.Program.pypcode","title":"<code>pypcode</code>  <code>cached</code> <code>property</code>","text":"<p>Generate the Pypcode context.</p>"},{"location":"reference/python/program/#quokka.program.Program.segments","title":"<code>segments</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the list of segments defined in the program.</p>"},{"location":"reference/python/program/#quokka.program.Program.strings","title":"<code>strings</code>  <code>property</code>","text":"<p>Program strings</p> <p>Retrieves all the strings used in the program.</p> <p>Returns:</p> Type Description <code>Iterable[str]</code> <p>A list of strings.</p>"},{"location":"reference/python/program/#quokka.program.Program.structures","title":"<code>structures</code>  <code>cached</code> <code>property</code>","text":"<p>Structures accessor</p> <p>Allows to retrieve the different structures of a program (as defined by the disassembler).</p> <p>Returns:</p> Type Description <code>List[Structure]</code> <p>A list of structures</p>"},{"location":"reference/python/program/#quokka.program.Program.__hash__","title":"<code>__hash__()</code>","text":"<p>Hash of the Program (use the hash from the exported file)</p> Source code in <code>quokka/program.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Hash of the Program (use the hash from the exported file)\"\"\"\n    return int(self.proto.meta.hash.hash_value, 16)\n</code></pre>"},{"location":"reference/python/program/#quokka.program.Program.__init__","title":"<code>__init__(export_file, exec_path)</code>","text":"<p>Constructor</p> Source code in <code>quokka/program.py</code> <pre><code>def __init__(\n    self, export_file: Union[pathlib.Path, str], exec_path: Union[pathlib.Path, str]\n):\n    \"\"\"Constructor\"\"\"\n    super(dict, self).__init__()\n\n    self.proto: quokka.pb.Quokka = quokka.pb.Quokka()\n    self.export_file: pathlib.Path = pathlib.Path(export_file)\n    with open(self.export_file, \"rb\") as fd:\n        self.proto.ParseFromString(fd.read())\n\n    # Export mode\n    self.mode: ExporterMode = ExporterMode.from_proto(self.proto.exporter_meta.mode)\n\n    # Version checking\n    # A change in the major version might break backward compatibility\n    proto_version = quokka.parse_version(self.proto.exporter_meta.version)\n    current_version = quokka.parse_version(quokka.__version__)\n    if proto_version[0] != current_version[0]:\n        self.logger.warning(\n            \"The exported file has been generated by a different version of Quokka.\"\n            f\" The file has been generated by Quokka {self.proto.exporter_meta.version}\"\n            f\" while you are using {quokka.__version__}\"\n        )\n    elif self.proto.exporter_meta.version != quokka.__version__:\n        self.logger.debug(\n            \"Version mismatch detected but still compatible with the exported file.\"\n            f\" The file has been generated by Quokka {self.proto.exporter_meta.version}\"\n            f\" while you are using {quokka.__version__}\"\n        )\n\n    # Check if the hashes matches between the export file and the exec\n    if not quokka.check_hash(self.proto.meta.hash, pathlib.Path(exec_path)):\n        self.logger.error(\"Hash does not match with file.\")\n        raise quokka.QuokkaError(\"Hash mismatch\")\n\n    self.base_address: AddressT = self.proto.meta.base_addr\n    self.addresser = quokka.Addresser(self, self.base_address)\n\n    self.isa: quokka.analysis.ArchEnum = quokka.get_isa(self.proto.meta.isa)\n    self.address_size: int = quokka.convert_address_size(\n        self.proto.meta.address_size\n    )\n    self.arch: Type[quokka.analysis.QuokkaArch] = quokka.get_arch(\n        self.isa, self.address_size\n    )\n\n    self.endianness: Endianness = Endianness.from_proto(self.proto.meta.endianess)\n\n    self.chunks: Dict[int, Union[quokka.Chunk, quokka.SuperChunk]] = {}\n\n    self.executable = quokka.Executable(exec_path, self.endianness)\n    self.references = quokka.References(self)\n    self.data_holder = quokka.DataHolder(self.proto, self)\n\n    # Chunks\n    for chunk_index, _ in enumerate(self.proto.function_chunks):\n        chunk = quokka.Chunk(chunk_index, program=self)\n\n        if chunk.fake:\n            chunk = quokka.analysis.split_chunk(chunk)\n\n        self.chunks[chunk_index] = chunk\n\n    # Functions\n    self.fun_names: Dict[str, quokka.Function] = {}\n    for func in self.proto.functions:\n        function = quokka.Function(func, self)\n        self[function.start] = function\n        if function.name not in self.fun_names:\n            self.fun_names[function.name] = function\n        else:\n            if function.type == self.fun_names[function.name]:\n                self.logger.warning(\"Found two functions with the same name.\")\n            else:\n                if function.type == FunctionType.NORMAL:\n                    self.fun_names[function.name] = function\n</code></pre>"},{"location":"reference/python/program/#quokka.program.Program.__repr__","title":"<code>__repr__()</code>","text":"<p>Program representation</p> Source code in <code>quokka/program.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Program representation\"\"\"\n    return self.__str__()\n</code></pre>"},{"location":"reference/python/program/#quokka.program.Program.__str__","title":"<code>__str__()</code>","text":"<p>Program representation</p> Source code in <code>quokka/program.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Program representation\"\"\"\n    return f\"&lt;Program {self.executable.exec_file.name} ({self.arch.__name__})&gt;\"\n</code></pre>"},{"location":"reference/python/program/#quokka.program.Program.from_binary","title":"<code>from_binary(exec_path, output_file=None, database_file=None, debug=False, timeout=600)</code>  <code>staticmethod</code>","text":"<p>Generate an export file directly from the binary.</p> <p>This methods will export <code>exec_path</code> directly using Quokka IDA's plugin if installed.</p> <p>Parameters:</p> Name Type Description Default <code>exec_path</code> <code>Union[Path, str]</code> <p>Binary to export.</p> required <code>output_file</code> <code>Optional[Union[Path, str]]</code> <p>Where to store the result (by default: near the executable)</p> <code>None</code> <code>database_file</code> <code>Optional[Union[Path, str]]</code> <p>Where to store IDA database (by default: near the executable)</p> <code>None</code> <code>timeout</code> <code>Optional[int]</code> <p>How long should we wait for the export to finish (default: 10 min)</p> <code>600</code> <code>debug</code> <code>bool</code> <p>Activate the debug output</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[Program]</code> <p>A |<code>Program</code> instance or None if</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the executable is not found</p> Source code in <code>quokka/program.py</code> <pre><code>@staticmethod\ndef from_binary(\n    exec_path: Union[pathlib.Path, str],\n    output_file: Optional[Union[pathlib.Path, str]] = None,\n    database_file: Optional[Union[pathlib.Path, str]] = None,\n    debug: bool = False,\n    timeout: Optional[int] = 600,\n) -&gt; Optional[Program]:\n    \"\"\"Generate an export file directly from the binary.\n\n    This methods will export `exec_path` directly using Quokka IDA's plugin if\n    installed.\n\n    Arguments:\n        exec_path: Binary to export.\n        output_file: Where to store the result (by default: near the executable)\n        database_file: Where to store IDA database (by default: near the executable)\n        timeout: How long should we wait for the export to finish (default: 10 min)\n        debug: Activate the debug output\n\n    Returns:\n        A |`Program` instance or None if\n\n    Raises:\n        FileNotFoundError: If the executable is not found\n    \"\"\"\n\n    exec_path = pathlib.Path(exec_path)\n    if not exec_path.is_file():\n        raise FileNotFoundError(\"Missing exec file\")\n\n    if output_file is None:\n        output_file = exec_path.parent / f\"{exec_path.name}.quokka\"\n    else:\n        output_file = pathlib.Path(output_file)\n\n    if output_file.is_file():\n        return Program(output_file, exec_path)\n\n    exec_file = exec_path\n    if database_file is None:\n        database_file = exec_file.parent / f\"{exec_file.name}.i64\"\n    else:\n        database_file = pathlib.Path(database_file)\n\n    additional_options = []\n    if not database_file.is_file():\n        additional_options.append(f'-o{database_file.with_suffix(\"\")}')\n    else:\n        exec_file = database_file\n\n    # Search for the IDA Pro executable\n    ida_path = find_ida_executable()\n    if not ida_path:\n        Program.logger.warning(f\"IDA executable not found\")\n        return None\n\n    try:\n        cmd = (\n            [\n                ida_path,\n                \"-OQuokkaAuto:true\",\n                f\"-OQuokkaFile:{output_file}\",\n            ]\n            + additional_options\n            + [\"-A\", f\"{exec_file!s}\"]\n        )\n\n        Program.logger.info(\"%s\", \" \".join(cmd))\n        result = subprocess.run(\n            cmd,\n            stderr=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            env={\n                \"TVHEADLESS\": \"1\",\n                \"HOME\": os.environ[\"HOME\"],\n                \"PATH\": os.environ.get(\"PATH\", \"\"),\n                \"TERM\": \"xterm\",  # problem with libcurses\n            },\n            timeout=timeout,\n            check=True,\n        )\n        if debug or result.returncode != 0:\n            Program.logger.debug(result.stderr)\n\n    except subprocess.CalledProcessError:\n        return None\n\n    if not output_file.is_file():\n        return None\n\n    return Program(output_file, exec_path)\n</code></pre>"},{"location":"reference/python/program/#quokka.program.Program.get_chunk","title":"<code>get_chunk(chunk_index, block_index=None)</code>","text":"<p>Get a <code>Chunk</code></p> <p>If the candidate Chunk is a SuperChunk, this method will resolve it to find the appropriate chunk (given a block index).</p> <p>Parameters:</p> Name Type Description Default <code>chunk_index</code> <code>Index</code> <p>Chunk index</p> required <code>block_index</code> <code>Optional[Index]</code> <p>Used to resolve SuperChunks</p> <code>None</code> <p>Returns:</p> Type Description <code>Chunk</code> <p>A Chunk matching the criteria</p> <p>Raises:</p> Type Description <code>ChunkMissingError</code> <p>When no chunk has been found</p> Source code in <code>quokka/program.py</code> <pre><code>def get_chunk(\n    self, chunk_index: Index, block_index: Optional[Index] = None\n) -&gt; quokka.Chunk:\n    \"\"\"Get a `Chunk`\n\n    If the candidate Chunk is a SuperChunk, this method will resolve it to find the\n    appropriate chunk (given a block index).\n\n    Arguments:\n        chunk_index: Chunk index\n        block_index: Used to resolve SuperChunks\n\n    Returns:\n        A Chunk matching the criteria\n\n    Raises:\n        ChunkMissingError: When no chunk has been found\n    \"\"\"\n    chunk = self.chunks.get(chunk_index, None)\n    if isinstance(chunk, quokka.Chunk):\n        return chunk\n\n    if isinstance(chunk, quokka.SuperChunk):\n        if block_index is None:\n            raise quokka.ChunkMissingError(\n                \"Unable to find the chunk requested because its a super chunk\"\n            )\n\n        return chunk.get_chunk_by_index(chunk_index, block_index)\n\n    raise quokka.ChunkMissingError(\"Unable to find the chunk, index unknown\")\n</code></pre>"},{"location":"reference/python/program/#quokka.program.Program.get_data","title":"<code>get_data(address)</code>","text":"<p>Get data by address</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>AddressT</code> <p>Address to query</p> required <p>Returns:</p> Type Description <code>Data</code> <p>A data at the address</p> Source code in <code>quokka/program.py</code> <pre><code>def get_data(self, address: AddressT) -&gt; quokka.Data:\n    \"\"\"Get data by address\n\n    Arguments:\n        address: Address to query\n\n    Returns:\n        A data at the address\n    \"\"\"\n    return self.data_holder.get_data(address)\n</code></pre>"},{"location":"reference/python/program/#quokka.program.Program.get_first_function_by_chunk","title":"<code>get_first_function_by_chunk(chunk)</code>","text":"<p>Return the first function found when searching for a chunk.</p> <p>Parameters:</p> Name Type Description Default <code>chunk</code> <code>Chunk</code> <p>Chunk belonging to the function</p> required <p>Returns:</p> Type Description <code>Optional[Function]</code> <p>A function in which <code>chunk</code> belongs</p> <p>Raises:</p> Type Description <code>FunctionMissingError</code> <p>No function has been found for the chunk</p> Source code in <code>quokka/program.py</code> <pre><code>def get_first_function_by_chunk(\n    self, chunk: quokka.Chunk\n) -&gt; Optional[quokka.Function]:\n    \"\"\"Return the first function found when searching for a chunk.\n\n    Arguments:\n        chunk: Chunk belonging to the function\n\n    Returns:\n      A function in which `chunk` belongs\n\n    Raises:\n        FunctionMissingError: No function has been found for the chunk\n    \"\"\"\n    try:\n        return self.get_function_by_chunk(chunk)[0]\n    except IndexError:\n        raise quokka.FunctionMissingError(\"Missing function from chunk\")\n</code></pre>"},{"location":"reference/python/program/#quokka.program.Program.get_function","title":"<code>get_function(name, approximative=True, normal=False)</code>","text":"<p>Find a function in a program by its name</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Function name</p> required <code>approximative</code> <code>bool</code> <p>Should the name exactly match or allow partial matches?</p> <code>True</code> <code>normal</code> <code>bool</code> <p>Return only FunctionType.NORMAL functions</p> <code>False</code> <p>Returns:</p> Type Description <code>Function</code> <p>A function matching the research criteria</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>When no function is found</p> Source code in <code>quokka/program.py</code> <pre><code>def get_function(\n    self, name: str, approximative: bool = True, normal: bool = False\n) -&gt; quokka.Function:\n    \"\"\"Find a function in a program by its name\n\n    Arguments:\n        name: Function name\n        approximative: Should the name exactly match or allow partial matches?\n        normal: Return only FunctionType.NORMAL functions\n\n    Returns:\n        A function matching the research criteria\n\n    Raises:\n        ValueError: When no function is found\n    \"\"\"\n    if approximative is False:\n        try:\n            return self.fun_names[name]\n        except KeyError as exc:\n            raise ValueError(\"Missing function\") from exc\n\n    for function_name, function in self.fun_names.items():\n        # TODO(dm) Improve this\n        if name in function.name and (\n            not normal or function.type == FunctionType.NORMAL\n        ):\n            return self.fun_names[function_name]\n\n    raise ValueError(\"Unable to find an appropriate function\")\n</code></pre>"},{"location":"reference/python/program/#quokka.program.Program.get_function_by_chunk","title":"<code>get_function_by_chunk(chunk)</code>","text":"<p>Retrieves all the functions where <code>chunk</code> belongs.</p> <p>Parameters:</p> Name Type Description Default <code>chunk</code> <code>Chunk</code> <p>Chunk to search for</p> required <p>Returns:</p> Type Description <code>List[Function]</code> <p>A list of corresponding functions</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>When no function is found for the chunk.</p> Source code in <code>quokka/program.py</code> <pre><code>def get_function_by_chunk(self, chunk: quokka.Chunk) -&gt; List[quokka.Function]:\n    \"\"\"Retrieves all the functions where `chunk` belongs.\n\n    Arguments:\n        chunk: Chunk to search for\n\n    Returns:\n        A list of corresponding functions\n\n    Raises:\n        IndexError: When no function is found for the chunk.\n\n    \"\"\"\n    functions = self.func_chunk_index[chunk.proto_index]\n    if not functions:\n        raise IndexError(\n            \"No function has been found for the chunk. \"\n            \"This is probably a Quokka bug and should be reported.\"\n        )\n\n    return functions\n</code></pre>"},{"location":"reference/python/program/#quokka.program.Program.get_instruction","title":"<code>get_instruction(address)</code>","text":"<p>Get an instruction by its address</p> <p>Note: the address must be the head of the instruction.</p> <p>TODO(dm): Improve the algorithm because the chunks are sorted (use bisect)</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>AddressT</code> <p>AddressT: Address to query</p> required <p>Returns:</p> Type Description <code>Instruction</code> <p>A <code>quokka.Instruction</code></p> <p>Raises:</p> Type Description <code>IndexError</code> <p>When no instruction is found at this address</p> Source code in <code>quokka/program.py</code> <pre><code>def get_instruction(self, address: AddressT) -&gt; quokka.Instruction:\n    \"\"\"Get an instruction by its address\n\n    Note: the address must be the head of the instruction.\n\n    TODO(dm): Improve the algorithm because the chunks are sorted (use bisect)\n\n    Arguments:\n        address: AddressT: Address to query\n\n    Returns:\n        A `quokka.Instruction`\n\n    Raises:\n        IndexError: When no instruction is found at this address\n    \"\"\"\n    for chunk in self.chunks.values():\n        if chunk.in_chunk(address):\n            try:\n                return chunk.get_instruction(address)\n            except IndexError:\n                pass\n\n    raise IndexError(f\"No instruction at address 0x{address:x}\")\n</code></pre>"},{"location":"reference/python/program/#quokka.program.Program.get_segment","title":"<code>get_segment(address)</code>","text":"<p>Get a <code>Segment</code> by an address</p> <p>The address must be in [segment.start, segment.end) to be found.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>AddressT</code> <p>Segment's address</p> required <p>Returns:</p> Type Description <code>Segment</code> <p>The corresponding Segment</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>When the segment is not found</p> Source code in <code>quokka/program.py</code> <pre><code>def get_segment(self, address: AddressT) -&gt; quokka.Segment:\n    \"\"\"Get a `Segment` by an address\n\n    The address must be in [segment.start, segment.end) to be found.\n\n    Arguments:\n        address: Segment's address\n\n    Returns:\n        The corresponding Segment\n\n    Raises:\n        KeyError: When the segment is not found\n    \"\"\"\n    for segment in self.segments:\n        if segment.in_segment(address):\n            return segment\n\n    raise KeyError(f\"No segment has been found for address {address:#x}\")\n</code></pre>"},{"location":"reference/python/program/#quokka.program.Program.iter_chunk","title":"<code>iter_chunk(chunk_types=None)</code>","text":"<p>Iterate over all the chunks in the program.</p> <p>If a <code>SuperChunk</code> is found, it will split it and return individual chunks. By default, it iterates over all the chunks, even extern functions.</p> <p>Parameters:</p> Name Type Description Default <code>chunk_types</code> <code>Optional[List[FunctionType]]</code> <p>Allow list of chunk types. By default, it retrieves every chunk.</p> <code>None</code> <p>Yields:</p> Type Description <code>Chunk</code> <p>All the chunks in the program.</p> Source code in <code>quokka/program.py</code> <pre><code>def iter_chunk(\n    self, chunk_types: Optional[List[FunctionType]] = None\n) -&gt; Iterator[quokka.Chunk]:\n    \"\"\"Iterate over all the chunks in the program.\n\n    If a `SuperChunk` is found, it will split it and return individual chunks.\n    By default, it iterates over all the chunks, even extern functions.\n\n    Arguments:\n        chunk_types: Allow list of chunk types. By default, it retrieves every\n            chunk.\n\n    Yields:\n        All the chunks in the program.\n    \"\"\"\n\n    if chunk_types is None:\n        chunk_types = list(FunctionType)\n\n    chunk: quokka.Chunk\n    for chunk in self.chunks.values():\n        if isinstance(chunk, quokka.SuperChunk):\n            inner_chunk: quokka.Chunk\n            for inner_chunk in chunk.values():\n                if inner_chunk.chunk_type in chunk_types:\n                    yield inner_chunk\n        else:\n            if chunk.chunk_type in chunk_types:\n                yield chunk\n</code></pre>"},{"location":"reference/python/program/#quokka.program.Program.read_bytes","title":"<code>read_bytes(v_addr, size)</code>","text":"<p>Read raw bytes from a virtual address</p> <p>Parameters:</p> Name Type Description Default <code>v_addr</code> <code>AddressT</code> <p>Virtual address of the data to read</p> required <code>size</code> <code>int</code> <p>Size of the data to read</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The raw data at the specified address</p> Source code in <code>quokka/program.py</code> <pre><code>def read_bytes(self, v_addr: AddressT, size: int) -&gt; bytes:\n    \"\"\"Read raw bytes from a virtual address\n\n    Arguments:\n        v_addr: Virtual address of the data to read\n        size: Size of the data to read\n\n    Returns:\n        The raw data at the specified address\n    \"\"\"\n\n    if (offset := v_addr - self.base_address) &lt; 0:\n        raise ValueError(\"Address outside virtual address space.\")\n    return self.executable.read_bytes(offset, size)\n</code></pre>"},{"location":"reference/python/reference/","title":"reference","text":"<p>References Management</p> <p>This module deals with all references between different objects in the code.</p> A reference is an object with the following attributes <ul> <li>A Source</li> <li>A Destination</li> <li>A Type</li> </ul> <p>As they are stored in a complex manner, this module deals with their resolution, i.e. how to resolve the pointed object.</p> <p>There is room for improvement here. ;)</p>"},{"location":"reference/python/reference/#quokka.reference.Reference","title":"<code>Reference</code>","text":"<p>Reference: a link between a source and a destination</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>ReferenceTarget</code> <p>Source of the reference</p> required <code>destination</code> <code>ReferenceTarget</code> <p>Destination (target) of the reference</p> required <code>type_</code> <code>ReferenceType</code> <p>Type of the reference</p> required <p>Attributes:</p> Name Type Description <code>source</code> <code>ReferenceTarget</code> <p>Source of the reference</p> <code>destination</code> <code>ReferenceTarget</code> <p>Destination (target) of the reference</p> <code>type</code> <code>ReferenceType</code> <p>Type of the reference</p> Source code in <code>quokka/reference.py</code> <pre><code>class Reference:\n    \"\"\"Reference: a link between a source and a destination\n\n    Arguments:\n        source: Source of the reference\n        destination: Destination (target) of the reference\n        type_: Type of the reference\n\n    Attributes:\n        source: Source of the reference\n        destination: Destination (target) of the reference\n        type: Type of the reference\n    \"\"\"\n\n    def __init__(\n        self,\n        source: ReferenceTarget,\n        destination: ReferenceTarget,\n        type_: ReferenceType,\n    ) -&gt; None:\n        \"\"\"Constructor\"\"\"\n        self.source: ReferenceTarget = source\n        self.destination: ReferenceTarget = destination\n        self.type: ReferenceType = type_\n</code></pre>"},{"location":"reference/python/reference/#quokka.reference.Reference.__init__","title":"<code>__init__(source, destination, type_)</code>","text":"<p>Constructor</p> Source code in <code>quokka/reference.py</code> <pre><code>def __init__(\n    self,\n    source: ReferenceTarget,\n    destination: ReferenceTarget,\n    type_: ReferenceType,\n) -&gt; None:\n    \"\"\"Constructor\"\"\"\n    self.source: ReferenceTarget = source\n    self.destination: ReferenceTarget = destination\n    self.type: ReferenceType = type_\n</code></pre>"},{"location":"reference/python/reference/#quokka.reference.References","title":"<code>References</code>","text":"<p>               Bases: <code>Mapping</code></p> <p>References bucket : maintain the list of all references inside the program</p> <p>The instantiation of the class will create a mapping for every reference but not resolve them yet.</p> <p>This class is probably the most messy one in Quokka and needs a global refactoring. However, since it's somehow working, let's try to not break it yet.</p> <p>Parameters:</p> Name Type Description Default <code>program</code> <code>Program</code> <p>Reference to the program</p> required <p>Attributes:</p> Name Type Description <code>program</code> <code>Program</code> <p>Reference to the program</p> <code>proto_ref</code> <p>Protobuf data</p> <code>references_category</code> <code>Dict[ReferencesLocation, DefaultDict]</code> <p>A mapping that contains every reference for each direction. For instance, a ref X from inst a to struct b will be stored in both the structure key and the instruction key</p> Source code in <code>quokka/reference.py</code> <pre><code>class References(Mapping):\n    \"\"\"References bucket : maintain the list of all references inside the program\n\n    The instantiation of the class will create a mapping for every reference but not\n    resolve them yet.\n\n    This class is probably the most messy one in Quokka and needs a global refactoring.\n    However, since it's somehow working, let's try to not break it yet.\n\n    Arguments:\n        program: Reference to the program\n\n    Attributes:\n        program: Reference to the program\n        proto_ref: Protobuf data\n        references_category: A mapping that contains every reference for each direction.\n            For instance, a ref X from inst a to struct b will be stored in both the\n            structure key and the instruction key\n\n    \"\"\"\n\n    SOURCE = \"source\"\n    DESTINATION = \"destination\"\n\n    def __init__(self, program: quokka.Program) -&gt; None:\n        \"\"\"Init method\n\n        Arguments:\n            program: A backref to program\n        \"\"\"\n\n        # Define the update method\n        def update(\n            mapping: Mapping,  # type: ignore\n            key: Union[Tuple[int], LocationValueType],\n            value: Index,\n        ) -&gt; None:\n            \"\"\"Recursive method to update the `self.references_category` mapping\"\"\"\n            if isinstance(key, int):\n                mapping[key].append(value)\n                return\n\n            current_key: int = key[0]\n            sub_key: Union[Tuple[()], Tuple[int], Tuple[int, int]] = key[1:]\n            if sub_key:\n                update(mapping[current_key], sub_key, value)\n            elif not isinstance(mapping.get(current_key), MutableMapping):\n                mapping[current_key].append(value)\n\n        self.program: quokka.Program = program\n        self.proto_ref = program.proto.references\n\n        # Init the references mapping\n        self.references_category: Dict[ReferencesLocation, DefaultDict] = {  # type: ignore\n            ReferencesLocation.INSTRUCTION: collections.defaultdict(list),\n            ReferencesLocation.DATA: collections.defaultdict(list),\n            ReferencesLocation.STRUCTURE: collections.defaultdict(\n                lambda: collections.defaultdict(list)\n            ),\n            ReferencesLocation.INST_INSTANCE: collections.defaultdict(\n                lambda: collections.defaultdict(lambda: collections.defaultdict(list))\n            ),\n            ReferencesLocation.FUNCTION: collections.defaultdict(list),\n            ReferencesLocation.CHUNK: collections.defaultdict(list),\n        }\n\n        reference: quokka.pb.Quokka.Reference\n        for index, reference in enumerate(self.proto_ref):\n            source_ref = self.references_category[self.location_type(reference.source)]\n            update(source_ref, self.get_location_value(reference.source), index)\n\n            destination_ref = self.references_category[\n                self.location_type(reference.destination)\n            ]\n            update(\n                destination_ref, self.get_location_value(reference.destination), index\n            )\n\n    @staticmethod\n    def location_type(\n        location: quokka.pb.Quokka.Location,\n    ) -&gt; ReferencesLocation:\n        \"\"\"Convert the proto location type\"\"\"\n        return ReferencesLocation.from_proto(location.WhichOneof(\"LocationType\"))\n\n    def get_location_value(\n        self, location: quokka.pb.Quokka.Location\n    ) -&gt; LocationValueType:\n        \"\"\"Resolve a location\n\n        This method resolves a location for quokka.\n\n        Arguments:\n            location: Reference location\n\n        Returns:\n            A LocationTypeValue\n        \"\"\"\n        location_type: ReferencesLocation = self.location_type(location)\n        location_value: LocationValueType = getattr(location, location_type.value)\n\n        if location_type in (\n            ReferencesLocation.INSTRUCTION,\n            ReferencesLocation.DATA,\n            ReferencesLocation.FUNCTION,\n            ReferencesLocation.CHUNK,\n        ):\n            return location_value\n\n        elif location_type == ReferencesLocation.STRUCTURE:\n            structure_idx: int = getattr(location_value, \"structure_idx\")\n\n            if getattr(location_value, \"no_member\") is False:\n                return structure_idx, getattr(location_value, \"member_idx\")\n\n            return structure_idx, -1\n\n        elif location_type == ReferencesLocation.INST_INSTANCE:\n            return (\n                getattr(location_value, \"func_chunk_idx\"),\n                getattr(location_value, \"block_idx\"),\n                getattr(location_value, \"instruction_idx\"),\n            )\n\n        raise ValueError\n\n    def __getitem__(self, k: Index) -&gt; Reference:\n        \"\"\"Lazy loading for references\"\"\"\n        return self.create_reference(self.proto_ref[k])\n\n    def __len__(self) -&gt; int:\n        \"\"\"References count\"\"\"\n        return len(self.proto_ref)\n\n    def __iter__(self) -&gt; Iterator[Dict[AddressT, Reference]]:\n        \"\"\"Iterator over references\"\"\"\n        raise NotImplementedError\n\n    @property\n    def structures(self) -&gt; List[quokka.Structure]:\n        \"\"\"Accessor to the program structures\"\"\"\n        return self.program.structures\n\n    @property\n    def data(self):\n        \"\"\"Accessor to the program PROTO data\"\"\"\n        return self.program.proto.data\n\n    @property\n    def instructions(self):\n        \"\"\"Accessor to the program proto instruction\"\"\"\n        return self.program.proto.instructions\n\n    def create_reference(self, reference: quokka.pb.Quokka.Reference) -&gt; \"Reference\":\n        \"\"\"Create a reference\n\n        Start with resolving both the source and the destination.\n\n        Arguments:\n            reference: A protobuf reference object\n\n        Returns:\n            A python reference with both source and destination resolved\n        \"\"\"\n        source: ReferenceTarget = self.resolve_location(reference.source)\n        destination: ReferenceTarget = self.resolve_location(reference.destination)\n\n        return Reference(\n            source, destination, ReferenceType.from_proto(reference.reference_type)\n        )\n\n    def find_instruction(\n        self,\n        instruction_identifier: \"quokka.pb.Quokka.Location.InstructionIdentifier\",\n    ) -&gt; Tuple[quokka.Chunk, quokka.Block, Index]:\n        \"\"\"Search an instruction from an instruction identifier.\n\n        The parameters are a chunk index, a block index, and an inst index inside the\n        block.\n\n        Arguments:\n            instruction_identifier: Protobuf instruction identifier\n\n        Returns:\n            A instruction tuple (Chunk, Block, Instruction Index)\n        \"\"\"\n        chunk = self.program.get_chunk(\n            instruction_identifier.func_chunk_idx, instruction_identifier.block_idx\n        )\n        block = chunk[chunk.index_to_address[instruction_identifier.block_idx]]\n        return chunk, block, instruction_identifier.instruction_idx\n\n    def resolve_location(self, location: quokka.pb.Quokka.Location) -&gt; ReferenceTarget:\n        \"\"\"Resolve a location\n\n        This convert a proto location to the actual instance of the object.\n\n        Arguments:\n            location: A protobuf Location (sigh) object\n\n        Returns:\n            A ReferenceTarget\n\n        Raises:\n            ValueError: When no appropriate location has been found.\n        \"\"\"\n        location_type: ReferencesLocation = self.location_type(location)\n        if location_type == ReferencesLocation.INSTRUCTION:\n            raise DeprecationWarning(\"Not used anymore\")\n\n        elif location_type == ReferencesLocation.DATA:\n            return self.program.data_holder[location.data_idx]\n\n        elif location_type == ReferencesLocation.STRUCTURE:\n            structure: quokka.Structure = self.structures[\n                location.struct_position.structure_idx\n            ]\n            if location.struct_position.no_member is False:\n                return structure[\n                    structure.index_to_offset[location.struct_position.member_idx]\n                ]\n            return structure\n\n        elif location_type == ReferencesLocation.INST_INSTANCE:\n            return self.find_instruction(location.instruction_position)\n\n        elif location_type == ReferencesLocation.CHUNK:\n            return self.program.chunks[location.chunk_idx]\n\n        raise ValueError(\"No location found\")\n\n    @staticmethod\n    def get_direction(towards: bool = True) -&gt; Tuple[str, str]:\n        \"\"\"Helper method to analyze if we take the reference or unwind it\"\"\"\n        target = \"destination\" if towards else \"source\"\n        wanted = \"destination\" if not towards else \"source\"\n\n        return target, wanted\n\n    def resolve_block_references(\n        self,\n        chunk_index: Index,\n        block_index: Index,\n        reference_type: ReferenceType,\n        towards: bool = True,\n    ) -&gt; List[Reference]:\n        \"\"\"Return a list of references from/towards a block.\n\n        Arguments:\n            chunk_index: Index of the chunk\n            block_index: Index of the block\n            reference_type: TYpe of reference wanted (e.g. Data)\n            towards: True if we want the reference *to* this block.\n                False if we want the references *from* the block.\n\n        Returns:\n            A List of references matching the criteria\n        \"\"\"\n        target, _ = self.get_direction(towards)\n\n        return_list = []\n        for reference_ids in self.references_category[ReferencesLocation.INST_INSTANCE][\n            chunk_index\n        ][block_index].values():\n            for reference_id in reference_ids:\n                reference: Reference = self[reference_id]\n                if reference.type == reference_type and isinstance(\n                    getattr(reference, target), tuple\n                ):\n                    target_loc = getattr(reference, target)\n                    if (target_loc[0].proto_index, target_loc[1].proto_index) == (\n                        chunk_index,\n                        block_index,\n                    ):\n                        return_list.append(reference)\n\n        return return_list\n\n    def resolve_inst_instance(\n        self,\n        inst_tuple: Tuple[int, int, int],\n        reference_type: Optional[ReferenceType] = None,\n        towards: bool = True,\n    ) -&gt; List[Reference]:\n        \"\"\"Resolve instruction references\n\n        Return a list of references from/towards an instruction.\n        If a reference_type is specified the references will be filtered by their type\n\n        Arguments:\n            inst_tuple: A tuple (Chunk Index, Block Index, Instruction Index)\n            reference_type: Reference type to consider (filter result)\n            towards: In which sense to search the reference?\n\n        Returns:\n            A list of reference matching the criteria\n        \"\"\"\n        return_list = []\n        target, _ = self.get_direction(towards)\n\n        for reference_idx in self.references_category[ReferencesLocation.INST_INSTANCE][\n            inst_tuple[0]\n        ][inst_tuple[1]][inst_tuple[2]]:\n            reference: \"Reference\" = self[reference_idx]\n            if (not reference_type or reference.type == reference_type) and isinstance(\n                getattr(reference, target), tuple\n            ):\n                target_loc = getattr(reference, target)\n                if (\n                    target_loc[0].proto_index,\n                    target_loc[1].proto_index,\n                    target_loc[2],\n                ) == inst_tuple:\n                    return_list.append(reference)\n\n        return return_list\n\n    def resolve_calls(\n        self, chunk: quokka.Chunk, towards: bool = True\n    ) -&gt; List[Union[Tuple[quokka.Chunk, quokka.Block, int], quokka.Chunk]]:\n        \"\"\"Resolve calls to a chunk\n\n        This method resolves calls initiated or received from every instruction in a\n        chunk. Of note, a call must be from an Instruction Tuple to another.\n\n        Arguments:\n            chunk: Target chunk\n            towards: Do we look at calls towards this chunk {X,Y,Z} -&gt; Chunk or at calls\n                from this chunk Chunk -&gt; {X,Y,Z} ?\n\n        Returns:\n            A list of objects that are either tuple (Chunk, Block, Instruction Index) or\n            Chunk (only for fake chunks that are created from an imported function)\n        \"\"\"\n        return_list = []\n        target, wanted = self.get_direction(towards)\n\n        for block_index in self.references_category[ReferencesLocation.INST_INSTANCE][\n            chunk.proto_index\n        ]:\n            # For super-chunks, filter out block that do not belong to this chunk\n            # anymore\n            if block_index not in chunk.index_to_address:\n                continue\n\n            block_references = self.references_category[\n                ReferencesLocation.INST_INSTANCE\n            ][chunk.proto_index][block_index]\n            for references in block_references.values():\n                for reference_idx in references:\n                    reference: \"Reference\" = self[reference_idx]\n                    if reference.type == ReferenceType.CALL and isinstance(\n                        getattr(reference, target), tuple\n                    ):\n                        target_loc = getattr(reference, target)\n                        if target_loc[0].proto_index == chunk.proto_index:\n                            location = getattr(reference, wanted)\n                            # Fix: Only returns valid tuple\n                            # TODO(dm): check why sometimes a Data might be returned\n                            if isinstance(location, (tuple, quokka.Chunk)):\n                                return_list.append(location)\n\n        return return_list\n\n    def resolve_data(\n        self,\n        data_index: Index,\n        reference_type: Union[ReferenceType, None] = None,\n    ) -&gt; List[Reference]:\n        \"\"\"Resolve data references\n\n        Returns a list of reference towards a data\n        If a reference_type is specified the references will be filtered by their type\n\n        Arguments:\n            data_index: Index of the data in the protobuf\n            reference_type: Type of reference\n\n        Returns:\n            A list of reference matching the criteria\n        \"\"\"\n\n        references: List[Reference] = []\n        for reference_idx in self.references_category[ReferencesLocation.DATA][\n            data_index\n        ]:\n            reference = self[reference_idx]\n\n            if reference_type is not None and reference_type != reference.type:\n                continue\n\n            references.append(reference)\n\n        return references\n</code></pre>"},{"location":"reference/python/reference/#quokka.reference.References.data","title":"<code>data</code>  <code>property</code>","text":"<p>Accessor to the program PROTO data</p>"},{"location":"reference/python/reference/#quokka.reference.References.instructions","title":"<code>instructions</code>  <code>property</code>","text":"<p>Accessor to the program proto instruction</p>"},{"location":"reference/python/reference/#quokka.reference.References.structures","title":"<code>structures</code>  <code>property</code>","text":"<p>Accessor to the program structures</p>"},{"location":"reference/python/reference/#quokka.reference.References.__getitem__","title":"<code>__getitem__(k)</code>","text":"<p>Lazy loading for references</p> Source code in <code>quokka/reference.py</code> <pre><code>def __getitem__(self, k: Index) -&gt; Reference:\n    \"\"\"Lazy loading for references\"\"\"\n    return self.create_reference(self.proto_ref[k])\n</code></pre>"},{"location":"reference/python/reference/#quokka.reference.References.__init__","title":"<code>__init__(program)</code>","text":"<p>Init method</p> <p>Parameters:</p> Name Type Description Default <code>program</code> <code>Program</code> <p>A backref to program</p> required Source code in <code>quokka/reference.py</code> <pre><code>def __init__(self, program: quokka.Program) -&gt; None:\n    \"\"\"Init method\n\n    Arguments:\n        program: A backref to program\n    \"\"\"\n\n    # Define the update method\n    def update(\n        mapping: Mapping,  # type: ignore\n        key: Union[Tuple[int], LocationValueType],\n        value: Index,\n    ) -&gt; None:\n        \"\"\"Recursive method to update the `self.references_category` mapping\"\"\"\n        if isinstance(key, int):\n            mapping[key].append(value)\n            return\n\n        current_key: int = key[0]\n        sub_key: Union[Tuple[()], Tuple[int], Tuple[int, int]] = key[1:]\n        if sub_key:\n            update(mapping[current_key], sub_key, value)\n        elif not isinstance(mapping.get(current_key), MutableMapping):\n            mapping[current_key].append(value)\n\n    self.program: quokka.Program = program\n    self.proto_ref = program.proto.references\n\n    # Init the references mapping\n    self.references_category: Dict[ReferencesLocation, DefaultDict] = {  # type: ignore\n        ReferencesLocation.INSTRUCTION: collections.defaultdict(list),\n        ReferencesLocation.DATA: collections.defaultdict(list),\n        ReferencesLocation.STRUCTURE: collections.defaultdict(\n            lambda: collections.defaultdict(list)\n        ),\n        ReferencesLocation.INST_INSTANCE: collections.defaultdict(\n            lambda: collections.defaultdict(lambda: collections.defaultdict(list))\n        ),\n        ReferencesLocation.FUNCTION: collections.defaultdict(list),\n        ReferencesLocation.CHUNK: collections.defaultdict(list),\n    }\n\n    reference: quokka.pb.Quokka.Reference\n    for index, reference in enumerate(self.proto_ref):\n        source_ref = self.references_category[self.location_type(reference.source)]\n        update(source_ref, self.get_location_value(reference.source), index)\n\n        destination_ref = self.references_category[\n            self.location_type(reference.destination)\n        ]\n        update(\n            destination_ref, self.get_location_value(reference.destination), index\n        )\n</code></pre>"},{"location":"reference/python/reference/#quokka.reference.References.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterator over references</p> Source code in <code>quokka/reference.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Dict[AddressT, Reference]]:\n    \"\"\"Iterator over references\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/python/reference/#quokka.reference.References.__len__","title":"<code>__len__()</code>","text":"<p>References count</p> Source code in <code>quokka/reference.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"References count\"\"\"\n    return len(self.proto_ref)\n</code></pre>"},{"location":"reference/python/reference/#quokka.reference.References.create_reference","title":"<code>create_reference(reference)</code>","text":"<p>Create a reference</p> <p>Start with resolving both the source and the destination.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>Reference</code> <p>A protobuf reference object</p> required <p>Returns:</p> Type Description <code>'Reference'</code> <p>A python reference with both source and destination resolved</p> Source code in <code>quokka/reference.py</code> <pre><code>def create_reference(self, reference: quokka.pb.Quokka.Reference) -&gt; \"Reference\":\n    \"\"\"Create a reference\n\n    Start with resolving both the source and the destination.\n\n    Arguments:\n        reference: A protobuf reference object\n\n    Returns:\n        A python reference with both source and destination resolved\n    \"\"\"\n    source: ReferenceTarget = self.resolve_location(reference.source)\n    destination: ReferenceTarget = self.resolve_location(reference.destination)\n\n    return Reference(\n        source, destination, ReferenceType.from_proto(reference.reference_type)\n    )\n</code></pre>"},{"location":"reference/python/reference/#quokka.reference.References.find_instruction","title":"<code>find_instruction(instruction_identifier)</code>","text":"<p>Search an instruction from an instruction identifier.</p> <p>The parameters are a chunk index, a block index, and an inst index inside the block.</p> <p>Parameters:</p> Name Type Description Default <code>instruction_identifier</code> <code>'quokka.pb.Quokka.Location.InstructionIdentifier'</code> <p>Protobuf instruction identifier</p> required <p>Returns:</p> Type Description <code>Tuple[Chunk, Block, Index]</code> <p>A instruction tuple (Chunk, Block, Instruction Index)</p> Source code in <code>quokka/reference.py</code> <pre><code>def find_instruction(\n    self,\n    instruction_identifier: \"quokka.pb.Quokka.Location.InstructionIdentifier\",\n) -&gt; Tuple[quokka.Chunk, quokka.Block, Index]:\n    \"\"\"Search an instruction from an instruction identifier.\n\n    The parameters are a chunk index, a block index, and an inst index inside the\n    block.\n\n    Arguments:\n        instruction_identifier: Protobuf instruction identifier\n\n    Returns:\n        A instruction tuple (Chunk, Block, Instruction Index)\n    \"\"\"\n    chunk = self.program.get_chunk(\n        instruction_identifier.func_chunk_idx, instruction_identifier.block_idx\n    )\n    block = chunk[chunk.index_to_address[instruction_identifier.block_idx]]\n    return chunk, block, instruction_identifier.instruction_idx\n</code></pre>"},{"location":"reference/python/reference/#quokka.reference.References.get_direction","title":"<code>get_direction(towards=True)</code>  <code>staticmethod</code>","text":"<p>Helper method to analyze if we take the reference or unwind it</p> Source code in <code>quokka/reference.py</code> <pre><code>@staticmethod\ndef get_direction(towards: bool = True) -&gt; Tuple[str, str]:\n    \"\"\"Helper method to analyze if we take the reference or unwind it\"\"\"\n    target = \"destination\" if towards else \"source\"\n    wanted = \"destination\" if not towards else \"source\"\n\n    return target, wanted\n</code></pre>"},{"location":"reference/python/reference/#quokka.reference.References.get_location_value","title":"<code>get_location_value(location)</code>","text":"<p>Resolve a location</p> <p>This method resolves a location for quokka.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Location</code> <p>Reference location</p> required <p>Returns:</p> Type Description <code>LocationValueType</code> <p>A LocationTypeValue</p> Source code in <code>quokka/reference.py</code> <pre><code>def get_location_value(\n    self, location: quokka.pb.Quokka.Location\n) -&gt; LocationValueType:\n    \"\"\"Resolve a location\n\n    This method resolves a location for quokka.\n\n    Arguments:\n        location: Reference location\n\n    Returns:\n        A LocationTypeValue\n    \"\"\"\n    location_type: ReferencesLocation = self.location_type(location)\n    location_value: LocationValueType = getattr(location, location_type.value)\n\n    if location_type in (\n        ReferencesLocation.INSTRUCTION,\n        ReferencesLocation.DATA,\n        ReferencesLocation.FUNCTION,\n        ReferencesLocation.CHUNK,\n    ):\n        return location_value\n\n    elif location_type == ReferencesLocation.STRUCTURE:\n        structure_idx: int = getattr(location_value, \"structure_idx\")\n\n        if getattr(location_value, \"no_member\") is False:\n            return structure_idx, getattr(location_value, \"member_idx\")\n\n        return structure_idx, -1\n\n    elif location_type == ReferencesLocation.INST_INSTANCE:\n        return (\n            getattr(location_value, \"func_chunk_idx\"),\n            getattr(location_value, \"block_idx\"),\n            getattr(location_value, \"instruction_idx\"),\n        )\n\n    raise ValueError\n</code></pre>"},{"location":"reference/python/reference/#quokka.reference.References.location_type","title":"<code>location_type(location)</code>  <code>staticmethod</code>","text":"<p>Convert the proto location type</p> Source code in <code>quokka/reference.py</code> <pre><code>@staticmethod\ndef location_type(\n    location: quokka.pb.Quokka.Location,\n) -&gt; ReferencesLocation:\n    \"\"\"Convert the proto location type\"\"\"\n    return ReferencesLocation.from_proto(location.WhichOneof(\"LocationType\"))\n</code></pre>"},{"location":"reference/python/reference/#quokka.reference.References.resolve_block_references","title":"<code>resolve_block_references(chunk_index, block_index, reference_type, towards=True)</code>","text":"<p>Return a list of references from/towards a block.</p> <p>Parameters:</p> Name Type Description Default <code>chunk_index</code> <code>Index</code> <p>Index of the chunk</p> required <code>block_index</code> <code>Index</code> <p>Index of the block</p> required <code>reference_type</code> <code>ReferenceType</code> <p>TYpe of reference wanted (e.g. Data)</p> required <code>towards</code> <code>bool</code> <p>True if we want the reference to this block. False if we want the references from the block.</p> <code>True</code> <p>Returns:</p> Type Description <code>List[Reference]</code> <p>A List of references matching the criteria</p> Source code in <code>quokka/reference.py</code> <pre><code>def resolve_block_references(\n    self,\n    chunk_index: Index,\n    block_index: Index,\n    reference_type: ReferenceType,\n    towards: bool = True,\n) -&gt; List[Reference]:\n    \"\"\"Return a list of references from/towards a block.\n\n    Arguments:\n        chunk_index: Index of the chunk\n        block_index: Index of the block\n        reference_type: TYpe of reference wanted (e.g. Data)\n        towards: True if we want the reference *to* this block.\n            False if we want the references *from* the block.\n\n    Returns:\n        A List of references matching the criteria\n    \"\"\"\n    target, _ = self.get_direction(towards)\n\n    return_list = []\n    for reference_ids in self.references_category[ReferencesLocation.INST_INSTANCE][\n        chunk_index\n    ][block_index].values():\n        for reference_id in reference_ids:\n            reference: Reference = self[reference_id]\n            if reference.type == reference_type and isinstance(\n                getattr(reference, target), tuple\n            ):\n                target_loc = getattr(reference, target)\n                if (target_loc[0].proto_index, target_loc[1].proto_index) == (\n                    chunk_index,\n                    block_index,\n                ):\n                    return_list.append(reference)\n\n    return return_list\n</code></pre>"},{"location":"reference/python/reference/#quokka.reference.References.resolve_calls","title":"<code>resolve_calls(chunk, towards=True)</code>","text":"<p>Resolve calls to a chunk</p> <p>This method resolves calls initiated or received from every instruction in a chunk. Of note, a call must be from an Instruction Tuple to another.</p> <p>Parameters:</p> Name Type Description Default <code>chunk</code> <code>Chunk</code> <p>Target chunk</p> required <code>towards</code> <code>bool</code> <p>Do we look at calls towards this chunk {X,Y,Z} -&gt; Chunk or at calls from this chunk Chunk -&gt; {X,Y,Z} ?</p> <code>True</code> <p>Returns:</p> Type Description <code>List[Union[Tuple[Chunk, Block, int], Chunk]]</code> <p>A list of objects that are either tuple (Chunk, Block, Instruction Index) or</p> <code>List[Union[Tuple[Chunk, Block, int], Chunk]]</code> <p>Chunk (only for fake chunks that are created from an imported function)</p> Source code in <code>quokka/reference.py</code> <pre><code>def resolve_calls(\n    self, chunk: quokka.Chunk, towards: bool = True\n) -&gt; List[Union[Tuple[quokka.Chunk, quokka.Block, int], quokka.Chunk]]:\n    \"\"\"Resolve calls to a chunk\n\n    This method resolves calls initiated or received from every instruction in a\n    chunk. Of note, a call must be from an Instruction Tuple to another.\n\n    Arguments:\n        chunk: Target chunk\n        towards: Do we look at calls towards this chunk {X,Y,Z} -&gt; Chunk or at calls\n            from this chunk Chunk -&gt; {X,Y,Z} ?\n\n    Returns:\n        A list of objects that are either tuple (Chunk, Block, Instruction Index) or\n        Chunk (only for fake chunks that are created from an imported function)\n    \"\"\"\n    return_list = []\n    target, wanted = self.get_direction(towards)\n\n    for block_index in self.references_category[ReferencesLocation.INST_INSTANCE][\n        chunk.proto_index\n    ]:\n        # For super-chunks, filter out block that do not belong to this chunk\n        # anymore\n        if block_index not in chunk.index_to_address:\n            continue\n\n        block_references = self.references_category[\n            ReferencesLocation.INST_INSTANCE\n        ][chunk.proto_index][block_index]\n        for references in block_references.values():\n            for reference_idx in references:\n                reference: \"Reference\" = self[reference_idx]\n                if reference.type == ReferenceType.CALL and isinstance(\n                    getattr(reference, target), tuple\n                ):\n                    target_loc = getattr(reference, target)\n                    if target_loc[0].proto_index == chunk.proto_index:\n                        location = getattr(reference, wanted)\n                        # Fix: Only returns valid tuple\n                        # TODO(dm): check why sometimes a Data might be returned\n                        if isinstance(location, (tuple, quokka.Chunk)):\n                            return_list.append(location)\n\n    return return_list\n</code></pre>"},{"location":"reference/python/reference/#quokka.reference.References.resolve_data","title":"<code>resolve_data(data_index, reference_type=None)</code>","text":"<p>Resolve data references</p> <p>Returns a list of reference towards a data If a reference_type is specified the references will be filtered by their type</p> <p>Parameters:</p> Name Type Description Default <code>data_index</code> <code>Index</code> <p>Index of the data in the protobuf</p> required <code>reference_type</code> <code>Union[ReferenceType, None]</code> <p>Type of reference</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reference]</code> <p>A list of reference matching the criteria</p> Source code in <code>quokka/reference.py</code> <pre><code>def resolve_data(\n    self,\n    data_index: Index,\n    reference_type: Union[ReferenceType, None] = None,\n) -&gt; List[Reference]:\n    \"\"\"Resolve data references\n\n    Returns a list of reference towards a data\n    If a reference_type is specified the references will be filtered by their type\n\n    Arguments:\n        data_index: Index of the data in the protobuf\n        reference_type: Type of reference\n\n    Returns:\n        A list of reference matching the criteria\n    \"\"\"\n\n    references: List[Reference] = []\n    for reference_idx in self.references_category[ReferencesLocation.DATA][\n        data_index\n    ]:\n        reference = self[reference_idx]\n\n        if reference_type is not None and reference_type != reference.type:\n            continue\n\n        references.append(reference)\n\n    return references\n</code></pre>"},{"location":"reference/python/reference/#quokka.reference.References.resolve_inst_instance","title":"<code>resolve_inst_instance(inst_tuple, reference_type=None, towards=True)</code>","text":"<p>Resolve instruction references</p> <p>Return a list of references from/towards an instruction. If a reference_type is specified the references will be filtered by their type</p> <p>Parameters:</p> Name Type Description Default <code>inst_tuple</code> <code>Tuple[int, int, int]</code> <p>A tuple (Chunk Index, Block Index, Instruction Index)</p> required <code>reference_type</code> <code>Optional[ReferenceType]</code> <p>Reference type to consider (filter result)</p> <code>None</code> <code>towards</code> <code>bool</code> <p>In which sense to search the reference?</p> <code>True</code> <p>Returns:</p> Type Description <code>List[Reference]</code> <p>A list of reference matching the criteria</p> Source code in <code>quokka/reference.py</code> <pre><code>def resolve_inst_instance(\n    self,\n    inst_tuple: Tuple[int, int, int],\n    reference_type: Optional[ReferenceType] = None,\n    towards: bool = True,\n) -&gt; List[Reference]:\n    \"\"\"Resolve instruction references\n\n    Return a list of references from/towards an instruction.\n    If a reference_type is specified the references will be filtered by their type\n\n    Arguments:\n        inst_tuple: A tuple (Chunk Index, Block Index, Instruction Index)\n        reference_type: Reference type to consider (filter result)\n        towards: In which sense to search the reference?\n\n    Returns:\n        A list of reference matching the criteria\n    \"\"\"\n    return_list = []\n    target, _ = self.get_direction(towards)\n\n    for reference_idx in self.references_category[ReferencesLocation.INST_INSTANCE][\n        inst_tuple[0]\n    ][inst_tuple[1]][inst_tuple[2]]:\n        reference: \"Reference\" = self[reference_idx]\n        if (not reference_type or reference.type == reference_type) and isinstance(\n            getattr(reference, target), tuple\n        ):\n            target_loc = getattr(reference, target)\n            if (\n                target_loc[0].proto_index,\n                target_loc[1].proto_index,\n                target_loc[2],\n            ) == inst_tuple:\n                return_list.append(reference)\n\n    return return_list\n</code></pre>"},{"location":"reference/python/reference/#quokka.reference.References.resolve_location","title":"<code>resolve_location(location)</code>","text":"<p>Resolve a location</p> <p>This convert a proto location to the actual instance of the object.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Location</code> <p>A protobuf Location (sigh) object</p> required <p>Returns:</p> Type Description <code>ReferenceTarget</code> <p>A ReferenceTarget</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>When no appropriate location has been found.</p> Source code in <code>quokka/reference.py</code> <pre><code>def resolve_location(self, location: quokka.pb.Quokka.Location) -&gt; ReferenceTarget:\n    \"\"\"Resolve a location\n\n    This convert a proto location to the actual instance of the object.\n\n    Arguments:\n        location: A protobuf Location (sigh) object\n\n    Returns:\n        A ReferenceTarget\n\n    Raises:\n        ValueError: When no appropriate location has been found.\n    \"\"\"\n    location_type: ReferencesLocation = self.location_type(location)\n    if location_type == ReferencesLocation.INSTRUCTION:\n        raise DeprecationWarning(\"Not used anymore\")\n\n    elif location_type == ReferencesLocation.DATA:\n        return self.program.data_holder[location.data_idx]\n\n    elif location_type == ReferencesLocation.STRUCTURE:\n        structure: quokka.Structure = self.structures[\n            location.struct_position.structure_idx\n        ]\n        if location.struct_position.no_member is False:\n            return structure[\n                structure.index_to_offset[location.struct_position.member_idx]\n            ]\n        return structure\n\n    elif location_type == ReferencesLocation.INST_INSTANCE:\n        return self.find_instruction(location.instruction_position)\n\n    elif location_type == ReferencesLocation.CHUNK:\n        return self.program.chunks[location.chunk_idx]\n\n    raise ValueError(\"No location found\")\n</code></pre>"},{"location":"reference/python/reference/#quokka.reference.ReferencesLocation","title":"<code>ReferencesLocation</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Reference location</p> A reference may be attached to one of the following <ul> <li>an instruction index (that means every instance of the instruction)</li> <li>a data index</li> <li>a structure position (e.g. a structure or a member inside a structure)</li> <li>an instruction : a tuple with (chunk, block, inst_index) identifying precisely     one instruction</li> <li>a function</li> <li>a chunk</li> </ul> Source code in <code>quokka/reference.py</code> <pre><code>class ReferencesLocation(enum.Enum):\n    \"\"\"Reference location\n\n    A reference may be attached to one of the following :\n        * an instruction index (that means every instance of the instruction)\n        * a data index\n        * a structure position (e.g. a structure or a member inside a structure)\n        * an instruction : a tuple with (chunk, block, inst_index) identifying precisely\n            one instruction\n        * a function\n        * a chunk\n    \"\"\"\n\n    INSTRUCTION = \"inst_idx\"\n    DATA = \"data_idx\"\n    STRUCTURE = \"struct_position\"\n    INST_INSTANCE = \"instruction_position\"\n    FUNCTION = \"function_idx\"\n    CHUNK = \"chunk_idx\"\n\n    @staticmethod\n    def from_proto(location_type: str) -&gt; ReferencesLocation:\n        \"\"\"Convert reference location from proto\"\"\"\n        # These are the name of the fields in the protobuf\n        mapping = {\n            \"inst_idx\": ReferencesLocation.INSTRUCTION,\n            \"data_idx\": ReferencesLocation.DATA,\n            \"struct_position\": ReferencesLocation.STRUCTURE,\n            \"instruction_position\": ReferencesLocation.INST_INSTANCE,\n            \"function_idx\": ReferencesLocation.FUNCTION,\n            \"chunk_idx\": ReferencesLocation.CHUNK,\n        }\n\n        try:\n            return mapping[location_type]\n        except IndexError as exc:\n            raise ValueError(\"Unknown location type\") from exc\n</code></pre>"},{"location":"reference/python/reference/#quokka.reference.ReferencesLocation.from_proto","title":"<code>from_proto(location_type)</code>  <code>staticmethod</code>","text":"<p>Convert reference location from proto</p> Source code in <code>quokka/reference.py</code> <pre><code>@staticmethod\ndef from_proto(location_type: str) -&gt; ReferencesLocation:\n    \"\"\"Convert reference location from proto\"\"\"\n    # These are the name of the fields in the protobuf\n    mapping = {\n        \"inst_idx\": ReferencesLocation.INSTRUCTION,\n        \"data_idx\": ReferencesLocation.DATA,\n        \"struct_position\": ReferencesLocation.STRUCTURE,\n        \"instruction_position\": ReferencesLocation.INST_INSTANCE,\n        \"function_idx\": ReferencesLocation.FUNCTION,\n        \"chunk_idx\": ReferencesLocation.CHUNK,\n    }\n\n    try:\n        return mapping[location_type]\n    except IndexError as exc:\n        raise ValueError(\"Unknown location type\") from exc\n</code></pre>"},{"location":"reference/python/segment/","title":"segment","text":"<p>Segment management</p>"},{"location":"reference/python/segment/#quokka.segment.Segment","title":"<code>Segment</code>","text":"<p>Segment</p> <p>This class represents IDA segments.</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <code>Segment</code> <p>Segment protobuf information</p> required <code>program</code> <code>Program</code> <p>Program back reference</p> required <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Segment name</p> <code>start</code> <code>AddressT</code> <p>Segment starting address</p> <code>permissions</code> <code>int</code> <p>Segment permissions</p> <code>size</code> <code>int</code> <p>Segment size</p> <code>type</code> <code>SegmentType</code> <p>Segment type</p> <code>program</code> <code>Program</code> <p>Program reference</p> <code>file_offset</code> <code>int</code> <p>Segment offset in the file (if appropriate)</p> Source code in <code>quokka/segment.py</code> <pre><code>class Segment:\n    \"\"\"Segment\n\n    This class represents IDA segments.\n\n    Arguments:\n        segment: Segment protobuf information\n        program: Program back reference\n\n    Attributes:\n        name: Segment name\n        start: Segment starting address\n        permissions: Segment permissions\n        size: Segment size\n        type: Segment type\n        program: Program reference\n        file_offset: Segment offset in the file (if appropriate)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        segment: \"quokka.pb.Quokka.Segment\",\n        program: quokka.Program,\n    ):\n        \"\"\"Constructor\"\"\"\n        self.name: str = segment.name\n        self.start: AddressT = segment.start_addr\n        self.permissions: int = segment.permissions\n        self.size: int = segment.size\n        self.type: \"SegmentType\" = SegmentType.from_proto(segment.type)\n\n        self.program: quokka.Program = program\n\n        self.file_offset: int = -1\n        if segment.no_offset is False:\n            self.file_offset = segment.file_offset - self.start\n\n    @property\n    def end(self) -&gt; AddressT:\n        \"\"\"End address of the segment\"\"\"\n        return self.start + self.size\n\n    def writable(self) -&gt; bool:\n        \"\"\"Is the segment writable?\"\"\"\n        return self.permissions &amp; 0x2 &gt; 0\n\n    def executable(self) -&gt; bool:\n        \"\"\"Is the segment executable?\"\"\"\n        return self.permissions &amp; 0x1 &gt; 0\n\n    def readable(self) -&gt; bool:\n        \"\"\"Is the segment readable?\"\"\"\n        return self.permissions &amp; 0x4 &gt; 0\n\n    def in_segment(self, addr: int) -&gt; bool:\n        \"\"\"Does `addr` belong to this segment ?\"\"\"\n        return self.start &lt;= addr &lt; self.start + self.size\n</code></pre>"},{"location":"reference/python/segment/#quokka.segment.Segment.end","title":"<code>end</code>  <code>property</code>","text":"<p>End address of the segment</p>"},{"location":"reference/python/segment/#quokka.segment.Segment.__init__","title":"<code>__init__(segment, program)</code>","text":"<p>Constructor</p> Source code in <code>quokka/segment.py</code> <pre><code>def __init__(\n    self,\n    segment: \"quokka.pb.Quokka.Segment\",\n    program: quokka.Program,\n):\n    \"\"\"Constructor\"\"\"\n    self.name: str = segment.name\n    self.start: AddressT = segment.start_addr\n    self.permissions: int = segment.permissions\n    self.size: int = segment.size\n    self.type: \"SegmentType\" = SegmentType.from_proto(segment.type)\n\n    self.program: quokka.Program = program\n\n    self.file_offset: int = -1\n    if segment.no_offset is False:\n        self.file_offset = segment.file_offset - self.start\n</code></pre>"},{"location":"reference/python/segment/#quokka.segment.Segment.executable","title":"<code>executable()</code>","text":"<p>Is the segment executable?</p> Source code in <code>quokka/segment.py</code> <pre><code>def executable(self) -&gt; bool:\n    \"\"\"Is the segment executable?\"\"\"\n    return self.permissions &amp; 0x1 &gt; 0\n</code></pre>"},{"location":"reference/python/segment/#quokka.segment.Segment.in_segment","title":"<code>in_segment(addr)</code>","text":"<p>Does <code>addr</code> belong to this segment ?</p> Source code in <code>quokka/segment.py</code> <pre><code>def in_segment(self, addr: int) -&gt; bool:\n    \"\"\"Does `addr` belong to this segment ?\"\"\"\n    return self.start &lt;= addr &lt; self.start + self.size\n</code></pre>"},{"location":"reference/python/segment/#quokka.segment.Segment.readable","title":"<code>readable()</code>","text":"<p>Is the segment readable?</p> Source code in <code>quokka/segment.py</code> <pre><code>def readable(self) -&gt; bool:\n    \"\"\"Is the segment readable?\"\"\"\n    return self.permissions &amp; 0x4 &gt; 0\n</code></pre>"},{"location":"reference/python/segment/#quokka.segment.Segment.writable","title":"<code>writable()</code>","text":"<p>Is the segment writable?</p> Source code in <code>quokka/segment.py</code> <pre><code>def writable(self) -&gt; bool:\n    \"\"\"Is the segment writable?\"\"\"\n    return self.permissions &amp; 0x2 &gt; 0\n</code></pre>"},{"location":"reference/python/structure/","title":"structure","text":"<p>Structure management</p>"},{"location":"reference/python/structure/#quokka.structure.Structure","title":"<code>Structure</code>","text":"<p>               Bases: <code>dict</code></p> <p>Structure</p> <p>All IDA structure are merged inside this class (Enum, Structure, Union).</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>'quokka.pb.Quokka.Structure'</code> <p>Structure protobuf data</p> required <code>program</code> <code>Program</code> <p>Program back reference</p> required <p>Attributes:</p> Name Type Description <code>program</code> <code>Program</code> <p>Program backreference</p> <code>name</code> <code>str</code> <p>Structure name</p> <code>size</code> <code>Optional[int]</code> <p>Structure size (if known)</p> <code>type</code> <p>Structure type</p> <code>index_to_offset</code> <code>Dict[int, int]</code> <p>Mapping from offsets to structure members</p> <code>comments</code> <code>List[str]</code> <p>Structure comments</p> Source code in <code>quokka/structure.py</code> <pre><code>class Structure(dict):\n    \"\"\"Structure\n\n    All IDA structure are merged inside this class (Enum, Structure, Union).\n\n    Arguments:\n        structure: Structure protobuf data\n        program: Program back reference\n\n    Attributes:\n        program: Program backreference\n        name: Structure name\n        size: Structure size (if known)\n        type: Structure type\n        index_to_offset: Mapping from offsets to structure members\n        comments: Structure comments\n    \"\"\"\n\n    def __init__(\n        self,\n        structure: \"quokka.pb.Quokka.Structure\",\n        program: quokka.Program,\n    ) -&gt; None:\n        \"\"\"Constructor\"\"\"\n        super(dict, self).__init__()\n        self.program: quokka.Program = program\n        self.name: str = structure.name\n        self.size: Optional[int] = (\n            structure.size if structure.variable_size is False else 0\n        )\n        self.type = StructureType.from_proto(structure.type)\n\n        self.index_to_offset: Dict[int, int] = {}\n        for index, member in enumerate(structure.members):\n            self[member.offset] = StructureMember(member, self)\n            self.index_to_offset[index] = member.offset\n\n        self.comments: List[str] = []\n</code></pre>"},{"location":"reference/python/structure/#quokka.structure.Structure.__init__","title":"<code>__init__(structure, program)</code>","text":"<p>Constructor</p> Source code in <code>quokka/structure.py</code> <pre><code>def __init__(\n    self,\n    structure: \"quokka.pb.Quokka.Structure\",\n    program: quokka.Program,\n) -&gt; None:\n    \"\"\"Constructor\"\"\"\n    super(dict, self).__init__()\n    self.program: quokka.Program = program\n    self.name: str = structure.name\n    self.size: Optional[int] = (\n        structure.size if structure.variable_size is False else 0\n    )\n    self.type = StructureType.from_proto(structure.type)\n\n    self.index_to_offset: Dict[int, int] = {}\n    for index, member in enumerate(structure.members):\n        self[member.offset] = StructureMember(member, self)\n        self.index_to_offset[index] = member.offset\n\n    self.comments: List[str] = []\n</code></pre>"},{"location":"reference/python/structure/#quokka.structure.StructureMember","title":"<code>StructureMember</code>","text":"<p>StructureMember</p> <p>This class represents structure members (fields).</p> <p>Parameters:</p> Name Type Description Default <code>member</code> <code>'quokka.pb.Quokka.Structure.Member'</code> <p>Protobuf data</p> required <code>structure</code> <code>Structure</code> <p>Reference to the parent structure</p> required <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Member name</p> <code>size</code> <code>int</code> <p>Member size (if known)</p> <code>type</code> <code>DataType</code> <p>Member data type</p> <code>value</code> <code>Optional[int]</code> <p>Member value</p> <code>comments</code> <code>List[str]</code> <p>Member comments</p> Source code in <code>quokka/structure.py</code> <pre><code>class StructureMember:\n    \"\"\"StructureMember\n\n    This class represents structure members (fields).\n\n    Arguments:\n        member: Protobuf data\n        structure: Reference to the parent structure\n\n    Attributes:\n        name: Member name\n        size: Member size (if known)\n        type: Member data type\n        value: Member value\n        comments: Member comments\n    \"\"\"\n\n    def __init__(\n        self,\n        member: \"quokka.pb.Quokka.Structure.Member\",\n        structure: Structure,\n    ) -&gt; None:\n        \"\"\"Constructor\"\"\"\n        self.name: str = member.name\n        self.type: DataType = DataType.from_proto(member.type)\n        self.size: int = member.size\n        self.value: Optional[int] = member.value if member.value != 0 else None\n        self._structure: weakref.ref[Structure] = weakref.ref(structure)\n\n        self.comments: List[str] = []\n\n    @property\n    def structure(self) -&gt; Structure:\n        \"\"\"Back reference to the parent structure\"\"\"\n        return self._structure()\n</code></pre>"},{"location":"reference/python/structure/#quokka.structure.StructureMember.structure","title":"<code>structure</code>  <code>property</code>","text":"<p>Back reference to the parent structure</p>"},{"location":"reference/python/structure/#quokka.structure.StructureMember.__init__","title":"<code>__init__(member, structure)</code>","text":"<p>Constructor</p> Source code in <code>quokka/structure.py</code> <pre><code>def __init__(\n    self,\n    member: \"quokka.pb.Quokka.Structure.Member\",\n    structure: Structure,\n) -&gt; None:\n    \"\"\"Constructor\"\"\"\n    self.name: str = member.name\n    self.type: DataType = DataType.from_proto(member.type)\n    self.size: int = member.size\n    self.value: Optional[int] = member.value if member.value != 0 else None\n    self._structure: weakref.ref[Structure] = weakref.ref(structure)\n\n    self.comments: List[str] = []\n</code></pre>"},{"location":"reference/python/types/","title":"types","text":"<p>Types used in Quokka</p>"},{"location":"reference/python/types/#quokka.types.AddressSize","title":"<code>AddressSize</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Address size</p> Source code in <code>quokka/types.py</code> <pre><code>class AddressSize(enum.Enum):\n    \"\"\"Address size\"\"\"\n\n    ADDRESS_64 = enum.auto()\n    ADDRESS_32 = enum.auto()\n    ADDRESS_16 = enum.auto()\n    ADDRESS_UNK = enum.auto()\n\n    @staticmethod\n    def from_proto(\n        address_size: \"quokka.pb.Quokka.AddressSizeValue\",\n    ) -&gt; \"AddressSize\":\n        \"\"\"Convert the protobuf value into this enumeration\"\"\"\n        mapping = {\n            quokka.pb.Quokka.ADDR_32: AddressSize.ADDRESS_32,\n            quokka.pb.Quokka.ADDR_64: AddressSize.ADDRESS_64,\n        }\n\n        return mapping.get(address_size, AddressSize.ADDRESS_UNK)\n</code></pre>"},{"location":"reference/python/types/#quokka.types.AddressSize.from_proto","title":"<code>from_proto(address_size)</code>  <code>staticmethod</code>","text":"<p>Convert the protobuf value into this enumeration</p> Source code in <code>quokka/types.py</code> <pre><code>@staticmethod\ndef from_proto(\n    address_size: \"quokka.pb.Quokka.AddressSizeValue\",\n) -&gt; \"AddressSize\":\n    \"\"\"Convert the protobuf value into this enumeration\"\"\"\n    mapping = {\n        quokka.pb.Quokka.ADDR_32: AddressSize.ADDRESS_32,\n        quokka.pb.Quokka.ADDR_64: AddressSize.ADDRESS_64,\n    }\n\n    return mapping.get(address_size, AddressSize.ADDRESS_UNK)\n</code></pre>"},{"location":"reference/python/types/#quokka.types.BlockType","title":"<code>BlockType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Block Type</p> Source code in <code>quokka/types.py</code> <pre><code>class BlockType(enum.Enum):\n    \"\"\"Block Type\"\"\"\n\n    NORMAL = enum.auto()\n    INDJUMP = enum.auto()\n    RET = enum.auto()\n    NORET = enum.auto()\n    CNDRET = enum.auto()\n    ENORET = enum.auto()\n    EXTERN = enum.auto()\n    ERROR = enum.auto()\n    FAKE = enum.auto()\n\n    @staticmethod\n    def from_proto(\n        block_type: \"quokka.pb.Quokka.FunctionChunk.Block.BlockTypeValue\",\n    ) -&gt; BlockType:\n        \"\"\"Convert the protobuf value into this enumeration\"\"\"\n        mapping = {\n            quokka.pb.Quokka.FunctionChunk.Block.BLOCK_TYPE_NORMAL: BlockType.NORMAL,\n            quokka.pb.Quokka.FunctionChunk.Block.BLOCK_TYPE_INDJUMP: BlockType.INDJUMP,\n            quokka.pb.Quokka.FunctionChunk.Block.BLOCK_TYPE_RET: BlockType.RET,\n            quokka.pb.Quokka.FunctionChunk.Block.BLOCK_TYPE_NORET: BlockType.NORET,\n            quokka.pb.Quokka.FunctionChunk.Block.BLOCK_TYPE_CNDRET: BlockType.CNDRET,\n            quokka.pb.Quokka.FunctionChunk.Block.BLOCK_TYPE_ENORET: BlockType.ENORET,\n            quokka.pb.Quokka.FunctionChunk.Block.BLOCK_TYPE_EXTERN: BlockType.EXTERN,\n            quokka.pb.Quokka.FunctionChunk.Block.BLOCK_TYPE_ERROR: BlockType.ERROR,\n            quokka.pb.Quokka.FunctionChunk.Block.BLOCK_TYPE_FAKE: BlockType.FAKE,\n        }\n\n        return mapping.get(block_type, BlockType.FAKE)\n</code></pre>"},{"location":"reference/python/types/#quokka.types.BlockType.from_proto","title":"<code>from_proto(block_type)</code>  <code>staticmethod</code>","text":"<p>Convert the protobuf value into this enumeration</p> Source code in <code>quokka/types.py</code> <pre><code>@staticmethod\ndef from_proto(\n    block_type: \"quokka.pb.Quokka.FunctionChunk.Block.BlockTypeValue\",\n) -&gt; BlockType:\n    \"\"\"Convert the protobuf value into this enumeration\"\"\"\n    mapping = {\n        quokka.pb.Quokka.FunctionChunk.Block.BLOCK_TYPE_NORMAL: BlockType.NORMAL,\n        quokka.pb.Quokka.FunctionChunk.Block.BLOCK_TYPE_INDJUMP: BlockType.INDJUMP,\n        quokka.pb.Quokka.FunctionChunk.Block.BLOCK_TYPE_RET: BlockType.RET,\n        quokka.pb.Quokka.FunctionChunk.Block.BLOCK_TYPE_NORET: BlockType.NORET,\n        quokka.pb.Quokka.FunctionChunk.Block.BLOCK_TYPE_CNDRET: BlockType.CNDRET,\n        quokka.pb.Quokka.FunctionChunk.Block.BLOCK_TYPE_ENORET: BlockType.ENORET,\n        quokka.pb.Quokka.FunctionChunk.Block.BLOCK_TYPE_EXTERN: BlockType.EXTERN,\n        quokka.pb.Quokka.FunctionChunk.Block.BLOCK_TYPE_ERROR: BlockType.ERROR,\n        quokka.pb.Quokka.FunctionChunk.Block.BLOCK_TYPE_FAKE: BlockType.FAKE,\n    }\n\n    return mapping.get(block_type, BlockType.FAKE)\n</code></pre>"},{"location":"reference/python/types/#quokka.types.DataType","title":"<code>DataType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Data Type</p> Source code in <code>quokka/types.py</code> <pre><code>class DataType(enum.Enum):\n    \"\"\"Data Type\"\"\"\n\n    UNKNOWN = enum.auto()\n    BYTE = enum.auto()\n    WORD = enum.auto()\n    DOUBLE_WORD = enum.auto()\n    QUAD_WORD = enum.auto()\n    OCTO_WORD = enum.auto()\n    FLOAT = enum.auto()\n    DOUBLE = enum.auto()\n    ASCII = enum.auto()\n    STRUCT = enum.auto()\n    ALIGN = enum.auto()\n    POINTER = enum.auto()\n\n    @staticmethod\n    def from_proto(data_type: \"quokka.pb.Quokka.DataTypeValue\") -&gt; \"DataType\":\n        \"\"\"Convert the protobuf value into this enumeration\"\"\"\n        mapping = {\n            quokka.pb.Quokka.TYPE_B: DataType.BYTE,\n            quokka.pb.Quokka.TYPE_W: DataType.WORD,\n            quokka.pb.Quokka.TYPE_DW: DataType.DOUBLE_WORD,\n            quokka.pb.Quokka.TYPE_QW: DataType.QUAD_WORD,\n            quokka.pb.Quokka.TYPE_OW: DataType.QUAD_WORD,\n            quokka.pb.Quokka.TYPE_FLOAT: DataType.FLOAT,\n            quokka.pb.Quokka.TYPE_DOUBLE: DataType.DOUBLE,\n            quokka.pb.Quokka.TYPE_ASCII: DataType.ASCII,\n            quokka.pb.Quokka.TYPE_STRUCT: DataType.STRUCT,\n            quokka.pb.Quokka.TYPE_ALIGN: DataType.ALIGN,\n            quokka.pb.Quokka.TYPE_POINTER: DataType.POINTER,\n        }\n\n        return mapping.get(data_type, DataType.UNKNOWN)\n</code></pre>"},{"location":"reference/python/types/#quokka.types.DataType.from_proto","title":"<code>from_proto(data_type)</code>  <code>staticmethod</code>","text":"<p>Convert the protobuf value into this enumeration</p> Source code in <code>quokka/types.py</code> <pre><code>@staticmethod\ndef from_proto(data_type: \"quokka.pb.Quokka.DataTypeValue\") -&gt; \"DataType\":\n    \"\"\"Convert the protobuf value into this enumeration\"\"\"\n    mapping = {\n        quokka.pb.Quokka.TYPE_B: DataType.BYTE,\n        quokka.pb.Quokka.TYPE_W: DataType.WORD,\n        quokka.pb.Quokka.TYPE_DW: DataType.DOUBLE_WORD,\n        quokka.pb.Quokka.TYPE_QW: DataType.QUAD_WORD,\n        quokka.pb.Quokka.TYPE_OW: DataType.QUAD_WORD,\n        quokka.pb.Quokka.TYPE_FLOAT: DataType.FLOAT,\n        quokka.pb.Quokka.TYPE_DOUBLE: DataType.DOUBLE,\n        quokka.pb.Quokka.TYPE_ASCII: DataType.ASCII,\n        quokka.pb.Quokka.TYPE_STRUCT: DataType.STRUCT,\n        quokka.pb.Quokka.TYPE_ALIGN: DataType.ALIGN,\n        quokka.pb.Quokka.TYPE_POINTER: DataType.POINTER,\n    }\n\n    return mapping.get(data_type, DataType.UNKNOWN)\n</code></pre>"},{"location":"reference/python/types/#quokka.types.EdgeType","title":"<code>EdgeType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Edge Type</p> Source code in <code>quokka/types.py</code> <pre><code>class EdgeType(enum.Enum):\n    \"\"\"Edge Type\"\"\"\n\n    UNCONDITIONAL = enum.auto()\n    TRUE = enum.auto()\n    FALSE = enum.auto()\n    SWITCH = enum.auto()\n\n    @staticmethod\n    def from_proto(\n        edge_type: \"quokka.pb.Quokka.Edge.EdgeTypeValue\",\n    ) -&gt; \"EdgeType\":\n        \"\"\"Convert the protobuf value into this enumeration\"\"\"\n        mapping = {\n            quokka.pb.Quokka.Edge.TYPE_UNCONDITIONAL: EdgeType.UNCONDITIONAL,\n            quokka.pb.Quokka.Edge.TYPE_TRUE: EdgeType.TRUE,\n            quokka.pb.Quokka.Edge.TYPE_FALSE: EdgeType.FALSE,\n            quokka.pb.Quokka.Edge.TYPE_SWITCH: EdgeType.SWITCH,\n        }\n\n        edge = mapping.get(edge_type)\n        if edge is not None:\n            return edge\n\n        raise ValueError(\"Unable to decode Edge Type\")\n</code></pre>"},{"location":"reference/python/types/#quokka.types.EdgeType.from_proto","title":"<code>from_proto(edge_type)</code>  <code>staticmethod</code>","text":"<p>Convert the protobuf value into this enumeration</p> Source code in <code>quokka/types.py</code> <pre><code>@staticmethod\ndef from_proto(\n    edge_type: \"quokka.pb.Quokka.Edge.EdgeTypeValue\",\n) -&gt; \"EdgeType\":\n    \"\"\"Convert the protobuf value into this enumeration\"\"\"\n    mapping = {\n        quokka.pb.Quokka.Edge.TYPE_UNCONDITIONAL: EdgeType.UNCONDITIONAL,\n        quokka.pb.Quokka.Edge.TYPE_TRUE: EdgeType.TRUE,\n        quokka.pb.Quokka.Edge.TYPE_FALSE: EdgeType.FALSE,\n        quokka.pb.Quokka.Edge.TYPE_SWITCH: EdgeType.SWITCH,\n    }\n\n    edge = mapping.get(edge_type)\n    if edge is not None:\n        return edge\n\n    raise ValueError(\"Unable to decode Edge Type\")\n</code></pre>"},{"location":"reference/python/types/#quokka.types.Endianness","title":"<code>Endianness</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Endianness of the program</p> <p>LE: Little endian (least significant bit first) BE: Big endian (most significant bit first)</p> TODO <p>See how we can support mixed endianness</p> Source code in <code>quokka/types.py</code> <pre><code>class Endianness(enum.Enum):\n    \"\"\"Endianness of the program\n\n    LE: Little endian (least significant bit first)\n    BE: Big endian (most significant bit first)\n\n    TODO:\n        See how we can support mixed endianness\n    \"\"\"\n\n    LITTLE_ENDIAN = enum.auto()\n    BIG_ENDIAN = enum.auto()\n    UNKNOWN = enum.auto()\n\n    @staticmethod\n    def from_proto(\n        endianness: \"quokka.pb.Quokka.Meta.EndianessValue\",\n    ) -&gt; Endianness:\n        \"\"\"Convert the protobuf value into this enumeration\"\"\"\n        mapping = {\n            quokka.pb.Quokka.Meta.END_BE: Endianness.BIG_ENDIAN,\n            quokka.pb.Quokka.Meta.END_LE: Endianness.LITTLE_ENDIAN,\n        }\n\n        return mapping.get(endianness, Endianness.UNKNOWN)\n</code></pre>"},{"location":"reference/python/types/#quokka.types.Endianness.from_proto","title":"<code>from_proto(endianness)</code>  <code>staticmethod</code>","text":"<p>Convert the protobuf value into this enumeration</p> Source code in <code>quokka/types.py</code> <pre><code>@staticmethod\ndef from_proto(\n    endianness: \"quokka.pb.Quokka.Meta.EndianessValue\",\n) -&gt; Endianness:\n    \"\"\"Convert the protobuf value into this enumeration\"\"\"\n    mapping = {\n        quokka.pb.Quokka.Meta.END_BE: Endianness.BIG_ENDIAN,\n        quokka.pb.Quokka.Meta.END_LE: Endianness.LITTLE_ENDIAN,\n    }\n\n    return mapping.get(endianness, Endianness.UNKNOWN)\n</code></pre>"},{"location":"reference/python/types/#quokka.types.ExporterMode","title":"<code>ExporterMode</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Mode type</p> <p>The exporter mode controls the type of exported data.</p> Source code in <code>quokka/types.py</code> <pre><code>class ExporterMode(enum.IntEnum):\n    \"\"\"Mode type\n\n    The exporter mode controls the type of exported data.\n    \"\"\"\n\n    LIGHT = enum.auto()\n    FULL = enum.auto()\n    NORMAL = enum.auto()\n\n    @staticmethod\n    def from_proto(mode: \"quokka.pb.Quokka.ExporterMeta.ModeValue\") -&gt; \"ExporterMode\":\n        mapping = {\n            quokka.pb.Quokka.ExporterMeta.MODE_LIGHT: ExporterMode.LIGHT,\n            quokka.pb.Quokka.ExporterMeta.MODE_FULL: ExporterMode.FULL,\n        }\n\n        return mapping.get(mode, ExporterMode.NORMAL)\n</code></pre>"},{"location":"reference/python/types/#quokka.types.FunctionType","title":"<code>FunctionType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Function Type</p> Source code in <code>quokka/types.py</code> <pre><code>class FunctionType(enum.Enum):\n    \"\"\"Function Type\"\"\"\n\n    NORMAL = enum.auto()\n    IMPORTED = enum.auto()\n    LIBRARY = enum.auto()\n    THUNK = enum.auto()\n    EXTERN = enum.auto()\n    INVALID = enum.auto()\n\n    @staticmethod\n    def from_proto(\n        function_type: \"quokka.pb.Quokka.Function.FunctionTypeValue\",\n    ) -&gt; \"FunctionType\":\n        \"\"\"Convert the protobuf value into this enumeration\"\"\"\n        mapping = {\n            quokka.pb.Quokka.Function.TYPE_NORMAL: FunctionType.NORMAL,\n            quokka.pb.Quokka.Function.TYPE_IMPORTED: FunctionType.IMPORTED,\n            quokka.pb.Quokka.Function.TYPE_LIBRARY: FunctionType.LIBRARY,\n            quokka.pb.Quokka.Function.TYPE_THUNK: FunctionType.THUNK,\n        }\n\n        return mapping.get(function_type, FunctionType.INVALID)\n</code></pre>"},{"location":"reference/python/types/#quokka.types.FunctionType.from_proto","title":"<code>from_proto(function_type)</code>  <code>staticmethod</code>","text":"<p>Convert the protobuf value into this enumeration</p> Source code in <code>quokka/types.py</code> <pre><code>@staticmethod\ndef from_proto(\n    function_type: \"quokka.pb.Quokka.Function.FunctionTypeValue\",\n) -&gt; \"FunctionType\":\n    \"\"\"Convert the protobuf value into this enumeration\"\"\"\n    mapping = {\n        quokka.pb.Quokka.Function.TYPE_NORMAL: FunctionType.NORMAL,\n        quokka.pb.Quokka.Function.TYPE_IMPORTED: FunctionType.IMPORTED,\n        quokka.pb.Quokka.Function.TYPE_LIBRARY: FunctionType.LIBRARY,\n        quokka.pb.Quokka.Function.TYPE_THUNK: FunctionType.THUNK,\n    }\n\n    return mapping.get(function_type, FunctionType.INVALID)\n</code></pre>"},{"location":"reference/python/types/#quokka.types.ReferenceType","title":"<code>ReferenceType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Reference Type</p> Source code in <code>quokka/types.py</code> <pre><code>class ReferenceType(enum.Enum):\n    \"\"\"Reference Type\"\"\"\n\n    CALL = enum.auto()\n    DATA = enum.auto()\n    ENUM = enum.auto()\n    STRUC = enum.auto()\n    UNKNOWN = enum.auto()\n\n    @staticmethod\n    def from_proto(\n        reference_type: \"quokka.pb.Quokka.Reference.ReferenceTypeValue\",\n    ) -&gt; \"ReferenceType\":\n        \"\"\"Convert the protobuf value into this enumeration\"\"\"\n        mapping = {\n            quokka.pb.Quokka.Reference.REF_CALL: ReferenceType.CALL,\n            quokka.pb.Quokka.Reference.REF_DATA: ReferenceType.DATA,\n            quokka.pb.Quokka.Reference.REF_ENUM: ReferenceType.ENUM,\n            quokka.pb.Quokka.Reference.REF_STRUC: ReferenceType.STRUC,\n        }\n\n        return mapping.get(reference_type, ReferenceType.UNKNOWN)\n</code></pre>"},{"location":"reference/python/types/#quokka.types.ReferenceType.from_proto","title":"<code>from_proto(reference_type)</code>  <code>staticmethod</code>","text":"<p>Convert the protobuf value into this enumeration</p> Source code in <code>quokka/types.py</code> <pre><code>@staticmethod\ndef from_proto(\n    reference_type: \"quokka.pb.Quokka.Reference.ReferenceTypeValue\",\n) -&gt; \"ReferenceType\":\n    \"\"\"Convert the protobuf value into this enumeration\"\"\"\n    mapping = {\n        quokka.pb.Quokka.Reference.REF_CALL: ReferenceType.CALL,\n        quokka.pb.Quokka.Reference.REF_DATA: ReferenceType.DATA,\n        quokka.pb.Quokka.Reference.REF_ENUM: ReferenceType.ENUM,\n        quokka.pb.Quokka.Reference.REF_STRUC: ReferenceType.STRUC,\n    }\n\n    return mapping.get(reference_type, ReferenceType.UNKNOWN)\n</code></pre>"},{"location":"reference/python/types/#quokka.types.RegAccessMode","title":"<code>RegAccessMode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Register access mode</p> Source code in <code>quokka/types.py</code> <pre><code>class RegAccessMode(enum.Enum):\n    \"\"\"Register access mode\"\"\"\n\n    READ = enum.auto()\n    WRITE = enum.auto()\n    ANY = enum.auto()\n</code></pre>"},{"location":"reference/python/types/#quokka.types.SegmentType","title":"<code>SegmentType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Segment Type</p> Source code in <code>quokka/types.py</code> <pre><code>class SegmentType(enum.Enum):\n    \"\"\"Segment Type\"\"\"\n\n    UNKNOWN = enum.auto()\n    CODE = enum.auto()\n    DATA = enum.auto()\n    BSS = enum.auto()\n    NULL = enum.auto()\n    EXTERN = enum.auto()\n    NORMAL = enum.auto()\n    ABSOLUTE_SYMBOLS = enum.auto()\n\n    @staticmethod\n    def from_proto(\n        segment_type: \"quokka.pb.Quokka.Segment.TypeValue\",\n    ) -&gt; \"SegmentType\":\n        \"\"\"Convert the protobuf value into this enumeration\"\"\"\n        mapping = {\n            quokka.pb.Quokka.Segment.SEGMENT_CODE: SegmentType.CODE,\n            quokka.pb.Quokka.Segment.SEGMENT_DATA: SegmentType.DATA,\n            quokka.pb.Quokka.Segment.SEGMENT_BSS: SegmentType.BSS,\n            quokka.pb.Quokka.Segment.SEGMENT_NULL: SegmentType.NULL,\n            quokka.pb.Quokka.Segment.SEGMENT_NORMAL: SegmentType.NORMAL,\n            quokka.pb.Quokka.Segment.SEGMENT_EXTERN: SegmentType.EXTERN,\n            quokka.pb.Quokka.Segment.SEGMENT_ABSOLUTE_SYMBOLS: SegmentType.ABSOLUTE_SYMBOLS,\n        }\n\n        return mapping.get(segment_type, SegmentType.UNKNOWN)\n</code></pre>"},{"location":"reference/python/types/#quokka.types.SegmentType.from_proto","title":"<code>from_proto(segment_type)</code>  <code>staticmethod</code>","text":"<p>Convert the protobuf value into this enumeration</p> Source code in <code>quokka/types.py</code> <pre><code>@staticmethod\ndef from_proto(\n    segment_type: \"quokka.pb.Quokka.Segment.TypeValue\",\n) -&gt; \"SegmentType\":\n    \"\"\"Convert the protobuf value into this enumeration\"\"\"\n    mapping = {\n        quokka.pb.Quokka.Segment.SEGMENT_CODE: SegmentType.CODE,\n        quokka.pb.Quokka.Segment.SEGMENT_DATA: SegmentType.DATA,\n        quokka.pb.Quokka.Segment.SEGMENT_BSS: SegmentType.BSS,\n        quokka.pb.Quokka.Segment.SEGMENT_NULL: SegmentType.NULL,\n        quokka.pb.Quokka.Segment.SEGMENT_NORMAL: SegmentType.NORMAL,\n        quokka.pb.Quokka.Segment.SEGMENT_EXTERN: SegmentType.EXTERN,\n        quokka.pb.Quokka.Segment.SEGMENT_ABSOLUTE_SYMBOLS: SegmentType.ABSOLUTE_SYMBOLS,\n    }\n\n    return mapping.get(segment_type, SegmentType.UNKNOWN)\n</code></pre>"},{"location":"reference/python/types/#quokka.types.StructureType","title":"<code>StructureType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Structure Type</p> Source code in <code>quokka/types.py</code> <pre><code>class StructureType(enum.Enum):\n    \"\"\"Structure Type\"\"\"\n\n    STRUCT = enum.auto()\n    ENUM = enum.auto()\n    UNION = enum.auto()\n    UNKNOWN = enum.auto()\n\n    @staticmethod\n    def from_proto(\n        structure_type: \"quokka.pb.Quokka.Structure.StructureTypeValue\",\n    ) -&gt; \"StructureType\":\n        \"\"\"Convert the protobuf value into this enumeration\"\"\"\n        mapping = {\n            quokka.pb.Quokka.Structure.TYPE_STRUCT: StructureType.STRUCT,\n            quokka.pb.Quokka.Structure.TYPE_ENUM: StructureType.ENUM,\n            quokka.pb.Quokka.Structure.TYPE_UNION: StructureType.UNION,\n        }\n\n        return mapping.get(structure_type, StructureType.UNKNOWN)\n</code></pre>"},{"location":"reference/python/types/#quokka.types.StructureType.from_proto","title":"<code>from_proto(structure_type)</code>  <code>staticmethod</code>","text":"<p>Convert the protobuf value into this enumeration</p> Source code in <code>quokka/types.py</code> <pre><code>@staticmethod\ndef from_proto(\n    structure_type: \"quokka.pb.Quokka.Structure.StructureTypeValue\",\n) -&gt; \"StructureType\":\n    \"\"\"Convert the protobuf value into this enumeration\"\"\"\n    mapping = {\n        quokka.pb.Quokka.Structure.TYPE_STRUCT: StructureType.STRUCT,\n        quokka.pb.Quokka.Structure.TYPE_ENUM: StructureType.ENUM,\n        quokka.pb.Quokka.Structure.TYPE_UNION: StructureType.UNION,\n    }\n\n    return mapping.get(structure_type, StructureType.UNKNOWN)\n</code></pre>"},{"location":"reference/python/utils/","title":"utils","text":"<p>Utilities functions</p>"},{"location":"reference/python/utils/#quokka.utils.check_hash","title":"<code>check_hash(hash_proto, file_path)</code>","text":"<p>Check if the hash is valid</p> <p>This method computes the appropriate hash based on what is available in the export file and compare them.</p> <p>Parameters:</p> Name Type Description Default <code>hash_proto</code> <code>Hash</code> <p>Protobuf message containing the hash</p> required <code>file_path</code> <code>Path</code> <p>Path to the binary</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Boolean for success</p> Source code in <code>quokka/utils.py</code> <pre><code>def check_hash(hash_proto: quokka.pb.Quokka.Meta.Hash, file_path: pathlib.Path) -&gt; bool:\n    \"\"\"Check if the hash is valid\n\n    This method computes the appropriate hash based on what is available in the export\n    file and compare them.\n\n    Arguments:\n        hash_proto: Protobuf message containing the hash\n        file_path: Path to the binary\n\n    Returns:\n        Boolean for success\n    \"\"\"\n    hash_methods = {\n        quokka.pb.Quokka.Meta.Hash.HASH_MD5: md5_file,\n        quokka.pb.Quokka.Meta.Hash.HASH_SHA256: sha256_file,\n    }\n\n    hash_method = hash_methods.get(hash_proto.hash_type)\n    if hash_method is None:\n        logger.info(\"Failed to verify hash for file because no hash was provided.\")\n        return True\n\n    file_hash = hash_method(file_path)\n    return file_hash == hash_proto.hash_value\n</code></pre>"},{"location":"reference/python/utils/#quokka.utils.convert_address_size","title":"<code>convert_address_size(proto_address_size)</code>","text":"<p>Convert the proto address size to an int value</p> <p>Parameters:</p> Name Type Description Default <code>proto_address_size</code> <code>'quokka.pb.Quokka.AddressSizeValue'</code> <p>Protobuf field</p> required <p>Returns:</p> Type Description <code>int</code> <p>An integer value</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>When the address size is not known</p> Source code in <code>quokka/utils.py</code> <pre><code>def convert_address_size(\n    proto_address_size: \"quokka.pb.Quokka.AddressSizeValue\",\n) -&gt; int:\n    \"\"\"Convert the proto address size to an int value\n\n    Arguments:\n        proto_address_size: Protobuf field\n\n    Returns:\n        An integer value\n\n    Raises:\n        ValueError: When the address size is not known\n    \"\"\"\n    if proto_address_size == quokka.pb.Quokka.ADDR_32:\n        return 32\n    if proto_address_size == quokka.pb.Quokka.ADDR_64:\n        return 64\n\n    raise ValueError(\"Address size not known\")\n</code></pre>"},{"location":"reference/python/utils/#quokka.utils.find_register_access","title":"<code>find_register_access(register, access_mode, instructions)</code>","text":"<p>Traverse the list of instructions searching for the first one that access the specified register with the required access mode.</p> <p>Parameters:</p> Name Type Description Default <code>reg</code> <p>The identifier of the register we are targeting, that can either be the capstone register ID (ex: capstone.x86_const.X86_REG_EAX) or the register name (ex: \"eax\")</p> required <code>access_mode</code> <code>RegAccessMode</code> <p>The access mode to the register (read or write)</p> required <code>instructions</code> <code>Iterable[Instruction]</code> <p>An iterable of instructions to analyze</p> required <p>Returns:</p> Type Description <code>Instruction | None</code> <p>The first instruction that access the register in the specified mode.</p> <code>Instruction | None</code> <p>Return None if no such instruction is found.</p> Source code in <code>quokka/utils.py</code> <pre><code>def find_register_access(\n    register: int | str, access_mode: RegAccessMode, instructions: Iterable[Instruction]\n) -&gt; Instruction | None:\n    \"\"\"Traverse the list of instructions searching for the first one that access\n    the specified register with the required access mode.\n\n    Arguments:\n        reg: The identifier of the register we are targeting, that can either be\n            the capstone register ID (ex: capstone.x86_const.X86_REG_EAX) or the\n            register name (ex: \"eax\")\n        access_mode: The access mode to the register (read or write)\n        instructions: An iterable of instructions to analyze\n\n    Returns:\n        The first instruction that access the register in the specified mode.\n        Return None if no such instruction is found.\n    \"\"\"\n\n    for instr in instructions:\n        # Retrieve the list of all registers read or modified by the instruction using capstone\n        regs_read, regs_write = instr.cs_inst.regs_access()\n\n        # Remap registers to the correct type\n        if isinstance(register, str):\n            register = register.lower()\n            regs_read = [instr.cs_inst.reg_name(r) for r in regs_read]\n            regs_write = [instr.cs_inst.reg_name(r) for r in regs_write]\n\n        # Check if it is accessing the target register in the correct mode\n        if (\n            register in regs_write\n            and (access_mode == RegAccessMode.WRITE or access_mode == RegAccessMode.ANY)\n        ) or (\n            register in regs_read\n            and (access_mode == RegAccessMode.READ or access_mode == RegAccessMode.ANY)\n        ):\n            return instr\n\n    return None\n</code></pre>"},{"location":"reference/python/utils/#quokka.utils.get_arch","title":"<code>get_arch(isa, address_size, is_thumb=False)</code>  <code>cached</code>","text":"<p>Convert an isa to an arch.</p> <p>Parameters:</p> Name Type Description Default <code>isa</code> <code>ArchEnum</code> <p>Instruction set</p> required <code>address_size</code> <code>int</code> <p>Address size</p> required <code>is_thumb</code> <code>bool</code> <p>Is it thumb mode?</p> <code>False</code> <p>Returns:</p> Type Description <code>Type['QuokkaArch']</code> <p>A QuokkaArch</p> Source code in <code>quokka/utils.py</code> <pre><code>@functools.lru_cache(maxsize=2, typed=True)\ndef get_arch(\n    isa: ArchEnum, address_size: int, is_thumb: bool = False\n) -&gt; Type[\"QuokkaArch\"]:\n    \"\"\"Convert an isa to an arch.\n\n    Arguments:\n        isa: Instruction set\n        address_size: Address size\n        is_thumb: Is it thumb mode?\n\n    Returns:\n        A QuokkaArch\n    \"\"\"\n    mapping = {\n        ArchEnum.ARM: {\n            32: ArchARM,\n            64: ArchARM64,\n        },\n        ArchEnum.X86: {\n            32: ArchX86,\n            64: ArchX64,\n        },\n        ArchEnum.MIPS: {\n            32: ArchMIPS,\n            64: ArchMIPS64,\n        },\n        ArchEnum.PPC: {\n            32: ArchPPC,\n            64: ArchPPC64,\n        },\n    }\n\n    platform_arch = mapping.get(isa)\n    if platform_arch is None:\n        return QuokkaArch\n\n    arch = platform_arch.get(address_size, QuokkaArch)\n\n    if arch == ArchARM and is_thumb:\n        arch = ArchARMThumb\n\n    return arch\n</code></pre>"},{"location":"reference/python/utils/#quokka.utils.get_isa","title":"<code>get_isa(proto_isa)</code>","text":"<p>Convert a proto isa to an architecture</p> Source code in <code>quokka/utils.py</code> <pre><code>def get_isa(\n    proto_isa: \"quokka.pb.Quokka.Meta.ISAValue\",\n) -&gt; ArchEnum:\n    \"\"\"Convert a proto isa to an architecture\"\"\"\n    mapping = {\n        quokka.pb.Quokka.Meta.PROC_INTEL: ArchEnum.X86,\n        quokka.pb.Quokka.Meta.PROC_ARM: ArchEnum.ARM,\n        quokka.pb.Quokka.Meta.PROC_PPC: ArchEnum.PPC,\n        quokka.pb.Quokka.Meta.PROC_MIPS: ArchEnum.MIPS,\n    }\n\n    return mapping.get(proto_isa, ArchEnum.UNKNOWN)\n</code></pre>"},{"location":"reference/python/utils/#quokka.utils.md5_file","title":"<code>md5_file(file_path)</code>","text":"<p>Compute the MD5 of a file</p> Source code in <code>quokka/utils.py</code> <pre><code>def md5_file(file_path: pathlib.Path) -&gt; str:\n    \"\"\"Compute the MD5 of a file\"\"\"\n    md5 = hashlib.md5()\n    with open(file_path.as_posix(), \"rb\") as fd:\n        for byte in iter(lambda: fd.read(65535), b\"\"):\n            md5.update(byte)\n\n    return md5.hexdigest()\n</code></pre>"},{"location":"reference/python/utils/#quokka.utils.parse_version","title":"<code>parse_version(version)</code>","text":"<p>Parse the version returning a tuple with the major, minor and patch</p> Source code in <code>quokka/utils.py</code> <pre><code>def parse_version(version: str) -&gt; tuple[int, int, int]:\n    \"\"\"Parse the version returning a tuple with the major, minor and patch\"\"\"\n\n    parsed = tuple(map(int, version.split(\".\")))\n    if len(parsed) != 3:\n        raise ValueError(\n            f\"Version {version} doesn't respect the format MAJOR.MINOR.PATCH\"\n        )\n\n    return parsed\n</code></pre>"},{"location":"reference/python/utils/#quokka.utils.sha256_file","title":"<code>sha256_file(file_path)</code>","text":"<p>Compute the SHA-256 of a file</p> Source code in <code>quokka/utils.py</code> <pre><code>def sha256_file(file_path: pathlib.Path) -&gt; str:\n    \"\"\"Compute the SHA-256 of a file\"\"\"\n    sha = hashlib.sha256()\n    with open(file_path.as_posix(), \"rb\") as fd:\n        for byte in iter(lambda: fd.read(65535), b\"\"):\n            sha.update(byte)\n\n    return sha.hexdigest()\n</code></pre>"},{"location":"reference/python/version/","title":"version","text":""},{"location":"reference/python/analysis/arch/","title":"arch","text":"<p>Architecture module</p>"},{"location":"reference/python/analysis/arch/#quokka.analysis.arch.ArchARM","title":"<code>ArchARM</code>","text":"<p>               Bases: <code>QuokkaArch</code></p> <p>ArchARM definition</p> Source code in <code>quokka/analysis/arch.py</code> <pre><code>class ArchARM(QuokkaArch):  # type: ignore\n    \"\"\"ArchARM definition\"\"\"\n\n    (\n        cc,\n        cpsflag,\n        cpsmode,\n        grps,\n        insts,\n        mb,\n        op,\n        regs,\n        setend,\n        sft,\n        sysreg,\n        vd,\n    ) = make_enums(\n        capstone_module=capstone.arm_const,\n        items=[\n            \"CC\",\n            \"CPSFLAG\",\n            \"CPSMODE\",\n            \"GRP\",\n            \"INS\",\n            \"MB\",\n            \"OP\",\n            \"REG\",\n            \"SETEND\",\n            \"SFT\",\n            \"SYSREG\",\n            \"VECTORDATA\",\n        ],\n        blacklist=[\"ENDING\", \"R13\", \"R14\", \"R15\", \"R9\", \"R10\", \"R11\", \"R12\"],\n        flags_enums=[\"SYSREG\"],\n    )\n\n    address_size = 32\n    compared_mnemonics = [\n        insts.CBNZ,\n        insts.CMP,\n        insts.CBZ,\n        insts.CMN,\n    ]\n\n    frame_pointer = regs.FP\n    stack_pointer = regs.SP\n    inst_pointer = regs.PC\n</code></pre>"},{"location":"reference/python/analysis/arch/#quokka.analysis.arch.ArchARM64","title":"<code>ArchARM64</code>","text":"<p>               Bases: <code>QuokkaArch</code></p> <p>Arch Arm64 definition</p> Source code in <code>quokka/analysis/arch.py</code> <pre><code>class ArchARM64(QuokkaArch):  # type: ignore\n    \"\"\"Arch Arm64 definition\"\"\"\n\n    (\n        at,\n        barrier,\n        cc,\n        dc,\n        ext,\n        grp,\n        ic,\n        insts,\n        op,\n        prfm,\n        pstate,\n        regs,\n        sft,\n        sysreg,\n        tlbi,\n        vas,\n        vess,\n    ) = make_enums(\n        capstone_module=capstone.arm64_const,\n        items=[\n            \"AT\",\n            \"BARRIER\",\n            \"CC\",\n            \"DC\",\n            \"EXT\",\n            \"GRP\",\n            \"IC\",\n            \"INS\",\n            \"OP\",\n            \"PRFM\",\n            \"PSTATE\",\n            \"REG\",\n            \"SFT\",\n            \"SYSREG\",\n            \"TLBI\",\n            \"VAS\",\n            \"VESS\",\n        ],\n        blacklist=[\"ENDING\", \"X16\", \"X17\", \"X29\", \"X30\"],\n        flags_enums=[],\n    )\n\n    address_size = 64\n    compared_mnemonics = [\n        insts.CBZ,\n        insts.CBNZ,\n        insts.CMP,\n        insts.CCMN,\n        insts.CCMP,\n        insts.CMN,\n        insts.TBZ,\n        insts.TBNZ,\n    ]\n\n    frame_pointer = regs.FP\n    stack_pointer = regs.SP  # TODO(dm)!\n    inst_pointer = regs.X28\n</code></pre>"},{"location":"reference/python/analysis/arch/#quokka.analysis.arch.ArchARMThumb","title":"<code>ArchARMThumb</code>","text":"<p>               Bases: <code>ArchARM</code></p> <p>Arch Arm Thumb definition</p> Source code in <code>quokka/analysis/arch.py</code> <pre><code>class ArchARMThumb(ArchARM):  # type: ignore\n    \"\"\"Arch Arm Thumb definition\"\"\"\n\n    thumb: bool = True\n</code></pre>"},{"location":"reference/python/analysis/arch/#quokka.analysis.arch.ArchEnum","title":"<code>ArchEnum</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum identifying various architectures. The integer values are based on capstone enum.</p> Source code in <code>quokka/analysis/arch.py</code> <pre><code>class ArchEnum(IntEnum):\n    \"\"\"\n    Enum identifying various architectures. The integer\n    values are based on capstone enum.\n    \"\"\"\n\n    UNKNOWN = capstone.CS_ARCH_ALL\n    ARM = capstone.CS_ARCH_ARM\n    ARM64 = capstone.CS_ARCH_ARM64\n    EVM = capstone.CS_ARCH_EVM\n    M680X = capstone.CS_ARCH_M680X\n    M68K = capstone.CS_ARCH_M68K\n    MIPS = capstone.CS_ARCH_MIPS\n    PPC = capstone.CS_ARCH_PPC\n    SPARC = capstone.CS_ARCH_SPARC\n    SYSZ = capstone.CS_ARCH_SYSZ\n    TMS320C64X = capstone.CS_ARCH_TMS320C64X\n    X86 = capstone.CS_ARCH_X86\n    XCORE = capstone.CS_ARCH_XCORE\n</code></pre>"},{"location":"reference/python/analysis/arch/#quokka.analysis.arch.ArchMIPS","title":"<code>ArchMIPS</code>","text":"<p>               Bases: <code>QuokkaArch</code></p> <p>Arch MIPS definition</p> Source code in <code>quokka/analysis/arch.py</code> <pre><code>class ArchMIPS(QuokkaArch):  # type: ignore\n    \"\"\"Arch MIPS definition\"\"\"\n\n    (\n        grps,\n        insts,\n        op,\n        regs,\n    ) = make_enums(\n        capstone_module=capstone.mips_const,\n        items=[\n            \"GRP\",\n            \"INS\",\n            \"OP\",\n            \"REG\",\n        ],\n        blacklist=[\"ENDING\", \"INVALID\"],\n        flags_enums=[],\n    )\n\n    compared_mnemonics = [\n        insts.CMP,\n        insts.CMPI,\n        insts.CMPU,\n        insts.CMPGU,\n        insts.CMPGDU,\n    ]\n\n    address_size = 32\n\n    frame_pointer = regs.FP  # R30\n    stack_pointer = regs.SP  # R29\n    inst_pointer = regs.PC   # REG_PC\n</code></pre>"},{"location":"reference/python/analysis/arch/#quokka.analysis.arch.ArchMIPS64","title":"<code>ArchMIPS64</code>","text":"<p>               Bases: <code>ArchMIPS</code></p> <p>Arch MIPS64 definition</p> Source code in <code>quokka/analysis/arch.py</code> <pre><code>class ArchMIPS64(ArchMIPS):  # type: ignore\n    \"\"\"Arch MIPS64 definition\"\"\"\n\n    address_size = 64\n</code></pre>"},{"location":"reference/python/analysis/arch/#quokka.analysis.arch.ArchPPC","title":"<code>ArchPPC</code>","text":"<p>               Bases: <code>QuokkaArch</code></p> <p>Arch PPC definition</p> Source code in <code>quokka/analysis/arch.py</code> <pre><code>class ArchPPC(QuokkaArch):  # type: ignore\n    \"\"\"Arch PPC definition\"\"\"\n\n    (\n        bc,\n        bh,\n        grps,\n        insts,\n        op,\n        regs,\n    ) = make_enums(\n        capstone_module=capstone.ppc_const,\n        items=[\n            \"BC\",\n            \"BH\",\n            \"GRP\",\n            \"INS\",\n            \"OP\",\n            \"REG\",\n        ],\n        blacklist=[\"ENDING\", \"INVALID\"],\n        flags_enums=[],\n    )\n\n    compared_mnemonics = [\n        insts.CMPB,\n        insts.CMPD,\n        insts.CMPDI,\n        insts.CMPLD,\n        insts.CMPLW,\n        insts.CMPW,\n        insts.CMPWI,\n    ]\n\n    address_size = 32\n\n    frame_pointer = regs.R1  #\n    stack_pointer = regs.R1  # GPR1\n    inst_pointer = regs.CTR\n</code></pre>"},{"location":"reference/python/analysis/arch/#quokka.analysis.arch.ArchPPC64","title":"<code>ArchPPC64</code>","text":"<p>               Bases: <code>ArchPPC</code></p> <p>Arch PPC64 definition</p> Source code in <code>quokka/analysis/arch.py</code> <pre><code>class ArchPPC64(ArchPPC):  # type: ignore\n    \"\"\"Arch PPC64 definition\"\"\"\n\n    address_size = 64\n</code></pre>"},{"location":"reference/python/analysis/arch/#quokka.analysis.arch.ArchX64","title":"<code>ArchX64</code>","text":"<p>               Bases: <code>ArchX86</code></p> <p>Arch X64 definition</p> Source code in <code>quokka/analysis/arch.py</code> <pre><code>class ArchX64(ArchX86):  # type: ignore\n    \"\"\"Arch X64 definition\"\"\"\n\n    address_size = 64\n\n    frame_pointer = ArchX86.regs.RBP\n    stack_pointer = ArchX86.regs.RSP\n    inst_pointer = ArchX86.regs.RIP\n</code></pre>"},{"location":"reference/python/analysis/arch/#quokka.analysis.arch.ArchX86","title":"<code>ArchX86</code>","text":"<p>               Bases: <code>QuokkaArch</code></p> <p>Arch X86 definition</p> Source code in <code>quokka/analysis/arch.py</code> <pre><code>class ArchX86(QuokkaArch):  # type: ignore\n    \"\"\"Arch X86 definition\"\"\"\n\n    address_size = 32\n\n    regs, insts, groups, prefixes, optypes, _flags_state = make_enums(\n        capstone_module=capstone.x86_const,\n        items=[\"REG\", \"INS\", \"GRP\", \"PREFIX\", \"OP\", \"EFLAGS\"],\n        blacklist=[\"ENDING\"],\n        flags_enums=[\"EFLAGS\"],\n    )\n\n    compared_mnemonics = [insts.CMP, insts.TEST]\n\n    frame_pointer = regs.EBP\n    stack_pointer = regs.ESP\n    inst_pointer = regs.EIP\n</code></pre>"},{"location":"reference/python/analysis/arch/#quokka.analysis.arch.QuokkaArch","title":"<code>QuokkaArch</code>","text":"<p>Base class for a QuokkaArch</p> Source code in <code>quokka/analysis/arch.py</code> <pre><code>class QuokkaArch:\n    \"\"\"Base class for a QuokkaArch\"\"\"\n\n    address_size: int\n    compared_mnemonics: List[str]\n    stack_pointer: RegType\n    inst_pointer: RegType\n</code></pre>"},{"location":"reference/python/analysis/arch/#quokka.analysis.arch.make_enums","title":"<code>make_enums(capstone_module, items, blacklist, flags_enums)</code>","text":"<p>Make enums from capstone module</p> <p>Dynamically generate enums from capstone constants</p> <p>Parameters:</p> Name Type Description Default <code>capstone_module</code> <code>ModuleType</code> <p>Capstone module</p> required <code>items</code> <code>List[str]</code> <p>Name of enums</p> required <code>blacklist</code> <code>List[str]</code> <p>Fields to not consider</p> required <code>flags_enums</code> <code>List[str]</code> <p>List of flag enums</p> required <p>Returns:</p> Type Description <code>List</code> <p>A list of IntEnum/IntFlag</p> Source code in <code>quokka/analysis/arch.py</code> <pre><code>def make_enums(\n    capstone_module: ModuleType, items: List[str], blacklist: List[str], flags_enums: List[str]\n) -&gt; List:\n    \"\"\"Make enums from capstone module\n\n    Dynamically generate enums from capstone constants\n\n    Arguments:\n        capstone_module: Capstone module\n        items: Name of enums\n        blacklist: Fields to not consider\n        flags_enums: List of flag enums\n\n    Returns:\n        A list of IntEnum/IntFlag\n    \"\"\"\n    data = collections.defaultdict(dict)\n    for key, val in getattr(capstone_module, \"__dict__\").items():\n        _, cat, name = key.split(\"_\", maxsplit=2)\n        if name not in blacklist:\n            name = \"_\" + name if \"0\" &lt;= name[0] &lt;= \"9\" else name\n            data[cat][name] = val\n\n    return [\n        IntEnum(x, names=data[x], module=__name__)\n        if x not in flags_enums\n        else IntFlag(x, names=data[x], module=__name__)\n        for x in items\n        if x\n    ]\n</code></pre>"},{"location":"reference/python/analysis/calling_convention/","title":"calling_convention","text":"<p>Calling conventions</p>"},{"location":"reference/python/analysis/calling_convention/#quokka.analysis.calling_convention.ARM64CC","title":"<code>ARM64CC</code>","text":"<p>               Bases: <code>CallingConvention</code></p> <p>AAPCS calling convention for Aarch64</p> Source code in <code>quokka/analysis/calling_convention.py</code> <pre><code>class ARM64CC(CallingConvention):\n    \"\"\"AAPCS calling convention for Aarch64\"\"\"\n\n    name = \"aapcs\"\n    argument_registers = [\n        ArchARM64.regs.X0,\n        ArchARM64.regs.X1,\n        ArchARM64.regs.X2,\n        ArchARM64.regs.X3,\n        ArchARM64.regs.X4,\n        ArchARM64.regs.X5,\n        ArchARM64.regs.X6,\n        ArchARM64.regs.X7,\n    ]\n\n    floating_point_registers: List[RegType] = []  # TODO\n    caller_saved_registers: List[RegType] = []\n    return_value = ArchARM64.regs.X0\n</code></pre>"},{"location":"reference/python/analysis/calling_convention/#quokka.analysis.calling_convention.ARMCC","title":"<code>ARMCC</code>","text":"<p>               Bases: <code>CallingConvention</code></p> <p>AAPCS calling convention for ARM</p> Source code in <code>quokka/analysis/calling_convention.py</code> <pre><code>class ARMCC(CallingConvention):\n    \"\"\"AAPCS calling convention for ARM\"\"\"\n\n    name = \"aapcs\"\n    argument_registers = [\n        ArchARM.regs.R0,\n        ArchARM.regs.R1,\n        ArchARM.regs.R2,\n        ArchARM.regs.R3,\n    ]\n    floating_point_registers: List[RegType] = []  # TODO\n    caller_saved_registers: List[RegType] = []\n    return_value = ArchARM.regs.R0\n</code></pre>"},{"location":"reference/python/analysis/calling_convention/#quokka.analysis.calling_convention.CCdecl","title":"<code>CCdecl</code>","text":"<p>               Bases: <code>CallingConvention</code></p> <p>Cdecl calling convention</p> Source code in <code>quokka/analysis/calling_convention.py</code> <pre><code>class CCdecl(CallingConvention):\n    \"\"\"Cdecl calling convention\"\"\"\n\n    name = \"cdecl\"\n    argument_registers: List[RegType] = []  # All arguments are on the stack\n    floating_point_registers: List[RegType] = []  # Same\n    caller_saved_registers = [\n        ArchX86.regs.EAX,\n        ArchX86.regs.ECX,\n        ArchX86.regs.EDX,\n    ]\n\n    return_value = ArchX86.regs.EAX\n    overflow_return = ArchX86.regs.EDX\n</code></pre>"},{"location":"reference/python/analysis/calling_convention/#quokka.analysis.calling_convention.CallingConvention","title":"<code>CallingConvention</code>","text":"<p>Base class for a calling convention</p> Source code in <code>quokka/analysis/calling_convention.py</code> <pre><code>class CallingConvention:\n    \"\"\"Base class for a calling convention\"\"\"\n\n    name: str\n    argument_registers: List[RegType]\n    floating_point_registers: List[RegType]\n    caller_saved_registers: List[RegType]\n    callee_saved: bool = False\n\n    return_value: RegType\n    overflow_return: RegType\n</code></pre>"},{"location":"reference/python/analysis/calling_convention/#quokka.analysis.calling_convention.Fastcall","title":"<code>Fastcall</code>","text":"<p>               Bases: <code>CallingConvention</code></p> <p>Fastcall calling convention</p> Source code in <code>quokka/analysis/calling_convention.py</code> <pre><code>class Fastcall(CallingConvention):\n    \"\"\"Fastcall calling convention\"\"\"\n\n    name = \"fastcall\"\n    argument_registers = [ArchX86.regs.ECX, ArchX86.regs.EDX]\n    floating_point_registers = [ArchX86.regs.ST0, ArchX86.regs.ST1]  # TODO(dm) check\n    caller_saved_registers = [\n        ArchX86.regs.EBX,\n        ArchX86.regs.EBX,\n        ArchX86.regs.ESI,\n        ArchX86.regs.EDI,\n    ]\n\n    return_value = ArchX86.regs.EAX\n    overflow_return = ArchX86.regs.EDX\n</code></pre>"},{"location":"reference/python/analysis/calling_convention/#quokka.analysis.calling_convention.MicrosoftAMD64","title":"<code>MicrosoftAMD64</code>","text":"<p>               Bases: <code>CallingConvention</code></p> <p>Microsoft 64 calling convention</p> Source code in <code>quokka/analysis/calling_convention.py</code> <pre><code>class MicrosoftAMD64(CallingConvention):\n    \"\"\"Microsoft 64 calling convention\"\"\"\n\n    name = \"ms\"\n    argument_registers = [\n        ArchX64.regs.RCX,\n        ArchX64.regs.RDX,\n        ArchX64.regs.R8,\n        ArchX64.regs.R9,\n    ]\n\n    floating_point_registers = [\n        ArchX64.regs.XMM0,\n        ArchX64.regs.XMM1,\n        ArchX64.regs.XMM2,\n        ArchX64.regs.XMM3,\n    ]\n\n    return_value = ArchX64.regs.RAX\n    overflow_return = ArchX64.regs.RDX\n</code></pre>"},{"location":"reference/python/analysis/calling_convention/#quokka.analysis.calling_convention.Stdcall","title":"<code>Stdcall</code>","text":"<p>               Bases: <code>CCdecl</code></p> <p>Stdcall calling convention</p> Source code in <code>quokka/analysis/calling_convention.py</code> <pre><code>class Stdcall(CCdecl):\n    \"\"\"Stdcall calling convention\"\"\"\n\n    name = \"stdcall\"\n    callee_saved = True\n</code></pre>"},{"location":"reference/python/analysis/calling_convention/#quokka.analysis.calling_convention.SystemVAMD","title":"<code>SystemVAMD</code>","text":"<p>               Bases: <code>CallingConvention</code></p> <p>SysV calling convention</p> Source code in <code>quokka/analysis/calling_convention.py</code> <pre><code>class SystemVAMD(CallingConvention):\n    \"\"\"SysV calling convention\"\"\"\n\n    name = \"sysv\"\n    argument_registers = [\n        ArchX64.regs.RDI,\n        ArchX64.regs.RSI,\n        ArchX64.regs.RDX,\n        ArchX64.regs.RCX,\n        ArchX64.regs.R8,\n        ArchX64.regs.R9,\n    ]\n\n    floating_point_registers = [\n        ArchX64.regs.XMM0,\n        ArchX64.regs.XMM1,\n        ArchX64.regs.XMM2,\n        ArchX64.regs.XMM3,\n        ArchX64.regs.XMM4,\n        ArchX64.regs.XMM5,\n        ArchX64.regs.XMM6,\n        ArchX64.regs.XMM7,\n    ]\n\n    caller_saved_registers = argument_registers + [\n        ArchX64.regs.R10,\n        ArchX64.regs.R11,\n        ArchX64.regs.RAX,\n    ]\n\n    return_value = ArchX64.regs.RAX\n    overflow_return = ArchX64.regs.RDX\n</code></pre>"},{"location":"reference/python/analysis/env/","title":"env","text":"<p>Environment module</p>"},{"location":"reference/python/analysis/env/#quokka.analysis.env.Environment","title":"<code>Environment</code>","text":"<p>Environment base class</p> <p>Parameters:</p> Name Type Description Default <code>platform</code> <code>Platform</code> <p>Platform</p> required <code>arch</code> <code>Type[QuokkaArch]</code> <p>Architecture</p> required <p>Attributes:</p> Name Type Description <code>platform</code> <code>Platform</code> <p>Platform</p> <code>arch</code> <code>Type[QuokkaArch]</code> <p>Architecture</p> <code>calling_convention</code> <code>Type[CallingConvention]</code> <p>Calling convention</p> Source code in <code>quokka/analysis/env.py</code> <pre><code>class Environment:\n    \"\"\"Environment base class\n\n    Args:\n        platform: Platform\n        arch: Architecture\n\n    Attributes:\n        platform: Platform\n        arch: Architecture\n        calling_convention: Calling convention\n\n    \"\"\"\n\n    def __init__(\n        self,\n        platform: quokka.analysis.Platform,\n        arch: Type[quokka.analysis.arch.QuokkaArch],\n    ):\n        \"\"\"Constructor\"\"\"\n        self.platform: quokka.analysis.Platform = platform\n        self.arch: Type[quokka.analysis.arch.QuokkaArch] = arch\n        self.calling_convention: Type[\n            cc.CallingConvention\n        ] = get_calling_convention_for_arch_platform(platform, arch)\n</code></pre>"},{"location":"reference/python/analysis/env/#quokka.analysis.env.Environment.__init__","title":"<code>__init__(platform, arch)</code>","text":"<p>Constructor</p> Source code in <code>quokka/analysis/env.py</code> <pre><code>def __init__(\n    self,\n    platform: quokka.analysis.Platform,\n    arch: Type[quokka.analysis.arch.QuokkaArch],\n):\n    \"\"\"Constructor\"\"\"\n    self.platform: quokka.analysis.Platform = platform\n    self.arch: Type[quokka.analysis.arch.QuokkaArch] = arch\n    self.calling_convention: Type[\n        cc.CallingConvention\n    ] = get_calling_convention_for_arch_platform(platform, arch)\n</code></pre>"},{"location":"reference/python/analysis/env/#quokka.analysis.env.Platform","title":"<code>Platform</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Platform enumeration</p> Source code in <code>quokka/analysis/env.py</code> <pre><code>class Platform(enum.Enum):\n    \"\"\"Platform enumeration\"\"\"\n\n    UNKNOWN = enum.auto()\n    WINDOWS = enum.auto()\n    LINUX = enum.auto()\n    APPLE = enum.auto()\n</code></pre>"},{"location":"reference/python/analysis/env/#quokka.analysis.env.get_calling_convention_for_arch_platform","title":"<code>get_calling_convention_for_arch_platform(platform, arch)</code>","text":"<p>Retrieve the calling convention used for this couple platform/arch</p> <p>Parameters:</p> Name Type Description Default <code>platform</code> <code>Platform</code> <p>Used platform</p> required <code>arch</code> <code>Type[QuokkaArch]</code> <p>Used architecture</p> required <p>Returns:</p> Type Description <code>Type[CallingConvention]</code> <p>A calling convention</p> Source code in <code>quokka/analysis/env.py</code> <pre><code>def get_calling_convention_for_arch_platform(\n    platform: quokka.analysis.Platform,\n    arch: Type[quokka.analysis.QuokkaArch],\n) -&gt; Type[cc.CallingConvention]:\n    \"\"\"Retrieve the calling convention used for this couple platform/arch\n\n    Arguments:\n        platform: Used platform\n        arch: Used architecture\n\n    Returns:\n        A calling convention\n    \"\"\"\n    mapping = {\n        quokka.analysis.Platform.LINUX: {\n            ArchX64: cc.SystemVAMD,  # Must be before x86\n            ArchX86: cc.CCdecl,\n            ArchARM: cc.ARMCC,\n            ArchARM64: cc.ARM64CC,\n        },\n        quokka.analysis.Platform.WINDOWS: {\n            ArchX86: cc.Stdcall,\n            ArchX64: cc.MicrosoftAMD64,\n        },\n    }\n\n    platform_mapping = mapping.get(platform)\n    if platform_mapping is None:\n        return cc.CallingConvention\n\n    for architecture, convention in platform_mapping.items():\n        if issubclass(arch, architecture):\n            return convention\n\n    return cc.CallingConvention\n</code></pre>"},{"location":"reference/python/analysis/replacer/","title":"replacer","text":""},{"location":"reference/python/analysis/replacer/#quokka.analysis.replacer.Replacer","title":"<code>Replacer</code>","text":"<p>Replacer class</p> <p>Warning: This class has been used in some experiments but will/should probably be removed because it does not belong to the project.</p> Source code in <code>quokka/analysis/replacer.py</code> <pre><code>class Replacer:\n    \"\"\"Replacer class\n\n    Warning: This class has been used in some experiments but will/should probably be\n    removed because it does not belong to the project.\n    \"\"\"\n\n    ignored_registers: List[str]\n    ignored_mnemonics: List[str]\n\n    regs: RegType\n    compared_mnemonics: List[str]\n    calling_registers: List[RegType]\n\n    replacement: Dict[RegType, RegType]\n\n    @staticmethod\n    def norm_mnemonic(mnemonic: str) -&gt; str:\n        \"\"\"\n        Norm a mnemonic (remove everything after '.').\n        Examples:\n            cmp.w -&gt; CMP\n            mov -&gt; MOV\n\n        Arguments:\n            mnemonic: Mnemonic to norm\n\n        Returns:\n            Normed mnemonic\n        \"\"\"\n        if \".\" in mnemonic:\n            return mnemonic[: mnemonic.rfind(\".\")].upper()\n\n        return mnemonic.upper()\n\n    def get(self, item) -&gt; RegType:\n        assert self.replacement is not None\n        if isinstance(item, RegType):\n            return self.replacement.get(item, item)\n        return item\n\n    def is_ignored(self, item) -&gt; bool:\n        assert self.ignored_registers is not None\n        return self.get(item) in self.ignored_registers\n\n    def __call__(self, *args: Any, **kwargs: Any) -&gt; RegType:\n        return self.get(*args, **kwargs)\n\n    def is_ignored_mnemonics(self, mnemonic: str) -&gt; bool:\n        assert self.ignored_mnemonics is not None\n        return self.norm_mnemonic(mnemonic) in self.ignored_mnemonics\n\n    def is_compared_mnemonic(self, mnemonic: str) -&gt; bool:\n        assert self.compared_mnemonics is not None\n        return self.norm_mnemonic(mnemonic) in self.compared_mnemonics\n\n    def calling_convention(self) -&gt; List[RegType]:\n        assert self.calling_registers is not None\n        return self.calling_registers\n\n    def argument_registers(self, platform: quokka.analysis.Platform) -&gt; List:\n        return []\n</code></pre>"},{"location":"reference/python/analysis/replacer/#quokka.analysis.replacer.Replacer.norm_mnemonic","title":"<code>norm_mnemonic(mnemonic)</code>  <code>staticmethod</code>","text":"<p>Norm a mnemonic (remove everything after '.'). Examples:     cmp.w -&gt; CMP     mov -&gt; MOV</p> <p>Parameters:</p> Name Type Description Default <code>mnemonic</code> <code>str</code> <p>Mnemonic to norm</p> required <p>Returns:</p> Type Description <code>str</code> <p>Normed mnemonic</p> Source code in <code>quokka/analysis/replacer.py</code> <pre><code>@staticmethod\ndef norm_mnemonic(mnemonic: str) -&gt; str:\n    \"\"\"\n    Norm a mnemonic (remove everything after '.').\n    Examples:\n        cmp.w -&gt; CMP\n        mov -&gt; MOV\n\n    Arguments:\n        mnemonic: Mnemonic to norm\n\n    Returns:\n        Normed mnemonic\n    \"\"\"\n    if \".\" in mnemonic:\n        return mnemonic[: mnemonic.rfind(\".\")].upper()\n\n    return mnemonic.upper()\n</code></pre>"},{"location":"reference/python/analysis/utils/","title":"utils","text":"<p>Utilities functions for the analysis</p>"},{"location":"reference/python/analysis/utils/#quokka.analysis.utils.split_chunk","title":"<code>split_chunk(chunk)</code>","text":"<p>Split a chunk if it is composed of multiple components.</p> <p>If a chunk is composed of multiple connected components, we want to split them so some analysis may be performed.</p> <p>Parameters:</p> Name Type Description Default <code>chunk</code> <code>Chunk</code> <p>A chunk to split</p> required <p>Returns:</p> Type Description <code>Union[Chunk, SuperChunk]</code> <p>Either a Chunk or a SuperChunk</p> Source code in <code>quokka/analysis/utils.py</code> <pre><code>def split_chunk(\n    chunk: quokka.Chunk,\n) -&gt; Union[quokka.Chunk, quokka.SuperChunk]:\n    \"\"\"Split a chunk if it is composed of multiple components.\n\n    If a chunk is composed of multiple connected components, we want to split them so\n    some analysis may be performed.\n\n    Arguments:\n        chunk: A chunk to split\n\n    Returns:\n        Either a Chunk or a SuperChunk\n    \"\"\"\n    components = list(nx.connected_components(nx.Graph(chunk.graph)))\n    if len(components) &lt;= 1:\n        return chunk\n\n    return quokka.function.SuperChunk(chunk, components)\n</code></pre>"},{"location":"reference/python/backends/capstone/","title":"capstone","text":"<p>Capstone integration</p>"},{"location":"reference/python/backends/capstone/#quokka.backends.capstone.capstone_decode_instruction","title":"<code>capstone_decode_instruction(inst)</code>","text":"<p>Decode an instruction with capstone</p> <p>Decode an instruction and retry for ARM to check if the Thumb mode was activated The decoding logic is done by the inner method <code>_decode</code>.</p> <p>Parameters:</p> Name Type Description Default <code>inst</code> <code>Instruction</code> <p>Instruction to translate</p> required <p>Returns:</p> Type Description <code>Optional[CsInsn]</code> <p>A capstone instruction if it has been decoded</p> Source code in <code>quokka/backends/capstone.py</code> <pre><code>def capstone_decode_instruction(\n    inst: quokka.Instruction,\n) -&gt; Optional[capstone.CsInsn]:\n    \"\"\"Decode an instruction with capstone\n\n    Decode an instruction and retry for ARM to check if the Thumb mode was activated\n    The decoding logic is done by the inner method `_decode`.\n\n    Arguments:\n        inst: Instruction to translate\n\n    Returns:\n        A capstone instruction if it has been decoded\n    \"\"\"\n\n    context: capstone.Cs = update_capstone_context(inst.program, inst.thumb)\n    capstone_inst = _decode(context, inst.bytes, inst.address, count=1)\n\n    if capstone_inst is None and context.arch == capstone.CS_ARCH_ARM:\n        if context.mode == capstone.CS_MODE_THUMB:\n            new_context = get_capstone_context(quokka.analysis.ArchARM)\n        else:\n            new_context = get_capstone_context(quokka.analysis.ArchARMThumb)\n\n        capstone_inst = _decode(new_context, inst.bytes, inst.address, count=1)\n\n    return capstone_inst\n</code></pre>"},{"location":"reference/python/backends/capstone/#quokka.backends.capstone.get_capstone_context","title":"<code>get_capstone_context(arch, endian=Endianness.LITTLE_ENDIAN)</code>","text":"<p>Compute the capstone context for the program</p> <p>The Capstone context is used to decode instructions afterwards. Since we are interested in most of the details, we already set the details to True.</p> <p>Parameters:</p> Name Type Description Default <code>arch</code> <code>Type[QuokkaArch]</code> <p>Quokka program architecture</p> required <p>Returns:</p> Type Description <code>Cs</code> <p>A capstone Cs instance</p> Source code in <code>quokka/backends/capstone.py</code> <pre><code>def get_capstone_context(\n        arch: Type[quokka.analysis.QuokkaArch],\n        endian: Type[Endianness] = Endianness.LITTLE_ENDIAN) -&gt; capstone.Cs:\n    \"\"\"Compute the capstone context for the program\n\n    The Capstone context is used to decode instructions afterwards. Since we are\n    interested in most of the details, we already set the details to True.\n\n    Arguments:\n        arch: Quokka program architecture\n\n    Returns:\n        A capstone Cs instance\n    \"\"\"\n    endian_mapping = {\n        Endianness.BIG_ENDIAN: capstone.CS_MODE_BIG_ENDIAN,\n        Endianness.LITTLE_ENDIAN: capstone.CS_MODE_LITTLE_ENDIAN,\n    }\n    capstone_endian = endian_mapping[endian]\n\n    mapping = {\n        quokka.analysis.ArchARM: (capstone.CS_ARCH_ARM, capstone.CS_MODE_ARM),\n        quokka.analysis.ArchARM64: (capstone.CS_ARCH_ARM64, capstone.CS_MODE_ARM),\n        quokka.analysis.ArchX86: (capstone.CS_ARCH_X86, capstone.CS_MODE_32),\n        quokka.analysis.ArchX64: (capstone.CS_ARCH_X86, capstone.CS_MODE_64),\n        quokka.analysis.ArchARMThumb: (\n            capstone.CS_ARCH_ARM,\n            capstone.CS_MODE_THUMB,\n        ),\n        quokka.analysis.ArchMIPS: (\n            capstone.CS_ARCH_MIPS,\n            capstone.CS_MODE_32 + capstone_endian),\n        quokka.analysis.ArchMIPS64: (\n            capstone.CS_ARCH_MIPS,\n            capstone.CS_MODE_64 + capstone_endian),\n        quokka.analysis.ArchPPC: (\n            capstone.CS_ARCH_PPC,\n            capstone.CS_MODE_32 + capstone_endian),\n        quokka.analysis.ArchPPC64: (\n            capstone.CS_ARCH_PPC,\n            capstone.CS_MODE_64 + capstone_endian),\n    }\n\n    try:\n        capstone_arch, capstone_mode = mapping.get(arch)\n    except TypeError as exc:\n        raise quokka.CapstoneError(\"Unable to find the Architecture\") from exc\n\n    context = capstone.Cs(capstone_arch, capstone_mode)\n    context.detail = True\n\n    return context\n</code></pre>"},{"location":"reference/python/backends/capstone/#quokka.backends.capstone.update_capstone_context","title":"<code>update_capstone_context(program, is_thumb)</code>","text":"<p>Returns an appropriate context for Capstone instructions</p> <p>For ARM architecture, if the instruction is Thumb, we must use a different context.</p> <p>Parameters:</p> Name Type Description Default <code>program</code> <code>Program</code> <p>Program to consider</p> required <code>is_thumb</code> <code>bool</code> <p>Is the instruction a thumb one?</p> required <p>Returns:</p> Type Description <code>Cs</code> <p>The correct capstone context</p> Source code in <code>quokka/backends/capstone.py</code> <pre><code>def update_capstone_context(program: quokka.Program, is_thumb: bool) -&gt; capstone.Cs:\n    \"\"\"Returns an appropriate context for Capstone instructions\n\n    For ARM architecture, if the instruction is Thumb, we must use a different context.\n\n    Arguments:\n        program: Program to consider\n        is_thumb: Is the instruction a thumb one?\n\n    Returns:\n        The correct capstone context\n    \"\"\"\n    if (\n        program.arch\n        in (\n            quokka.analysis.ArchARM,\n            quokka.analysis.ArchARM64,\n            quokka.analysis.ArchARMThumb,\n        )\n        and is_thumb\n    ):\n        return get_capstone_context(quokka.analysis.ArchARMThumb)\n\n    return program.capstone\n</code></pre>"},{"location":"reference/python/backends/pypcode/","title":"pypcode","text":"<p>PyPCode integration</p>"},{"location":"reference/python/backends/pypcode/#quokka.backends.pypcode.get_arch_from_string","title":"<code>get_arch_from_string(target_id)</code>","text":"<p>Find the architecture for an arch based on the target identification</p> <p>Parameters:</p> Name Type Description Default <code>target_id</code> <code>str</code> <p>Identifier of the architecture</p> required <p>Raises:</p> Type Description <code>PypcodeError</code> <p>if the architecture is not found</p> <p>Returns:</p> Type Description <code>ArchLanguage</code> <p>The appropriate ArchLang</p> Source code in <code>quokka/backends/pypcode.py</code> <pre><code>def get_arch_from_string(target_id: str) -&gt; pypcode.ArchLanguage:\n    \"\"\"Find the architecture for an arch based on the target identification\n\n    Arguments:\n        target_id: Identifier of the architecture\n\n    Raises:\n        PypcodeError: if the architecture is not found\n\n    Returns:\n        The appropriate ArchLang\n    \"\"\"\n    pcode_arch: pypcode.Arch\n    for pcode_arch in pypcode.Arch.enumerate():\n        for lang in pcode_arch.languages:\n            if lang.id == target_id:\n                return lang\n\n    raise quokka.PypcodeError(\"Unable to find the appropriate arch: missing lang\")\n</code></pre>"},{"location":"reference/python/backends/pypcode/#quokka.backends.pypcode.get_pypcode_context","title":"<code>get_pypcode_context(arch, endian=Endianness.LITTLE_ENDIAN)</code>","text":"<p>Convert an arch from Quokka to Pypcode</p> <p>For the moment, only the arch described in quokka.analysis are supported. This method is a bit slow because enum are generated by pypcode on the fly but should be executed only once.</p> <p>Parameters:</p> Name Type Description Default <code>arch</code> <code>Type[QuokkaArch]</code> <p>Quokka program architecture</p> required <code>endian</code> <code>Type[Endianness]</code> <p>Architecture endianness</p> <code>LITTLE_ENDIAN</code> <p>Raises:</p> Type Description <code>PypcodeError</code> <p>if the conversion for arch is not found</p> <p>Returns:</p> Type Description <code>Context</code> <p>A pypcode.Context instance</p> Source code in <code>quokka/backends/pypcode.py</code> <pre><code>def get_pypcode_context(\n        arch: Type[quokka.analysis.QuokkaArch],\n        endian: Type[Endianness] = Endianness.LITTLE_ENDIAN\n) -&gt; pypcode.Context:\n    \"\"\"Convert an arch from Quokka to Pypcode\n\n    For the moment, only the arch described in quokka.analysis are supported.\n    This method is a bit slow because enum are generated by pypcode on the fly but should\n    be executed only once.\n\n    Arguments:\n        arch: Quokka program architecture\n        endian: Architecture endianness\n\n    Raises:\n        PypcodeError: if the conversion for arch is not found\n\n    Returns:\n        A pypcode.Context instance\n    \"\"\"\n    names: Dict[Type[quokka.analysis.arch.QuokkaArch], str] = {\n        quokka.analysis.ArchX64: \"x86:LE:64:default\",\n        quokka.analysis.ArchX86: \"x86:LE:32:default\",\n        quokka.analysis.ArchARM: \"ARM:LE:32:v8\",\n        quokka.analysis.ArchARM64: \"AARCH64:LE:64:v8A\",\n        quokka.analysis.ArchARMThumb: \"ARM:LE:32:v8T\",\n        quokka.analysis.ArchMIPS: \"MIPS:LE:32:default\",\n        quokka.analysis.ArchMIPS64: \"MIPS:LE:64:default\",\n        quokka.analysis.ArchPPC: \"PowerPC:LE:32:default\",\n        quokka.analysis.ArchPPC64: \"PowerPC:LE:64:default\",\n    }\n\n    try:\n        target_id = names[arch]\n    except KeyError as exc:\n        raise quokka.PypcodeError(\n            \"Unable to find the appropriate arch: missing id\"\n        ) from exc\n\n    if endian == Endianness.BIG_ENDIAN:\n        target_id = target_id.replace(\":LE:\", \":BE:\")\n\n    pcode_arch = get_arch_from_string(target_id)\n    return pypcode.Context(pcode_arch)\n</code></pre>"},{"location":"reference/python/backends/pypcode/#quokka.backends.pypcode.pypcode_decode_block","title":"<code>pypcode_decode_block(block)</code>","text":"<p>Decode a block at once.</p> <p>This method decode a block of instructions using Pypcode context all at once. This is faster than multiple calls to the decode at the instruction level.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>Block</code> <p>Block to decode</p> required <p>Returns:</p> Type Description <code>List[PcodeOp]</code> <p>A list of pcode operations</p> Source code in <code>quokka/backends/pypcode.py</code> <pre><code>def pypcode_decode_block(block: quokka.Block) -&gt; List[pypcode.PcodeOp]:\n    \"\"\"Decode a block at once.\n\n    This method decode a block of instructions using Pypcode context all at once.\n    This is faster than multiple calls to the decode at the instruction level.\n\n    Arguments:\n        block: Block to decode\n\n    Returns:\n        A list of pcode operations\n    \"\"\"\n\n    # Fast guard, empty blocks do not have any Pcode operations\n    first_instruction: Optional[quokka.Instruction] = next(block.instructions, None)\n    if first_instruction is None:\n        return []\n\n    # Retrieve the context from the instruction\n    context: pypcode.Context = update_pypcode_context(\n        block.program, first_instruction.thumb\n    )\n\n    try:\n        # Translate\n        translation = context.translate(\n            block.bytes,  # buf\n            block.start,  # base_address\n            0,  # max_bytes\n            0,  # max_instructions\n        )\n        return translation.ops\n\n    except pypcode.BadDataError as e:\n        logger.error(e)\n        raise quokka.PypcodeError(f\"Decoding error for block at 0x{block.start:x} (BadDataError)\")\n    except pypcode.UnimplError as e:\n        logger.error(e)\n        raise quokka.PypcodeError(f\"Decoding error for block at 0x{block.start:x} (UnimplError)\")\n</code></pre>"},{"location":"reference/python/backends/pypcode/#quokka.backends.pypcode.pypcode_decode_instruction","title":"<code>pypcode_decode_instruction(inst)</code>","text":"<p>Decode an instruction using Pypcode</p> <p>This will return the list of Pcode operations done for the instruction. Note that a (binary) instruction is expected to have several pcode instructions associated. When decoding a single instruction IMARK instructions are excluded!</p> <p>Parameters:</p> Name Type Description Default <code>inst</code> <code>Instruction</code> <p>Instruction to translate</p> required <p>Raises:</p> Type Description <code>PypcodeError</code> <p>if the decoding fails</p> <p>Returns:</p> Type Description <code>Sequence[PcodeOp]</code> <p>A sequence of PcodeOp</p> Source code in <code>quokka/backends/pypcode.py</code> <pre><code>def pypcode_decode_instruction(\n    inst: quokka.Instruction,\n) -&gt; Sequence[pypcode.PcodeOp]:\n    \"\"\"Decode an instruction using Pypcode\n\n    This will return the list of Pcode operations done for the instruction.\n    Note that a (binary) instruction is expected to have several pcode instructions\n    associated. When decoding a single instruction IMARK instructions are excluded!\n\n    Arguments:\n        inst: Instruction to translate\n\n    Raises:\n        PypcodeError: if the decoding fails\n\n    Returns:\n        A sequence of PcodeOp\n    \"\"\"\n\n    context: pypcode.Context = update_pypcode_context(inst.program, inst.thumb)\n    try:\n        translation = context.translate(\n            inst.bytes,  # buf\n            inst.address,  # base_address\n            0,  # max_bytes\n            1,  # max_instructions\n        )\n\n        return [x for x in translation.ops if x.opcode != pypcode.OpCode.IMARK]\n\n    except pypcode.BadDataError as e:\n        logger.error(e)\n        raise quokka.PypcodeError(f\"Unable to decode instruction (BadDataError)\")\n    except pypcode.UnimplError as e:\n        logger.error(e)\n        raise quokka.PypcodeError(f\"Unable to decode instruction (UnimplError)\")\n</code></pre>"},{"location":"reference/python/backends/pypcode/#quokka.backends.pypcode.update_pypcode_context","title":"<code>update_pypcode_context(program, is_thumb)</code>","text":"<p>Return an appropriate pypcode context for the decoding</p> <p>For ARM architecture, if the block starts with a Thumb instruction, we must use a different pypcode Context.</p> <p>We use the boolean <code>is_thumb</code> directly to allow caching of the call here because it is costly to generate the context.</p> <p>Parameters:</p> Name Type Description Default <code>program</code> <code>Program</code> <p>Program to consider</p> required <code>is_thumb</code> <code>bool</code> <p>Is the instruction a thumb one?</p> required <p>Returns:</p> Type Description <code>Context</code> <p>The correct pypcode context</p> Source code in <code>quokka/backends/pypcode.py</code> <pre><code>def update_pypcode_context(program: quokka.Program, is_thumb: bool) -&gt; pypcode.Context:\n    \"\"\"Return an appropriate pypcode context for the decoding\n\n    For ARM architecture, if the block starts with a Thumb instruction, we must use\n    a different pypcode Context.\n\n    We use the boolean `is_thumb` directly to allow caching of the call here because it\n    is costly to generate the context.\n\n    Arguments:\n        program: Program to consider\n        is_thumb: Is the instruction a thumb one?\n\n    Returns:\n        The correct pypcode context\n    \"\"\"\n\n    if (\n        program.arch\n        in (\n            quokka.analysis.ArchARM,\n            quokka.analysis.ArchARM64,\n            quokka.analysis.ArchARMThumb,\n        )\n        and is_thumb\n    ):\n        return get_pypcode_context(quokka.analysis.ArchARMThumb)\n\n    return program.pypcode\n</code></pre>"},{"location":"tutorials/bionic/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Introduction</li> <li>Strategy</li> <li>Final</li> </ul>"},{"location":"tutorials/bionic/final/","title":"Final words","text":"<p>The final script looks like this</p> <pre><code>#  Copyright 2022-2023 Quarkslab\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\n\"\"\"BIONIC User ID extractor\n\nThis snippet uses Quokka to extract the user ID mapping from a Bionic LibC\n\nUsage:\n    python ./script &lt;bionic_path&gt;\n\nAuthor:\n    Written by dm (Alexis Challande) in 2022.\n\"\"\"\n\nimport quokka\nfrom quokka import Data\nfrom quokka.types import AddressT, DataType\n\n\ndef print_usertable(bionic: quokka.Program):\n    \"\"\"Extract the user table with a bionic libc\"\"\"\n\n    # Step1 : Find the function\n    getpwuid = bionic.get_function(\"getpwuid\", approximative=False)\n\n    # Step 2: find the data ref\n    user_table: Data = getpwuid.data_references[1]\n\n    # Step 3: Read the first entry\n    users = []\n\n    first_user = bionic.executable.read_string(user_table.value)\n    first_id = bionic.get_data(user_table.address + 0x4).value\n    users.append((first_user, first_id))\n\n    # Read other entries\n    def read_userid(prog: quokka.Program, address: AddressT) -&gt; int:\n        return prog.executable.read_data(\n            prog.addresser.file(address), DataType.DOUBLE_WORD\n        )\n\n    # Gather all components together\n    start = user_table.address + 0x8\n    while True:\n        data: Data = bionic.get_data(start)\n        if data.code_references:\n            break\n\n        user_name = bionic.executable.read_string(data.value)\n        user_id = read_userid(bionic, data.address + 0x4)\n\n        print(f\"New user {user_name} with ID {user_id}\")\n        users.append((user_name, user_id))\n\n        start += 0x8\n\n    # Print the user table\n    for user_name, user_id in users:\n        print(f\"{user_name=} : {user_id=}\")\n\n\nif __name__ == \"__main__\":\n    program: quokka.Program = quokka.Program.from_binary(sys.argv[1])\n    print_usertable(program)\n</code></pre>"},{"location":"tutorials/bionic/introduction/","title":"Bionic in Android","text":"<p>In this tutorial, we will learn how to extract the user mapping in the <code>Android</code> libc: <code>Bionic</code>.</p>"},{"location":"tutorials/bionic/introduction/#context","title":"Context","text":"<p>Android, the mobile operating system, uses a custom <code>libc</code>: <code>bionic</code>. A few notable changes exist from the classic  implementation of the libc found on most desktop Linux systems. One of them is that the user table is embedded within the binary.</p>"},{"location":"tutorials/bionic/introduction/#objective","title":"Objective","text":"<p>Automatically extract the user mapping from the binary<sup>1</sup>.</p>"},{"location":"tutorials/bionic/introduction/#requirements","title":"Requirements","text":"<ul> <li>A working Quokka Installation</li> <li>The bionic library (<code>sha256sum: 5975c8366fce5e47ccdf80f5d01f3e4521fee3b1dcf719243f4e4236d9699443</code>)</li> <li>An export of the bionic library</li> </ul>"},{"location":"tutorials/bionic/introduction/#check-requirements","title":"Check requirements","text":"<pre><code>import quokka\nbionic = quokka.Program(\"libc.quokka\", \"libc.so\")\nassert bionic is not None\n</code></pre>"},{"location":"tutorials/bionic/introduction/#final-words","title":"Final words","text":"<p>Once you are set, we can advance to the next steps.</p> <ol> <li> <p>This exercise is based on an idea from Robin David in his IDA scripting training.\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorials/bionic/strategy/","title":"Strategy","text":"<p>Before diving within Quokka, let's try to understand how we could solve the problem on paper.</p>"},{"location":"tutorials/bionic/strategy/#steps","title":"Steps","text":"<ol> <li>Identify a function using the user table</li> <li>Find a data reference to the table</li> <li>Identify the table boundaries</li> <li>Read one entry</li> <li>Repeat until the end of the table</li> </ol>"},{"location":"tutorials/bionic/strategy/#step-1-identify-a-function-using-the-user-table","title":"Step 1: Identify a function using the user table","text":"<p>For this, we have no choice but to read the manual.</p> <p>The <code>getpwuid</code> function is a good candidate, look at the manual below:</p> <pre><code>The  getpwuid()  function  returns a pointer to a structure containing the\nbroken-out fields of the record in the password database that matches  the\nuser ID uid.\n</code></pre> <p>Lets select the function:</p> <pre><code># WARNING: Not working\n\nfrom quokka import Function\nfunction: Function = bionic.get_function(\"getpwuid\")\n\nassert function.name == \"getpwuid\" # Raises an error\n</code></pre> <p>The previous snippet generates an error. Indeed, the <code>function</code> selected is not <code>getpwuid</code> but <code>j_getpwuid</code>. However, the signature of the <code>get_function</code> method has an additional parameter:</p> <pre><code>Program.get_function(name: 'str', approximative: 'bool' = True, normal: 'bool' = False) -&gt; 'quokka.Function'\n</code></pre> <p>Thus, the correct code to select the <code>getpwuid</code> function is:</p> <pre><code>getpwuid: Function = bionic.get_function(\"getpwuid\", approximative=False)\nassert getpwuid.name == \"getpwuid\" # Correct\n</code></pre>"},{"location":"tutorials/bionic/strategy/#step-2-find-the-data-reference-to-the-table","title":"Step 2: Find the data reference to the table","text":"<p>We know that the <code>getpwuid</code> functions must use the user mapping we are searching. So, a (data) reference towards the  table must exist within the function. Lets explore them:</p> <pre><code>for data in getpwuid.data_references:\n    print(f\"{data.name} ({data.type}) at 0x{data.address:x}\")\n</code></pre> <p><pre><code>None (DataType.DOUBLE_WORD) at 0x1d024\n_ZL11android_ids (DataType.DOUBLE_WORD) at 0x8cda0\n_ZL11android_ids (DataType.DOUBLE_WORD) at 0x8cda0\nNone (DataType.DOUBLE_WORD) at 0x8cda4\n</code></pre> So the second and third reference in the function are towards the table we are looking for!</p> <p>Let's find the beginning of our user table:</p> <pre><code>from quokka import Data\nuser_table: Data = getpwuid.data_references[1]\n\nprint(f\"{user_table.address=:x}\")\n# user_table.address=8cda0\n</code></pre>"},{"location":"tutorials/bionic/strategy/#step-3-identify-the-table-boundaries","title":"Step 3: Identify the table boundaries","text":"<p>For this step, we are going to use an heuristic:  * We know that the user table is contiguous in memory * We know that there are no code-references to the middle of the table</p> <p>So we are going to iterate the memory, starting at the first entry until an element as a code reference pointing  towards it.</p> <p>To find if an element has a code reference, there is a convenient accessor:</p> <pre><code>data = bionic.get_data(address)\nassert data.code_references != [], \"Has code references\"\n</code></pre> <p>So our loop to iterate until the end of the table will look like this:</p> <pre><code>from quokka.types import AddressT\n\naddress: AddressT\nwhile True:\n    data = bionic.get_data(address)\n    if data.code_references:\n        break\n\n    ...\n</code></pre>"},{"location":"tutorials/bionic/strategy/#step-4-read-one-entry","title":"Step 4: Read one entry","text":"<p>The structure of the table is as followed: <pre><code>struct android_id_info {\n  const char name[17];\n  unsigned aid;\n};\n</code></pre></p> <p>To read this with Quokka:</p> <pre><code># Start with the first entry, using the read_string method\nuser_name = bionic.executable.read_string(user_table.value)\n# cameraserver\n</code></pre> <p>And read the user ID too: it will be on the next DWORD: <pre><code>first_id = bionic.get_data(user_table.address + 0x4).value\n# 1047\n</code></pre></p> <p>However, the snippet above works only if IDA found the data in the program. Otherwise, it will fail with the following error:</p> <pre><code>ValueError: No data at offset 0x8cdbc\n</code></pre> <p>Another solution is to write this helper script: <pre><code>from quokka import Program\nfrom quokka.types import AddressT, DataType\n\ndef read_userid(prog: Program, address: AddressT) -&gt; int:\n    \"\"\"Read an user ID within the program at `address`\"\"\"\n    return prog.executable.read_data(\n        prog.addresser.file(address), DataType.DOUBLE_WORD\n    )\n</code></pre></p>"},{"location":"tutorials/bionic/strategy/#step-5-repeat-until-the-end-of-the-table","title":"Step 5: Repeat until the end of the table","text":"<p>Now, we have every component of our script, let put it together within a loop:</p> <pre><code>from quokka.types import AddressT\n\nstart: AddressT = user_table.address + 0x8\nwhile True:\n    data = bionic.get_data(start)\n    if data.code_references:\n        break\n\n    user_name = bionic.executable.read_string(data.value)\n    user_id = read_userid(bionic, data.address + 0x4)\n\n    start += 0x8\n</code></pre>"},{"location":"tutorials/features/00_intro/","title":"Features extraction","text":"<p>Note</p> <p>This tutorial is adapted from the demonstration presented in GreHack'22.</p>"},{"location":"tutorials/features/00_intro/#context","title":"Context","text":"<p>Let's try to reproduce one of the feature extractor of the great <code>How Machine Learning Is Solving the Binary Function  Similarity Problem</code><sup>1</sup> paper.</p>"},{"location":"tutorials/features/00_intro/#idea","title":"Idea","text":"<p>This tutorial simply tries to demonstrate how to perform common feature extraction using <code>Quokka</code> API instead of using IDA's API. By using Quokka, you gain several advantages:</p> <ul> <li>A saner API</li> <li>A compatibility with multiple IDA versions</li> <li>Reusable scripts</li> <li>A faster feature extraction</li> </ul>"},{"location":"tutorials/features/00_intro/#original-code","title":"Original code","text":"<p>The original code for this tutorial is found in Cisco-Talos repository and reproduced below just for documentation  purpose.</p> <p>From <code>[https://github.com/Cisco-Talos/binary_function_similarity/blob/main/IDA_scripts/IDA_acfg_features/IDA_acfg_features.py](https://github.com/Cisco-Talos/binary_function_similarity/blob/main/IDA_scripts/IDA_acfg_features/IDA_acfg_features.py)</code></p> <pre><code>##############################################################################\n#                                                                            #\n#  Code for the USENIX Security '22 paper:                                   #\n#  How Machine Learning Is Solving the Binary Function Similarity Problem.   #\n#                                                                            #\n#  MIT License                                                               #\n#                                                                            #\n#  Copyright (c) 2019-2022 Cisco Talos                                       #\n#                                                                            #\n#  Permission is hereby granted, free of charge, to any person obtaining     #\n#  a copy of this software and associated documentation files (the           #\n#  \"Software\"), to deal in the Software without restriction, including       #\n#  without limitation the rights to use, copy, modify, merge, publish,       #\n#  distribute, sublicense, and/or sell copies of the Software, and to        #\n#  permit persons to whom the Software is furnished to do so, subject to     #\n#  the following conditions:                                                 #\n#                                                                            #\n#  The above copyright notice and this permission notice shall be            #\n#  included in all copies or substantial portions of the Software.           #\n#                                                                            #\n#  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,           #\n#  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF        #\n#  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND                     #\n#  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE    #\n#  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION    #\n#  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION     #\n#  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.           #\n#                                                                            #\n#  IDA_acfg_features.py - acfg_features IDA plugin implementation.           #\n#                                                                            #\n#  This plugin contains code from:                                           #\n#  github.com/williballenthin/python-idb/ licensed under Apache License 2.0  #\n#                                                                            #\n##############################################################################\n\nimport idautils\nimport idc\nimport json\nimport ntpath\nimport os\nimport time\n\nfrom capstone import *\nfrom collections import namedtuple\nfrom core import *\n\nBasicBlock = namedtuple('BasicBlock', ['va', 'size', 'succs'])\n\n\ndef get_bitness():\n    \"\"\"Return 32/64 according to the binary bitness.\"\"\"\n    info = idaapi.get_inf_structure()\n    if info.is_64bit():\n        return 64\n    elif info.is_32bit():\n        return 32\n\n\ndef initialize_capstone(procname, bitness):\n    \"\"\"\n    Initialize the Capstone disassembler.\n\n    Original code from Willi Ballenthin (Apache License 2.0):\n    https://github.com/williballenthin/python-idb/blob/\n    2de7df8356ee2d2a96a795343e59848c1b4cb45b/idb/idapython.py#L874\n    \"\"\"\n    md = None\n    arch = \"\"\n\n    # WARNING: mipsl mode not supported here\n    if procname == 'mipsb':\n        arch = \"MIPS\"\n        if bitness == 32:\n            md = Cs(CS_ARCH_MIPS, CS_MODE_MIPS32 | CS_MODE_BIG_ENDIAN)\n        if bitness == 64:\n            md = Cs(CS_ARCH_MIPS, CS_MODE_MIPS64 | CS_MODE_BIG_ENDIAN)\n\n    if procname == \"arm\":\n        arch = \"ARM\"\n        if bitness == 32:\n            # WARNING: THUMB mode not supported here\n            md = Cs(CS_ARCH_ARM, CS_MODE_ARM)\n        if bitness == 64:\n            md = Cs(CS_ARCH_ARM64, CS_MODE_ARM)\n\n    if \"pc\" in procname:\n        arch = \"x86\"\n        if bitness == 32:\n            md = Cs(CS_ARCH_X86, CS_MODE_32)\n        if bitness == 64:\n            md = Cs(CS_ARCH_X86, CS_MODE_64)\n\n    if md is None:\n        raise RuntimeError(\n            \"Capstone initialization failure ({}, {})\".format(\n                procname, bitness))\n\n    # Set detail to True to get the operand detailed info\n    md.detail = True\n    return md, arch\n\n\ndef capstone_disassembly(md, ea, size):\n    \"\"\"Disassemble a basic block using Capstone.\"\"\"\n    try:\n        # Define a fixed constant to extract immediates\n        max_imm = 4096\n\n        bb_heads = list()\n        bb_mnems = list()\n        bb_disasm = list()\n        bb_numerics = list()\n\n        # Get the binary data corresponding to the instruction.\n        binary_data = idc.get_bytes(ea, size)\n\n        # Iterate over each instruction in the BB\n        for i_inst in md.disasm(binary_data, ea):\n            # Get the address\n            bb_heads.append(i_inst.address)\n            # Get the mnemonic\n            bb_mnems.append(i_inst.mnemonic)\n            # Get the disasm\n            bb_disasm.append(\"{} {}\".format(\n                i_inst.mnemonic,\n                i_inst.op_str))\n\n            # Iterate over the operands\n            for op in i_inst.operands:\n                # Type immediate\n                if (op.type == 2):\n                    if op.imm &lt;= max_imm:\n                        bb_numerics.append(op.imm)\n\n        return bb_heads, bb_mnems, bb_disasm, bb_numerics\n\n    except Exception as e:\n        print(\"[!] Capstone exception\", e)\n        return list(), list(), list(), list()\n\n\ndef get_basic_blocks(fva):\n    \"\"\"Return the list of BasicBlock for a given function.\"\"\"\n    bb_list = list()\n    func = idaapi.get_func(fva)\n    if func is None:\n        return bb_list\n    for bb in idaapi.FlowChart(func):\n        # WARNING: this function includes the BBs with size 0\n        # This is different from what IDA_acfg_disasm does.\n        # if bb.end_ea - bb.start_ea &gt; 0:\n        bb_list.append(\n            BasicBlock(\n                va=bb.start_ea,\n                size=bb.end_ea - bb.start_ea,\n                succs=[x.start_ea for x in bb.succs()]))\n    return bb_list\n\n\ndef get_bb_disasm(bb, md):\n    \"\"\"Wrapper around a basic block disassembly.\"\"\"\n    bb_bytes = idc.get_bytes(bb.va, bb.size)\n    bb_heads, bb_mnems, bb_disasm, bb_numerics = \\\n        capstone_disassembly(md, bb.va, bb.size)\n    return bb_bytes, bb_heads, bb_mnems, bb_disasm, bb_numerics\n\n\ndef get_bb_features(bb, string_list, md, arch):\n    \"\"\"Extract the features associated to a BB.\"\"\"\n    features_dict = dict()\n\n    # Corner case\n    if bb.size == 0:\n        features_dict = dict(\n            bb_len=0,\n            # BB list-type features\n            bb_numerics=list(),\n            bb_strings=list(),\n            # BB numerical-type features\n            n_numeric_consts=0,\n            n_string_consts=0,\n            n_instructions=0,\n            n_arith_instrs=0,\n            n_call_instrs=0,\n            n_logic_instrs=0,\n            n_transfer_instrs=0,\n            n_redirect_instrs=0\n        )\n        return features_dict\n\n    # Get the BB bytes, disassembly, mnemonics and other features\n    bb_bytes, bb_heads, bb_mnems, bb_disasm, bb_numerics = \\\n        get_bb_disasm(bb, md)\n\n    # Get static strings from the BB\n    bb_strings = get_bb_strings(bb, string_list)\n\n    features_dict = dict(\n        bb_len=bb.size,\n        # BB list-type features\n        bb_numerics=bb_numerics,\n        bb_strings=bb_strings,\n        # BB numerical-type features\n        n_numeric_consts=len(bb_numerics),\n        n_string_consts=len(bb_strings),\n        n_instructions=len(bb_mnems),\n        n_arith_instrs=get_n_arith_instrs(bb_mnems, arch),\n        n_call_instrs=get_n_call_instrs(bb_mnems, arch),\n        n_logic_instrs=get_n_logic_instrs(bb_mnems, arch),\n        n_transfer_instrs=get_n_transfer_instrs(bb_mnems, arch),\n        n_redirect_instrs=get_n_redirect_instrs(bb_mnems, arch)\n    )\n    return features_dict\n\n\ndef run_acfg_features(idb_path, fva_list, output_dir):\n    \"\"\"Extract the features from each function. Save results to JSON.\"\"\"\n    print(\"[D] Processing: %s\" % idb_path)\n\n    # Create output directory if it does not exist\n    if not os.path.isdir(output_dir):\n        os.mkdir(output_dir)\n\n    output_dict = dict()\n    output_dict[idb_path] = dict()\n\n    procname = idaapi.get_inf_structure().procName.lower()\n    bitness = get_bitness()\n    md, arch = initialize_capstone(procname, bitness)\n\n    # Get the list of Strings for the IDB\n    string_list = list(idautils.Strings())\n\n    # Iterate over each function\n    for fva in fva_list:\n        try:\n            start_time = time.time()\n            nodes_set, edges_set = set(), set()\n            bbs_dict = dict()\n\n            for bb in get_basic_blocks(fva):\n                # CFG\n                nodes_set.add(bb.va)\n                for dest_ea in bb.succs:\n                    edges_set.add((bb.va, dest_ea))\n                # BB-level features\n                bbs_dict[bb.va] = get_bb_features(bb, string_list, md, arch)\n\n            # Function-level features\n            function_features = get_function_features(\n                fva, bbs_dict, len(edges_set))\n\n            elapsed_time = time.time() - start_time\n\n            func_dict = {\n                'nodes': list(nodes_set),\n                'edges': list(edges_set),\n                'features': function_features,\n                'basic_blocks': bbs_dict,\n                'elapsed_time': elapsed_time,\n            }\n            output_dict[idb_path][hex(fva)] = func_dict\n\n        except Exception as e:\n            print(\"[!] Exception: skipping function fva: %d\" % fva)\n            print(e)\n\n    out_name = ntpath.basename(idb_path.replace(\".i64\", \"_acfg_features.json\"))\n    with open(os.path.join(output_dir, out_name), \"w\") as f_out:\n        json.dump(output_dict, f_out)\n\n\nif __name__ == '__main__':\n    if not idaapi.get_plugin_options(\"acfg_features\"):\n        print(\"[!] -Oacfg_features option is missing\")\n        idc.Exit(1)\n\n    plugin_options = idaapi.get_plugin_options(\"acfg_features\").split(\":\")\n    if len(plugin_options) != 3:\n        print(\"[!] -Oacfg_features:INPUT_JSON:IDB_PATH:OUTPUT_DIR is required\")\n        idc.Exit(1)\n\n    input_json = plugin_options[0]\n    idb_path = plugin_options[1]\n    output_dir = plugin_options[2]\n\n    with open(input_json) as f_in:\n        selected_functions = json.load(f_in)\n\n    if idb_path not in selected_functions:\n        print(\"[!] Error! IDB path (%s) not in %s\" % (idb_path, input_json))\n        idc.Exit(1)\n\n    fva_list = selected_functions[idb_path]\n    print(\"[D] Found %d addresses\" % len(fva_list))\n\n    run_acfg_features(idb_path, fva_list, output_dir)\n    idc.Exit(0)\n</code></pre> <ol> <li> <p>Andrea Marcelli, Mariano Graziano, Xabier Ugarte-Pedrero, Yanick Fratantonio, Mohamad Mansouri, Davide Balzarotti.  How Machine Learning Is Solving the Binary Function Similarity Problem. USENIX Security '22.\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorials/features/01_block/","title":"Block features","text":"<p>In this 1st part, let's look at how to extract the block features for the paper.</p>"},{"location":"tutorials/features/01_block/#final-snippet","title":"Final snippet","text":"<pre><code>from typing import Dict, Union, List\nimport quokka\n\n# Use the code from arch.py in this repo\n# Originally \n# https://github.com/Cisco-Talos/binary_function_similarity/blob/main/IDA_scripts/IDA_acfg_features/core/architecture.py\nARCH_MNEM = ...\n\nFeaturesDict = Dict[str, Union[int, List[str], List[int]]]\n\ndef get_bb_features(block: quokka.Block) -&gt; FeaturesDict:\n\n    mnemonics = [inst.cs_inst.mnemonic for inst in block.instructions]\n    arch = block.program.isa.name\n\n    return {\n        \"bb_len\": block.size, # (1)!\n        # List features\n        \"bb_numerics\": block.constants, # (2)!\n        \"bb_strings\": block.strings, # (3)!\n        # Numeric features\n        \"n_numeric_consts\": len(block.constants), # (4)!\n        \"n_string_consts\": len(block.strings), # (5)!\n        \"n_instructions\": len(mnemonics), # (6)!\n        \"n_arith_instrs\": sum(\n            1 for m in mnemonics if m in ARCH_MNEM[arch][\"arithmetic\"]  # (7)!\n        ),\n        \"n_call_instrs\": sum(1 for m in mnemonics if m in ARCH_MNEM[arch][\"call\"]),\n        \"n_logic_instrs\": sum(1 for m in mnemonics if m in ARCH_MNEM[arch][\"logic\"]),\n        \"n_transfer_instrs\": sum(\n            1 for m in mnemonics if m in ARCH_MNEM[arch][\"transfer\"]\n        ),\n        \"n_redirect_instrs\": sum(\n            1\n            for m in mnemonics\n            if (m in ARCH_MNEM[arch][\"unconditional\"])\n            or (m in ARCH_MNEM[arch][\"conditional\"])\n            or (m in ARCH_MNEM[arch][\"call\"])\n        ),\n    }\n</code></pre> <ol> <li>First, let's take the len of the block as its size</li> <li>The list of numerics constants used in the block is accessible using the <code>.constants</code> attribute</li> <li>The list of strings found in the block is accessible by <code>.strings</code></li> <li>The number of constants is simply found using the <code>len</code> of the constants list</li> <li>The number of strings is simply found using the <code>len</code> of the strings list</li> <li>We count the number of instruction using the number of the mnemonics in the list.</li> <li>Classify instructions using the <code>ARCH_MNEM</code> mapping provided</li> </ol>"},{"location":"tutorials/features/01_block/#arch_mnem","title":"ARCH_MNEM","text":"<p>This mapping has been created by the paper's authors to classify the instructions in each architecture. For example,  the mnemonic used to touch the stack in <code>ARM</code> are the following:</p> <pre><code>ARCH_MNEM = {}\nARCH_MNEM[\"ARM\"][\"stack\"] = {\n    'pop',\n    'popeq',\n    'popne',\n    'pople',\n    'pophs',\n    'poplt',\n    'push'\n}\n</code></pre>"},{"location":"tutorials/features/01_block/#obtaining-the-mnemonics","title":"Obtaining the mnemonics","text":"<p>If you paid attention to the snippet, this line was used to obtain the mnemonics: <pre><code>...\nmnemonics = [inst.cs_inst.mnemonic for inst in block.instructions]\n...\n</code></pre></p> <p>Why did we use the <code>cs_inst</code> attribute instead of the more simple one <code>mnenomic</code> from the <code>Instruction</code> class?</p> <p>To simply demonstrate the usage of the <code>capstone</code> bindings.</p>"},{"location":"tutorials/features/02_functions/","title":"Functions features","text":""},{"location":"tutorials/features/02_functions/#original-code","title":"Original code","text":"<pre><code># From https://github.com/Cisco-Talos/binary_function_similarity/blob/main/IDA_scripts/IDA_acfg_features/core/ff_features.py#L76\ndef get_function_features(fva, bbs_dict, len_edges):\n    \"\"\"\n    Construction the dictionary with function-level features.\n    Args:\n        fva: function virtual address\n        bbs_dict: a dictionary with all the features, one per BB\n        len_eges: number of edges\n    Return:\n        a dictionary with function-level features\n    \"\"\"\n    f_dict = {\n        'n_func_calls': f_sum(bbs_dict, 'n_call_instrs'),\n        'n_logic_instrs': f_sum(bbs_dict, 'n_logic_instrs'),\n        'n_redirections': f_sum(bbs_dict, 'n_redirect_instrs'),\n        'n_transfer_instrs': f_sum(bbs_dict, 'n_transfer_instrs'),\n        'size_local_variables': get_size_local_vars(fva),\n        'n_bb': len(bbs_dict),\n        'n_edges': len_edges,\n        'n_incoming_calls': get_func_incoming_calls(fva),\n        'n_instructions': f_sum(bbs_dict, 'n_instructions')\n    }\n    return f_dict\n</code></pre>"},{"location":"tutorials/features/02_functions/#quokka-code","title":"Quokka code","text":"<pre><code>import quokka\n\nFeaturesDict = ...\n\ndef sum_block_features(bb_features: FeaturesDict, feature: str) -&gt; int:\n    \"\"\"Sum the values for every basic block in the function\"\"\"\n    assert feature.startswith(\"n_\"), \"Only numeric values can be summed\"\n    return sum(basic_block[feature] for basic_block in bb_features.values())\n\n\ndef get_func_features(func: quokka.Function) -&gt; FeaturesDict:\n    bb_features = {}\n    for block_start in func.graph:\n        block = func.get_block(block_start)\n        bb_features[block_start] = get_bb_features(block)\n\n    return {\n        'n_func_calls': sum_block_features(bb_features, 'n_call_instrs'),\n        'n_logic_instrs': sum_block_features(bb_features, 'n_logic_instrs'),\n        'n_redirections': sum_block_features(bb_features, 'n_redirect_instrs'),\n        'n_transfer_instrs': sum_block_features(bb_features, 'n_transfer_instrs'),\n        'size_local_variables': ..., # Not possible with Quokka\n        'n_bb': len(bb_features),\n        'n_edges': len(func.graph.edges),\n        'n_incoming_calls': len(func.callers),\n        'n_instructions': sum(1 for _ in func.instructions),\n        \"basic_blocks\": bb_features,\n    }\n</code></pre> <p>Et voil\u00e0!</p>"},{"location":"tutorials/features/03_final/","title":"Wrapping up","text":"<p>The two snippets presented in the previous pages can be concatenated in a single extract you can run on your binaries  to get a basic feature extractor.</p> <pre><code>#  Copyright 2022-2023 Quarkslab\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      https://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n\n\"\"\"\nFeature Extractor\n\nThis snippet uses Quokka to extract features from the every function (and block) of the program.\n\nUsage:\n    python ./script &lt;binary_path&gt;\n\nAuthor:\n    Written by dm (Alexis Challande) in 2022.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport sys\nfrom typing import Dict, Union, List\nimport quokka\n\n# Use the code from arch.py in this repo\n# Originally\n# https://github.com/Cisco-Talos/binary_function_similarity/blob/main/IDA_scripts/IDA_acfg_features/core/architecture.py\nARCH_MNEM = ...\n\nFeaturesDict = Dict[str, Union[int, List[str], List[int], \"FeaturesDict\"]]\n\n\ndef get_bb_features(block: quokka.Block) -&gt; FeaturesDict:\n    \"\"\"Extract features from a Basic Block\"\"\"\n\n    mnemonics = [inst.cs_inst.mnemonic for inst in block.instructions]\n    arch = block.program.isa.name\n\n    return {\n        \"bb_len\": block.size,\n        # List features\n        \"bb_numerics\": block.constants,\n        \"bb_strings\": block.strings,\n        # Numeric features\n        \"n_numeric_consts\": len(block.constants),\n        \"n_string_consts\": len(block.strings),\n        \"n_instructions\": len(mnemonics),\n        \"n_arith_instrs\": sum(\n            1 for m in mnemonics if m in ARCH_MNEM[arch][\"arithmetic\"]\n        ),\n        \"n_call_instrs\": sum(1 for m in mnemonics if m in ARCH_MNEM[arch][\"call\"]),\n        \"n_logic_instrs\": sum(1 for m in mnemonics if m in ARCH_MNEM[arch][\"logic\"]),\n        \"n_transfer_instrs\": sum(\n            1 for m in mnemonics if m in ARCH_MNEM[arch][\"transfer\"]\n        ),\n        \"n_redirect_instrs\": sum(\n            1\n            for m in mnemonics\n            if (m in ARCH_MNEM[arch][\"unconditional\"])\n            or (m in ARCH_MNEM[arch][\"conditional\"])\n            or (m in ARCH_MNEM[arch][\"call\"])\n        ),\n    }\n\n\ndef sum_block_features(bb_features: FeaturesDict, feature: str) -&gt; int:\n    \"\"\"Sum the values for every basic block in the function\"\"\"\n    assert feature.startswith(\"n_\"), \"Only numeric values can be summed\"\n    return sum(basic_block[feature] for basic_block in bb_features.values())\n\n\ndef get_func_features(func: quokka.Function) -&gt; FeaturesDict:\n    \"\"\"Extracts features from a Function\"\"\"\n    bb_features = {}\n    for block_start in func.graph:\n        block = func.get_block(block_start)\n        bb_features[block_start] = get_bb_features(block)\n\n    return {\n        \"n_func_calls\": sum_block_features(bb_features, \"n_call_instrs\"),\n        \"n_logic_instrs\": sum_block_features(bb_features, \"n_logic_instrs\"),\n        \"n_redirections\": sum_block_features(bb_features, \"n_redirect_instrs\"),\n        \"n_transfer_instrs\": sum_block_features(bb_features, \"n_transfer_instrs\"),\n        \"size_local_variables\": ...,  # Not possible with Quokka\n        \"n_bb\": len(bb_features),\n        \"n_edges\": len(func.graph.edges),\n        \"n_incoming_calls\": len(func.callers),\n        \"n_instructions\": sum(1 for _ in func.instructions),\n        \"basic_blocks\": bb_features,\n    }\n\n\ndef export_binary(binary: quokka.Program) -&gt; None:\n    \"\"\"Export features from a Program\"\"\"\n\n    prog_features: FeaturesDict = {}\n    for func in binary.values():\n        prog_features[func.start] = get_func_features(func)\n\n    with open(f\"{binary.name}.json\", \"w\") as fp:\n        json.dump(prog_features, fp, indent=True)\n\n\nif __name__ == \"main\":\n    program: quokka.Program = quokka.Program.from_binary(sys.argv[1])\n    export_binary(program)\n</code></pre>"},{"location":"tutorials/features/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Introduction</li> <li>Block features</li> <li>Function features</li> <li>Wrapping up</li> </ul>"},{"location":"tutorials/qb-crackme/00_intro/","title":"Tutorial","text":"<p>This tutorial show some usage Quokka Python API.</p>"},{"location":"tutorials/qb-crackme/00_intro/#run-the-code","title":"Run the code","text":"<p>Info</p> <p>All the code snippets are valid Python / Bash snippet and may be run directly.</p> <p>I suggest installing IPython for an interactive Python terminal with syntax highlighting and auto-completion</p>"},{"location":"tutorials/qb-crackme/00_intro/#step-1-install-quokka","title":"Step 1: Install quokka","text":"<p>Tip</p> <p>It's best to install quokka in a virtualenv.</p> <pre><code>$ pip install pip install git+https://github.com/quarkslab/quokka.git\n</code></pre>"},{"location":"tutorials/qb-crackme/00_intro/#step-2-download-the-binaries-for-the-tutorial","title":"Step 2: Download the binaries for the tutorial","text":"<p>For this tutorial, we will use a simple CrackMe. You can download it here. If you don't have IDA, you will also need the exported file: here.</p>"},{"location":"tutorials/qb-crackme/00_intro/#check","title":"Check","text":"<p>Let's now check that <code>quokka</code> has been installed!</p> <pre><code>$ python -c \"import quokka\"\n</code></pre> <p>If the result is not the following (or any other errors), congrats! <pre><code>Traceback (most recent call last):\n  File \"&lt;string&gt;\", line 1, in &lt;module&gt;\nModuleNotFoundError: No module named 'quokka'\n</code></pre></p>"},{"location":"tutorials/qb-crackme/01_load/","title":"Binary loading","text":"<p>Before doing anything with a <code>quokka</code> file, you need to load it.</p> <p>Tip</p> <p>For the remaining of this tutorial, I will be using an interactive IPython shell.</p> <p>To load a program, <code>quokka</code> needs both the export file and the original  binary. Indeed, to reduce the size of the export, information directly available in the binary are not exported.</p> <pre><code>import quokka\nfrom pathlib import Path\n\nsamples = Path('docs/samples')\nassert samples.is_dir(), \"You should run this code in Quokka main directory\"\n\nprog = quokka.Program(samples / \"qb-crackme.quokka\", samples / \"qb-crackme\")\n\n# Let's check if it worked\nprint(f'Program base address is 0x{prog.base_address:x}')\n# Should print: Program base address is 0x8048000.\n</code></pre>"},{"location":"tutorials/qb-crackme/01_load/#explore-a-bit-the-program-object","title":"Explore a bit the <code>Program</code> object","text":"<p>We now have in <code>prog</code> a complete program representation. Using <code>dir(prog)</code>, you can see the different possibilities.</p> <p>For instance, you can list the strings found in the program using :</p> <pre><code>import quokka\nprog = quokka.Program(\"docs/samples/qb-crackme.quokka\", \"docs/samples/qb-crackme\")\nprint(f\"Found {len(prog.strings)} in {prog.export_file.stem}\")\n</code></pre> <p>Using the protobuf directly</p> <p>Of note, the protobuf generated by the plugin is available in <code>prog.proto</code>. You should not access it directly because it's a rather compact format not  well documented.</p>"},{"location":"tutorials/qb-crackme/01_load/#export-and-load","title":"Export and load","text":"<p>If the IDA plugin has been installed you can also create the exported directly using the convenient method <code>from_binary</code>.</p> <pre><code>import quokka\n\nprog = quokka.Program.from_binary('docs/samples/qb-crackme')\nassert prog is not None, \"Unable to export qb-crackme\"\n</code></pre>"},{"location":"tutorials/qb-crackme/01_load/#tips-tricks","title":"Tips &amp; tricks","text":"<p>By default, IDA will store the database of the exported file next to the binary file. However, this is not convenient when dealing with read only filesystems.  Use the <code>database_file</code> option to control where it should be stored.</p> <pre><code>import quokka\n\nprog = quokka.Program.from_binary('/bin/ls')\n# Will fail because /bin is not writable\nassert prog is None, \"/bin is writable -- this is unusual\"\n\nprog = quokka.Program.from_binary('/bin/ls',\n                                  output_file='docs/samples/ls.quokka',                                      \n                                  database_file='docs/samples/ls.i64')\nassert prog is not None, \"Unable to export ls\"\n</code></pre> <p>The <code>debug</code> parameter of the same method will control the output. One of its  effect is that it will print the exporter output and the command used to launch  it.</p>"},{"location":"tutorials/qb-crackme/02_functions/","title":"Functions","text":"<p>One of the most common binary abstraction level is the <code>function</code>. Thus,  <code>quokka</code> offers nicer way to interact to them (compared to the default IDA API).</p> <p>Prerequisites</p> <p>For this part of the tutorial, I asssume you already have a working  installation of quokka and you already exported <code>qb-crackme</code>.</p>"},{"location":"tutorials/qb-crackme/02_functions/#finding-functions","title":"Finding functions","text":"<pre><code>import quokka\n\nprog: quokka.Program\n\n# First way: accessing a function by its address\nfunc = prog[0x8049000]\nprint(func)\n\n# This is &lt;Function _init_proc at 0x8049000&gt;\n\n# Second solution: by its name\nfunc = prog.fun_names['_init_proc']\n\n# Third: by the get_function method\nprog.get_function(name='_init_pr',  # Something in the name \n                  approximative=True, # Accept non-exact match\n                  normal=True) # Only regular functions\n</code></pre> <p>Function Types ?</p> <p>Binary functions have types in IDA (e.g. NORMAL, THUNK ...). The  <code>get_function</code> method allows to restrict results to the NORMAL one :  functions that are defined inside the program with regular body.</p> <p>The complete list of function types is:</p> Type Definition EXTERN Function defined in an external library IMPORTED NORMAL Regular functions LIBRARY THUNK Thunk functions INVALID Errored type, should not exist <p>The <code>type</code> of a function is accessible through <code>function.type</code> attribute.</p>"},{"location":"tutorials/qb-crackme/02_functions/#the-function-object","title":"The <code>Function</code> object","text":"<p>Like most of the object in <code>quokka</code>, the function object is in itself a mapping.  The keys are the address and the values the corresponding chunks.</p> <p>Info</p> <p>A chunk is an IDA specific concept to deal with code reuse across functions.  A function must have at least one chunk but a chunk may be shared by multiple  functions. See Igor's explanation</p> <p>Warning</p> <p>The direct successors of a function are chunks. However, the interface of  function and chunk is similar and most of  the functions works the same on  the both levels.</p> <p>Example</p> <pre><code>prog: quokka.Program\nfunc = prog.fun_names['_init_proc']\n\nprint(f\"Function {func.name} calls {len(func.calls)} function(s).\")\n# Print: Function _init_proc calls 1 function(s).\n</code></pre>"},{"location":"tutorials/qb-crackme/02_functions/#manipulating-function","title":"Manipulating function","text":"<p>The <code>Function</code> class offers fast accessors to common properties. The snippet  below list some of them : <pre><code>import quokka\n\nprog = quokka.Program('docs/samples/qb-crackme.Quokka', 'docs/samples/qb-crackme')\nfunc = prog.fun_names['level_1']\n\nprint(f'Func {func.name} starts at 0x{func.start:x} and finished at 0x{func.end:x}')\n\n# Print the strings in the function\nprint(func.strings)\n\n# Does the function uses constants ?\nif func.constants:\n    print(f'{func.name} use constants')\n\n# What are the names of the functions called by this one ?\nfor called in func.calls:\n    print(called.name)\n</code></pre></p>"},{"location":"tutorials/qb-crackme/02_functions/#function-cfg","title":"Function CFG","text":"<p>The CFG of the function is accessible through the <code>func.graph</code> attribute.  It is a <code>networkx.DiGraph</code> where the nodes are the blocks (of all the chunks). </p> <p>Warning</p> <p>You must use the <code>get_block</code> method to retrieve a block from a function  object as the dict in itself only refers <code>Chunk</code>.</p>"},{"location":"tutorials/qb-crackme/02_functions/#chunks-super-chunks","title":"Chunks &amp; Super chunks","text":"<p>We already stated that Functions are composed of Chunks, themselves composed of  Basic Blocks. However, the Chunk abstraction is never really used... Thus, most accessors at the function level propagate the requests at the block level.</p>"},{"location":"tutorials/qb-crackme/02_functions/#super-chunks","title":"Super Chunks","text":"<p>Super chunks are an abstraction used to deal with functions have multiple  non-connected subcomponents.</p> <p>A <code>SuperChunk</code> is composed of <code>Chunks</code> itself.</p> <p>To iterate through all the chunks of a program a special method exists :  <code>program.iter_chunk</code>. This method deals with SuperChunks and Functions to enumerate all the chunks  defined in the program.</p>"},{"location":"tutorials/qb-crackme/03_blocks/","title":"Blocks","text":"<p>Blocks are parts of a function. They are in itself dict with a mapping from instruction address to instruction.</p>"},{"location":"tutorials/qb-crackme/03_blocks/#finding-a-block","title":"Finding a block","text":"<pre><code>import quokka\n\n# Load the program and get a function\nprog = quokka.Program('docs/samples/qb-crackme.quokka', 'docs/samples/qb-crackme')\nfunc = prog.fun_names['level_1']\n\nblock_start: int = 0x80494e8\n\n# Method 1 : Get a block through the function\nblock = func.get_block(address=block_start)\n\n# Method 2 : Get a block from an instruction\ninst = prog.get_instruction(block_start)\nblock = inst.parent\n</code></pre>"},{"location":"tutorials/qb-crackme/03_blocks/#block-attributes","title":"Block attributes","text":"<p>It should be no suprise that a <code>Block</code> is also a mapping. Indeed, it holds a mapping from address to Instructions.</p> <p>However, it still has some properties</p>"},{"location":"tutorials/qb-crackme/03_blocks/#cfg","title":"CFG","text":"<p>A block maintains a list of successors and predecessors (from the CFG).</p> <pre><code>successor: int\nfor successor in block.successors:\n   assert(successor in block.parent)\n</code></pre>"},{"location":"tutorials/qb-crackme/03_blocks/#strings-constants-and-comments","title":"Strings, constants and comments","text":"<p>Strings, constants (and other data) are accessible with the eponyms attributes. Moreover, if a comment has been defined in IDA, it is accessible through  <code>comments</code>.</p>"},{"location":"tutorials/qb-crackme/03_blocks/#type","title":"Type","text":"<p>Basic blocks have types in IDA which is exported by <code>quokka</code>. Use <code>block.type</code> to access it.</p>"},{"location":"tutorials/qb-crackme/04_instructions/","title":"Instructions","text":"<p>Instructions are the main component of a program. <code>quokka</code> enables a seamless interaction with them and offers a first-class support for both <code>capstone</code> and  <code>pypcode</code>.</p>"},{"location":"tutorials/qb-crackme/04_instructions/#finding-an-instruction","title":"Finding an instruction","text":"<pre><code>import quokka\nprog = quokka.Program('docs/samples/qb-crackme.quokka', 'docs/samples/qb-crackme')\n\n# Method 1 : from the program by its address\ninst = prog.get_instruction(0x80494e8)\n# print(inst)\n\n# Method 2: by the function\nfunc = prog.fun_names['level1']\ninst = func.get_instruction(0x80494e8)\n\n# Method 3: by the block\nblock = func.get_block(func.start)\ninst = block.get_instruction(0x80494e8)\n</code></pre>"},{"location":"tutorials/qb-crackme/04_instructions/#instructions-attributes","title":"Instructions attributes","text":""},{"location":"tutorials/qb-crackme/04_instructions/#printing-the-mnemonic","title":"Printing the mnemonic","text":"<pre><code>print(inst)              # &lt;Inst push&gt;\nprint(inst.mnemonic)     # push\n</code></pre>"},{"location":"tutorials/qb-crackme/04_instructions/#using-the-capstone-bindings","title":"Using the <code>capstone</code> bindings","text":"<p>If <code>capstone</code> is installed, it's possible to access the capstone object by using <code>inst.cs_inst</code>.</p> <pre><code>print(inst.cs_inst)\n# &lt;CsInsn 0x80494e8 [55]: push ebp&gt;\n</code></pre> <p>With this method, you can access every capstone attributes. For instance, to get the read registers: <pre><code>for reg in inst.cs_inst.regs_read:\n    print(inst.cs_inst.reg_name(reg))\n</code></pre></p>"},{"location":"tutorials/qb-crackme/04_instructions/#mnemonics-and-operands","title":"Mnemonics and operands","text":"<p>The mnemonic is given by IDA and found using <code>instruction.mnemonic</code>.</p> <p>Warning</p> <p>There exists some discrepancies between IDA and Capstone, and they may not agree all the time on the disassembly. <code>quokka</code> tries to fall back to sane values.</p>"},{"location":"tutorials/qb-crackme/04_instructions/#operands","title":"Operands","text":"<p>Error</p> <p>Operands are not fully implemented. Use carefully.</p> <p>The instruction operands are listed in the <code>operands</code> attribute. The fields of the operands are directly replicated from the protobuf (and found  in IDA).</p> <p>The <code>details</code> field replicates some attributes from capstone if needed.</p> <p>Warning</p> <p>At some point, the information extracted from IDA will be unserialized, and it will be possible to fully understand what the fields mean.</p>"},{"location":"tutorials/qb-crackme/05_references/","title":"References","text":"<p>One important element in programs are the relations between different  subcomponents.</p> <p>We denote links between two element as <code>References</code>.</p>"},{"location":"tutorials/qb-crackme/05_references/#reference-types","title":"Reference Types","text":"<p><code>quokka</code> uses several Reference Types listed below that are self-explanatory.</p> Extract of types.py<pre><code>class ReferenceType(enum.Enum):\n    CALL = enum.auto()\n    DATA = enum.auto()\n    ENUM = enum.auto()\n    STRUC = enum.auto()\n    UNKNOWN = enum.auto()\n</code></pre>"},{"location":"tutorials/qb-crackme/05_references/#call-references","title":"Call References","text":"<p>A <code>Call</code> reference is a link from one <code>Instruction</code> to a <code>Chunk</code>. Usually, the mnemonic is something like <code>call</code>.</p> <p>For instance: <pre><code>import quokka\n\nprog = quokka.Program('docs/samples/qb-crackme.quokka', 'docs/samples/qb-crackme')\n\ninst: quokka.Instruction = prog.get_instruction(0x804950f)\ntarget: quokka.Chunk = inst.call_target\nprint(f\"Inst {inst} calls `{target.name}`\")\n# Inst &lt;call 0x8049270&gt; calls `get_input`\n</code></pre></p>"},{"location":"tutorials/qb-crackme/05_references/#data-references","title":"Data References","text":"<p>Sometimes, instruction manipulates <code>Data</code>.</p> <pre><code>import quokka\nprog = quokka.Program('docs/samples/qb-crackme.quokka', 'docs/samples/qb-crackme')\n\ninst = prog.get_instruction(0x8049287)\nprint(inst.cs_inst)\n# &lt;CsInsn 0x8049287 [a140e00408]: mov eax, dword ptr [0x804e040]&gt;\n\nfor data in inst.data_references:\n    print(f\"{data.type}: {data.address} {data.value}\")\n    # DataType.DOUBLE_WORD : 0x804e040 None\n</code></pre>"},{"location":"tutorials/qb-crackme/05_references/#reference-manager","title":"Reference Manager","text":"<p>Every Reference is stored in the Reference Manager. The API is not yet  stabilized and the Reference Manager should not be used directly.</p> <pre><code>import quokka\nprog = quokka.Program('docs/samples/qb-crackme.quokka', 'docs/samples/qb-crackme')\n\n# To list every call to a `Chunk`\nfunc = prog.fun_names[\"get_input\"]\nchunk = func[func.start]\nprog.references.resolve_calls(chunk)\n</code></pre>"},{"location":"tutorials/qb-crackme/06_other/","title":"Structures","text":"<p>Structures exported from IDA are found in <code>program.structures</code>. A structure is  composed of his members and most of all the information found in IDA are extracted.</p> <p>Note</p> <p><code>Unions</code>, <code>enums</code> and <code>structures</code> are all merged into the more generic  term structure in Quokka. The structure type is found in <code>structure.type</code>.</p>"},{"location":"tutorials/qb-crackme/06_other/#segments","title":"Segments","text":"<p>The segments exported from IDA are available under <code>program.segments</code></p>"},{"location":"tutorials/qb-crackme/06_other/#strings","title":"Strings","text":"<p>All the strings of the binary are also listed in <code>program.strings</code>.</p>"},{"location":"tutorials/qb-crackme/06_other/#executable","title":"Executable","text":"<p>The executable file is best dealt with the <code>program.executable</code> attribute.  Methods are provided to read from the  file content at both absolute and  relative address.</p>"},{"location":"tutorials/qb-crackme/07_solving/","title":"Solving the crackme","text":"<p>As you have already seen, the sample we use since the beginning of this tutorial is a (simple) crackme. </p> <p>Let's try to see how we can start to solve it with <code>quokka</code>.</p>"},{"location":"tutorials/qb-crackme/07_solving/#finding-the-challenges","title":"Finding the challenges","text":"<pre><code>import quokka\n\nprog = quokka.Program('docs/samples/qb-crackme.Quokka', 'docs/samples/qb-crackme')\n\n# Get the functions name\nfor func in prog.fun_names:\n    if func.startswith(\"level\"):\n        print(prog.fun_names[func])\n</code></pre> <p>It yields to the following results! <pre><code>&lt;Function level0 at 0x80492bc&gt;\n&lt;Function level1 at 0x80494e8&gt;\n&lt;Function level2 at 0x8049568&gt;\n&lt;Function level3 at 0x80495c3&gt;\n&lt;Function level4 at 0x80496f0&gt;\n&lt;Function level5 at 0x804980c&gt;\n&lt;Function level6 at 0x804987e&gt;\n&lt;Function level7 at 0x80499af&gt;\n&lt;Function level8 at 0x8049b69&gt;\n&lt;Function level9 at 0x8049cfe&gt;\n</code></pre></p> <p>Great, we have about 10 levels to solve. Let start by the first one.</p>"},{"location":"tutorials/qb-crackme/07_solving/#level-0","title":"Level 0","text":"<p>First, get the function: <pre><code>func = prog.fun_names[\"level0\"]\n</code></pre></p> <p>Then, let's examine it: <pre><code># Get the size\nprint(len(func)) # 1 Chunk\nprint(len(func[func.start])) # 7 basic blocks\n</code></pre></p> <p>We see that the functions have 3 strings: <pre><code>for str in func.strings:\n    print(str)\n</code></pre></p> <pre><code>0;-LS|iX|:rlAy1ZWr;|+Ab1S3},IV.z*t:%|pHyY_9&amp;AuW*.jJX`&lt;5]z{nB``mEdntH5f#`n={JPGLF0r&gt;ua!ObZE?y.VjfpsZ6rTvD|Y--9E~AXeuY9I2&amp;[iNTIr^]!%dAu-m82$CF#[of+]7RcgdKd.W&amp;~D01j^fI}=Cda+7W)zg:m1[=!]JdiUaq({@H:)+/JZ.z0(!?ekIV55oq-6an3Ag8o)5k-mu,RH1z7fSy:s@K4oQ.TkYg7^i\nF00d1e\nWhat's the flag?\n</code></pre> <p>And it's calling 3 functions: <pre><code>for chunk in func.calls:\n    print(chunk.name)\n</code></pre></p> <pre><code>get_input\n_strlen\n_strlen\n</code></pre> <p>Let's now print the disassembly of the first block to understand what's happening:</p> <pre><code>for inst in func.get_block(func.start):\n    print(inst.cs_inst)\n</code></pre> <pre><code>&lt;CsInsn 0x80492bc [55]: push ebp&gt;\n&lt;CsInsn 0x80492bd [89e5]: mov ebp, esp&gt;\n&lt;CsInsn 0x80492bf [81ec28020000]: sub esp, 0x228&gt;\n&lt;CsInsn 0x80492c5 [c745ec88b00408]: mov dword ptr [ebp - 0x14], 0x804b088&gt;\n&lt;CsInsn 0x80492cc [c745e88fb00408]: mov dword ptr [ebp - 0x18], 0x804b08f&gt;\n&lt;CsInsn 0x80492d3 [83ec04]: sub esp, 4&gt;\n&lt;CsInsn 0x80492d6 [8d85dcfdffff]: lea eax, [ebp - 0x224]&gt;\n&lt;CsInsn 0x80492dc [50]: push eax&gt;\n&lt;CsInsn 0x80492dd [ff75e8]: push dword ptr [ebp - 0x18]&gt;\n&lt;CsInsn 0x80492e0 [ff75ec]: push dword ptr [ebp - 0x14]&gt;\n&lt;CsInsn 0x80492e3 [e888ffffff]: call 0x8049270&gt;\n&lt;CsInsn 0x80492e8 [83c410]: add esp, 0x10&gt;\n&lt;CsInsn 0x80492eb [c745e4a0b00408]: mov dword ptr [ebp - 0x1c], 0x804b0a0&gt;\n&lt;CsInsn 0x80492f2 [83ec0c]: sub esp, 0xc&gt;\n&lt;CsInsn 0x80492f5 [ff75e4]: push dword ptr [ebp - 0x1c]&gt;\n&lt;CsInsn 0x80492f8 [e863fdffff]: call 0x8049060&gt;\n&lt;CsInsn 0x80492fd [83c410]: add esp, 0x10&gt;\n&lt;CsInsn 0x8049300 [8945e0]: mov dword ptr [ebp - 0x20], eax&gt;\n&lt;CsInsn 0x8049303 [83ec0c]: sub esp, 0xc&gt;\n&lt;CsInsn 0x8049306 [8d85dcfdffff]: lea eax, [ebp - 0x224]&gt;\n&lt;CsInsn 0x804930c [50]: push eax&gt;\n&lt;CsInsn 0x804930d [e84efdffff]: call 0x8049060&gt;\n&lt;CsInsn 0x8049312 [83c410]: add esp, 0x10&gt;\n&lt;CsInsn 0x8049315 [8945dc]: mov dword ptr [ebp - 0x24], eax&gt;\n&lt;CsInsn 0x8049318 [c745f400000000]: mov dword ptr [ebp - 0xc], 0&gt;\n&lt;CsInsn 0x804931f [c745f0c8000000]: mov dword ptr [ebp - 0x10], 0xc8&gt;\n&lt;CsInsn 0x8049326 [eb2c]: jmp 0x8049354&gt;\n</code></pre> <p>We find the three calls we already saw.</p> <p>Note</p> <p>Since we are using <code>capstone</code> disassembly here, we don't resolve the call target. However, using <code>func.get_instruction(0x80492e3).call_target.name</code> allows us to recover it!</p> <p>Let's examine this extract: <pre><code>&lt;CsInsn 0x80492eb [c745e4a0b00408]: mov dword ptr [ebp - 0x1c], 0x804b0a0&gt;\n[...]\n&lt;CsInsn 0x80492f5 [ff75e4]: push dword ptr [ebp - 0x1c]&gt;\n&lt;CsInsn 0x80492f8 [e863fdffff]: call 0x8049060&gt;\n</code></pre></p> <p>We load a data and push it on the stack before calling a function. We can ask <code>quokka</code> to help us to identify the calling convention used by the  binary in two ways:  <pre><code>from quokka.analysis import Environment, Platform\n\nenv = Environment(Platform.LINUX, prog.arch)\nprint(env.calling_convention)\n\n# Or ask IDA\n# This uses the protobuf directly because no accessor is yet available.\nprint(prog.proto.meta.calling_convention)\n</code></pre></p> <p>In <code>cdecl</code>, arguments are pushed on the stack. So, we see that the argument of the <code>strlen</code> call is the data loaded from memory.</p> <pre><code>inst = func.get_instruction(0x80492eb)\nprint(inst.string)\n</code></pre> <p>The argument used by the second call at <code>strlen</code> is the result of the <code>get_input</code> function.</p> <p>Let's consider the next block: <pre><code>first = func.get_block(func.start)\nnext_block = func.get_block(next(first.successors()))\n</code></pre></p> <p>We know there is only one successor because either : - the first block disassembly ends with an unconditional jump - <code>func.graph[first.start]</code> lists an Unconditional Edge - <code>sum(1 for _ in first.successors())</code> is 1</p> <p>Our new block has two predecessors: we are in a loop! <pre><code>list(next_block.predecessors())\n</code></pre></p> <p>From now on, we can just navigate in the CFG and see what are the conditions to complete to solve the level.</p>"},{"location":"tutorials/qb-crackme/07_solving/#final-words","title":"Final words","text":"<p>This toy example is maybe not the best display on why <code>quokka</code> could be useful, but highlights some possibilities.</p>"},{"location":"tutorials/qb-crackme/SUMMARY/","title":"SUMMARY","text":"<ul> <li>0 - Introduction</li> <li>1 - Loading</li> <li>2 - Functions</li> <li>3 - Blocks</li> <li>4 - Instructions</li> <li>5 - References</li> <li>6 - Others</li> <li>7 - Going further</li> </ul>"}]}