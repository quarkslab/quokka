{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Quokka: A Fast and Accurate Binary Exporter Introduction Quokka is a binary exporter: from the disassembly of a program, it generates an export file that can be used without the disassembler. The main objective of Quokka is to enable to completely manipulate the binary without ever opening a disassembler after the initial step. Moreover, it abstracts the disassembler's API to expose a clean interface to the users. Quokka is heavily inspired by BinExport , the binary exporter used by BinDiff. Installation Python plugin The plugin is built in the CI and available in the registry . It should be possible to install directly from PIP using this kind of commmand: $ pip install quokka-project IDA Plugin Note: The IDA plugin is not needed to read a Quokka generated file. It is only used to generate them. The plugin is built on the CI and available in the Release . To download the plugin, get the file named quokka_plugin**.so . Usage Export a file Note This requires a working IDA installation. Either using command line: $ idat64 -OQuokkaAuto:true -A /path/to/hello.i64 Note: We are using idat64 and not ida64 to increase the export speed because we don't need the graphical interface. Using the plugin shortcut inside IDA: (by default) Alt+A Load an export file import quokka # Directly from the binary (requires the IDA plugin to be installed) ls = quokka . Program . from_binary ( \"/bin/ls\" ) # From the exported file ls = quokka . Program ( \"ls.quokka\" , # the exported file \"/bin/ls\" ) # the original binary Building Build user@host:~/quokka$ cmake -B build \\ # Where to build -S . \\ # Where are the sources -DIdaSdk_ROOT_DIR:STRING=path/to/ida_sdk \\ # Path to IDA SDK -DIda_BIN_DIR:STRING=/path/to/ida/dir \\ # Path to IDA -DCMAKE_BUILD_TYPE:STRING=Release \\ # Build Type -DBUILD_TEST:BOOL=OFF # Don't build the tests user@host:~/quokka$ cmake --build build --target quokka_plugin -- -j To install the plugin: user@host:~/quokka$ cmake --install build In any case, the plugin will also be in build/quokka-install . You can copy it to Ida plugin directory. user@host:~/quokka$ cp build/quokka-install/quokka*64.so $IDA_BIN_DIR /plugins/ For more detailed information about building, see Building","title":"Home"},{"location":"#quokka-a-fast-and-accurate-binary-exporter","text":"","title":"Quokka: A Fast and Accurate Binary Exporter"},{"location":"#introduction","text":"Quokka is a binary exporter: from the disassembly of a program, it generates an export file that can be used without the disassembler. The main objective of Quokka is to enable to completely manipulate the binary without ever opening a disassembler after the initial step. Moreover, it abstracts the disassembler's API to expose a clean interface to the users. Quokka is heavily inspired by BinExport , the binary exporter used by BinDiff.","title":"Introduction"},{"location":"#installation","text":"","title":"Installation"},{"location":"#python-plugin","text":"The plugin is built in the CI and available in the registry . It should be possible to install directly from PIP using this kind of commmand: $ pip install quokka-project","title":"Python plugin"},{"location":"#ida-plugin","text":"Note: The IDA plugin is not needed to read a Quokka generated file. It is only used to generate them. The plugin is built on the CI and available in the Release . To download the plugin, get the file named quokka_plugin**.so .","title":"IDA Plugin"},{"location":"#usage","text":"","title":"Usage"},{"location":"#export-a-file","text":"Note This requires a working IDA installation. Either using command line: $ idat64 -OQuokkaAuto:true -A /path/to/hello.i64 Note: We are using idat64 and not ida64 to increase the export speed because we don't need the graphical interface. Using the plugin shortcut inside IDA: (by default) Alt+A","title":"Export a file"},{"location":"#load-an-export-file","text":"import quokka # Directly from the binary (requires the IDA plugin to be installed) ls = quokka . Program . from_binary ( \"/bin/ls\" ) # From the exported file ls = quokka . Program ( \"ls.quokka\" , # the exported file \"/bin/ls\" ) # the original binary","title":"Load an export file"},{"location":"#building","text":"","title":"Building"},{"location":"#build","text":"user@host:~/quokka$ cmake -B build \\ # Where to build -S . \\ # Where are the sources -DIdaSdk_ROOT_DIR:STRING=path/to/ida_sdk \\ # Path to IDA SDK -DIda_BIN_DIR:STRING=/path/to/ida/dir \\ # Path to IDA -DCMAKE_BUILD_TYPE:STRING=Release \\ # Build Type -DBUILD_TEST:BOOL=OFF # Don't build the tests user@host:~/quokka$ cmake --build build --target quokka_plugin -- -j To install the plugin: user@host:~/quokka$ cmake --install build In any case, the plugin will also be in build/quokka-install . You can copy it to Ida plugin directory. user@host:~/quokka$ cp build/quokka-install/quokka*64.so $IDA_BIN_DIR /plugins/ For more detailed information about building, see Building","title":"Build"},{"location":"FAQ/","text":"FAQ What is quokka ? quokka is a tool to manipulate the exported versions of your program. The goal is to have an easy to understand, stable and scalable API to query the (disassembled) binary without relying on having IDA running in the background nor interacting with its API. As a bonus, once a binary has been exported, you can close IDA and work only with the exported file. Why not use directly IDA API ? IDA API has at least two drawbacks (for me) : you will need to learn its syntax and how it works: # IDA way inst = ida_ua . insn_t () ida_ua . decode_insn ( inst , 0xABCD ) print ( inst . get_canon_mnem ()) ## Quokka inst = program . get_instruction ( 0xABCD ) print ( inst . mnemonic ) How does quokka works ? In short, it will write everything to a serialized binary format (namely protobuf). What is exported ? You may have a look at the protobuf format definition to understand exactly what is exported but the list here can give you a nice overview. Exported features: Meta information (file hash, name, detected compiler, calling convention) Segments Structures (structs, enumerations and unions) Comments (every comments attached to anything) Layout (where is the code/data/unknown) Functions and their associated Control Flow Graph Call Graph Instructions (and their operands / mnemonics) References (data and code xref) Data (bytes, strings, ...) What is not exported ? Pretty much everything else but I think the most important here is the type information. It will be a nice addition but that's not the best part of IDA API. What are the trade-off ? TODO(dm) Contributing Every PR is welcome. Where to start ? Grep the code for TODO, some are easy, some require more understanding of the code. Tips During development, you may want to use a soft link in the plugin directory coupled with the option to unload the plugin PLUGIN_UNL user@host:~/quokka/$ ln -sf $( pwd ) build/src/quokka*64.so \\ /opt/ida/plugins/","title":"FAQ"},{"location":"FAQ/#faq","text":"","title":"FAQ"},{"location":"FAQ/#what-is-quokka","text":"quokka is a tool to manipulate the exported versions of your program. The goal is to have an easy to understand, stable and scalable API to query the (disassembled) binary without relying on having IDA running in the background nor interacting with its API. As a bonus, once a binary has been exported, you can close IDA and work only with the exported file.","title":"What is quokka ?"},{"location":"FAQ/#why-not-use-directly-ida-api","text":"IDA API has at least two drawbacks (for me) : you will need to learn its syntax and how it works: # IDA way inst = ida_ua . insn_t () ida_ua . decode_insn ( inst , 0xABCD ) print ( inst . get_canon_mnem ()) ## Quokka inst = program . get_instruction ( 0xABCD ) print ( inst . mnemonic )","title":"Why not use directly IDA API ?"},{"location":"FAQ/#how-does-quokka-works","text":"In short, it will write everything to a serialized binary format (namely protobuf).","title":"How does quokka works ?"},{"location":"FAQ/#what-is-exported","text":"You may have a look at the protobuf format definition to understand exactly what is exported but the list here can give you a nice overview.","title":"What is exported ?"},{"location":"FAQ/#exported-features","text":"Meta information (file hash, name, detected compiler, calling convention) Segments Structures (structs, enumerations and unions) Comments (every comments attached to anything) Layout (where is the code/data/unknown) Functions and their associated Control Flow Graph Call Graph Instructions (and their operands / mnemonics) References (data and code xref) Data (bytes, strings, ...)","title":"Exported features:"},{"location":"FAQ/#what-is-not-exported","text":"Pretty much everything else but I think the most important here is the type information. It will be a nice addition but that's not the best part of IDA API.","title":"What is not exported ?"},{"location":"FAQ/#what-are-the-trade-off","text":"TODO(dm)","title":"What are the trade-off ?"},{"location":"FAQ/#contributing","text":"Every PR is welcome.","title":"Contributing"},{"location":"FAQ/#where-to-start","text":"Grep the code for TODO, some are easy, some require more understanding of the code.","title":"Where to start ?"},{"location":"FAQ/#tips","text":"During development, you may want to use a soft link in the plugin directory coupled with the option to unload the plugin PLUGIN_UNL user@host:~/quokka/$ ln -sf $( pwd ) build/src/quokka*64.so \\ /opt/ida/plugins/","title":"Tips"},{"location":"contributing/","text":"Development - Contributing Developing Clone the repository and install it in a virtualenv in an editable mode with the developers dependencies. $ python -m venv env $ source ./env/bin/activate $ cd quokka (env) $ pip install -e '.[dev]' (env) $ python -c \"import quokka; print(quokka.__version__)\" Format the code The project use the black formatter for the Python code with the defaults settings. Running Black (env) $ black bindings/python/ The C++ code is formatted using clang-format . Updating the Protobuf definition To update the Protobuf definition, follow this steps: <!> IMPORTANT <!> Open an issue on the official repository Update the proto/quokka.proto file with the new fields Increase the version number in CMakeLists.txt by : A major version if the change breaks backward compatibility A minor version otherwise Write the exporter code Update the python bindings accordingly Update the __quokka_version__ in bindings/python/__init__.py to match the one in step 3. Update the protobuf generated files for python using: python setup.py generate_py_protobufs Add a new IDA Version / SDK Add an image with the new IDA Version For example, using Version 7.7 : Go to ci Copy installer to ci/ida77/ida.run (Optional) Copy ~/.idapro/ida.reg to ci/ida77/ida.reg (Optional) Add the installation password in a file to remember it for next time Build the image $ docker build --file build.dockerfile \\ --build-arg IDA_DIRECTORY = ida77 \\ --build-arg IDA_PASSWORD = <install password> \\ . (Optional). If you did not copy a ida.reg file, you should run the container first, open IDA ( /opt/ida/idat64 ), accept the license and save the container (using docker commit ). Add the SDK in the repo Download the SDK from HexRays website Extract it Generate a password for the SDK archive. Compress the inner idasdk77/ directory in an archive protected by the password. Add the idasdk77.zip to the repository. Other tips and tricks Read the Dev's Tips & Tricks page!","title":"Contributing"},{"location":"contributing/#development-contributing","text":"","title":"Development - Contributing"},{"location":"contributing/#developing","text":"Clone the repository and install it in a virtualenv in an editable mode with the developers dependencies. $ python -m venv env $ source ./env/bin/activate $ cd quokka (env) $ pip install -e '.[dev]' (env) $ python -c \"import quokka; print(quokka.__version__)\"","title":"Developing"},{"location":"contributing/#format-the-code","text":"The project use the black formatter for the Python code with the defaults settings. Running Black (env) $ black bindings/python/ The C++ code is formatted using clang-format .","title":"Format the code"},{"location":"contributing/#updating-the-protobuf-definition","text":"To update the Protobuf definition, follow this steps: <!> IMPORTANT <!> Open an issue on the official repository Update the proto/quokka.proto file with the new fields Increase the version number in CMakeLists.txt by : A major version if the change breaks backward compatibility A minor version otherwise Write the exporter code Update the python bindings accordingly Update the __quokka_version__ in bindings/python/__init__.py to match the one in step 3. Update the protobuf generated files for python using: python setup.py generate_py_protobufs","title":"Updating the Protobuf definition"},{"location":"contributing/#add-a-new-ida-version-sdk","text":"","title":"Add a new IDA Version / SDK"},{"location":"contributing/#add-an-image-with-the-new-ida-version","text":"For example, using Version 7.7 : Go to ci Copy installer to ci/ida77/ida.run (Optional) Copy ~/.idapro/ida.reg to ci/ida77/ida.reg (Optional) Add the installation password in a file to remember it for next time Build the image $ docker build --file build.dockerfile \\ --build-arg IDA_DIRECTORY = ida77 \\ --build-arg IDA_PASSWORD = <install password> \\ . (Optional). If you did not copy a ida.reg file, you should run the container first, open IDA ( /opt/ida/idat64 ), accept the license and save the container (using docker commit ).","title":"Add an image with the new IDA Version"},{"location":"contributing/#add-the-sdk-in-the-repo","text":"Download the SDK from HexRays website Extract it Generate a password for the SDK archive. Compress the inner idasdk77/ directory in an archive protected by the password. Add the idasdk77.zip to the repository.","title":"Add the SDK in the repo"},{"location":"contributing/#other-tips-and-tricks","text":"Read the Dev's Tips & Tricks page!","title":"Other tips and tricks"},{"location":"dev/","text":"Devs Tips & Tricks Debug the Plugin First, generate a debug build using the option CMAKE_BUILD_TYPE=Debug . This will decrease the performances but allow to debug the plugin easily. Setup for CLion It is possible to perform a step-by-step debug of the plugin while running with IDA. The following steps are using CLion but are adaptable for other IDEs. First, configure the Profiles for the project. The two most important options are the SDK Root directory and the IDA bin directory. Create a Run/Debug configuration Set the target to quokka_plugin Set the executable to be your idat file Set arguments (the same you would use on the command line) Add some environment variables: IDALOG=/path/to/file Save the IDA's output in a file TVHEADLESS=1 - Improve the speed Set Build and Install as action before launch. If you set a breakpoint in the code, you can now debug your plugin by simply running Debug in CLion interface. Use Sanitizers By using the ENABLE_SANITIZERS option in CMake , you enable ASan . Of note, to run with IDA, you need to specify the path to Asan using LD_PRELOAD . Running Tests For the plugin The C++ tests are at best lackluster but the framework is here to improve them. To compile tests: user@host:~/quokka$ cmake -B build-tests \\ # Where to build -S . \\ # Where are the sources -DIdaSdk_ROOT_DIR:STRING=path/to/ida_sdk \\ # Path to IDA SDK -DIda_BIN_DIR:STRING=/path/to/ida/dir \\ # Path to IDA -DCMAKE_BUILD_TYPE:STRING=Debug \\ # Build Type -DBUILD_TEST:BOOL=On For the Python bindings The tests for the Python bindings are also limited but can be improved. To run them, use the following command. user@host:~/quokka$ pytest tests/python","title":"Tips & Tricks"},{"location":"dev/#devs-tips-tricks","text":"","title":"Devs Tips &amp; Tricks"},{"location":"dev/#debug-the-plugin","text":"First, generate a debug build using the option CMAKE_BUILD_TYPE=Debug . This will decrease the performances but allow to debug the plugin easily.","title":"Debug the Plugin"},{"location":"dev/#setup-for-clion","text":"It is possible to perform a step-by-step debug of the plugin while running with IDA. The following steps are using CLion but are adaptable for other IDEs. First, configure the Profiles for the project. The two most important options are the SDK Root directory and the IDA bin directory. Create a Run/Debug configuration Set the target to quokka_plugin Set the executable to be your idat file Set arguments (the same you would use on the command line) Add some environment variables: IDALOG=/path/to/file Save the IDA's output in a file TVHEADLESS=1 - Improve the speed Set Build and Install as action before launch. If you set a breakpoint in the code, you can now debug your plugin by simply running Debug in CLion interface.","title":"Setup for CLion"},{"location":"dev/#use-sanitizers","text":"By using the ENABLE_SANITIZERS option in CMake , you enable ASan . Of note, to run with IDA, you need to specify the path to Asan using LD_PRELOAD .","title":"Use Sanitizers"},{"location":"dev/#running-tests","text":"","title":"Running Tests"},{"location":"dev/#for-the-plugin","text":"The C++ tests are at best lackluster but the framework is here to improve them. To compile tests: user@host:~/quokka$ cmake -B build-tests \\ # Where to build -S . \\ # Where are the sources -DIdaSdk_ROOT_DIR:STRING=path/to/ida_sdk \\ # Path to IDA SDK -DIda_BIN_DIR:STRING=/path/to/ida/dir \\ # Path to IDA -DCMAKE_BUILD_TYPE:STRING=Debug \\ # Build Type -DBUILD_TEST:BOOL=On","title":"For the plugin"},{"location":"dev/#for-the-python-bindings","text":"The tests for the Python bindings are also limited but can be improved. To run them, use the following command. user@host:~/quokka$ pytest tests/python","title":"For the Python bindings"},{"location":"example/","text":"Examples Finding the string difference between two functions import quokka # Let's get interested in this patch for the CVE-2018-9555: # https://android.googlesource.com/platform/system/bt/+/02fc52878d8dba16b860fbdf415b6e4425922b2c%5E%21/#F0 # Load the vuln program using its export vuln = quokka . Program ( 'vuln.Quokka' , 'vuln_bluetooth.so' ) # Load the fix program using its export fix = quokka . Program ( 'fix.Quokka' , 'fix_bluetooth.so' ) # Assume we know that the patched function is \"l2c_lcc_proc_pdu\" vuln_function = vuln . get_function ( \"l2c_lcc_proc_pdu\" , approximative = True ) fix_function = fix . get_function ( \"l2c_lcc_proc_pdu\" , approximative = True ) assert ( vuln_function and fix_function ) # Vuln functions strings vuln_strings = vuln_function . strings fix_strings = fix_function . strings diff_strings = [ x for x in fix_strings if x not in vuln_strings ] print ( diff_strings ) # Output : ['%s: Invalid sdu_length: %d', '112321180'] # Nice ! Indeed, the \"112321180\" is actually the android bug id that is added during the patch # Extract from the patch: # # + L2CAP_TRACE_ERROR(\"%s: Invalid sdu_length: %d\", __func__, sdu_length); # + android_errorWriteWithInfoLog(0x534e4554, \"112321180\", -1, NULL, 0);","title":"Examples"},{"location":"example/#examples","text":"","title":"Examples"},{"location":"example/#finding-the-string-difference-between-two-functions","text":"import quokka # Let's get interested in this patch for the CVE-2018-9555: # https://android.googlesource.com/platform/system/bt/+/02fc52878d8dba16b860fbdf415b6e4425922b2c%5E%21/#F0 # Load the vuln program using its export vuln = quokka . Program ( 'vuln.Quokka' , 'vuln_bluetooth.so' ) # Load the fix program using its export fix = quokka . Program ( 'fix.Quokka' , 'fix_bluetooth.so' ) # Assume we know that the patched function is \"l2c_lcc_proc_pdu\" vuln_function = vuln . get_function ( \"l2c_lcc_proc_pdu\" , approximative = True ) fix_function = fix . get_function ( \"l2c_lcc_proc_pdu\" , approximative = True ) assert ( vuln_function and fix_function ) # Vuln functions strings vuln_strings = vuln_function . strings fix_strings = fix_function . strings diff_strings = [ x for x in fix_strings if x not in vuln_strings ] print ( diff_strings ) # Output : ['%s: Invalid sdu_length: %d', '112321180'] # Nice ! Indeed, the \"112321180\" is actually the android bug id that is added during the patch # Extract from the patch: # # + L2CAP_TRACE_ERROR(\"%s: Invalid sdu_length: %d\", __func__, sdu_length); # + android_errorWriteWithInfoLog(0x534e4554, \"112321180\", -1, NULL, 0);","title":"Finding the string difference between two functions"},{"location":"features/","text":"Features Quokka exports as much information from IDA as possible. The table below list the main exported elements. Exported elements Feature Exported Metadata Name Architecture ISA Compiler Layout Segments Code Layout Symbols Name Value Type Data Address Type Size Name Graphs Call Graph CFG Comments Address Type Content Functions Name Type Boundaries Instructions Mnemonic Operand Operand Type Bytes Address Expressions XRef (code, data) Basic Block Address Instructions Type Content Strings Address Content Data Structures Structures Enumerations Other features To ease Quokka usage in various worfklows, the tool also provides several additional features: Multiple export modes Capstone integration Pypcode integration","title":"Features"},{"location":"features/#features","text":"Quokka exports as much information from IDA as possible. The table below list the main exported elements.","title":"Features"},{"location":"features/#exported-elements","text":"Feature Exported Metadata Name Architecture ISA Compiler Layout Segments Code Layout Symbols Name Value Type Data Address Type Size Name Graphs Call Graph CFG Comments Address Type Content Functions Name Type Boundaries Instructions Mnemonic Operand Operand Type Bytes Address Expressions XRef (code, data) Basic Block Address Instructions Type Content Strings Address Content Data Structures Structures Enumerations","title":"Exported elements"},{"location":"features/#other-features","text":"To ease Quokka usage in various worfklows, the tool also provides several additional features: Multiple export modes Capstone integration Pypcode integration","title":"Other features"},{"location":"installation/","text":"Installation Python Bindings System requirements python 3.9 is required. It should also work with higher versions and is regularly developed with python 3.10. Note While the IDA plugin requires Linux, the Python bindings should also work on other architectures. However, it has not yet been tested. Installation Using PIP $ pip install quokka-project Using the sources To have the latest version, you can directly download the source from GitHub and install it locally. $ git clone git@github.com:quarkslab/quokka.git $ cd quokka $ python -m venv .quokka-env $ source .quokka-env/bin/activate (.quokka-env) $ pip install . Note The previous snippet creates a virtualenv, which is a good practice to manage Python dependencies. Using a CI wheel CI wheels are available directly on the CI Final checks To check the installation worked, run the following commands: $ source .quokka-env/bin/activate (.quokka-env) $ python -c 'import quokka; print(quokka.__version__)' IDA Plugin Requirements IDA Plugin Warning The plugin support for Windows is experimental. From the CI The plugin is built on the CI and available in the Release . To download the plugin, get the file named quokka_plugin**.so . Building Requirements : CMake (at least 3.13) A reasonable modern compiler supporting at least Cxx17 IDA Sdk (version 7.7) 64 bits IDA (7.7 and higher) Standard build The first step is to download the sources. You can clone the repository like in here To compile quokka , you first need to generate the configuration using CMake . user@host:~$ cd quokka user@host:~/quokka$ cmake -B build \\ # Where to build -S . \\ # Where are the sources -DIdaSdk_ROOT_DIR:STRING=path/to/ida_sdk \\ # Path to IDA SDK -DCMAKE_BUILD_TYPE:STRING=Release # Build Type If the first step succeeded, you can now do the actual building. user@host:~/quokka$ cmake --build build --target quokka_plugin -- -j # use as many core as possible Build On Windows Warning This is only experimental. Requirements This procedure has only been tested with using a Windows Dev Machine : Windows 11 Entreprise Visual Studio 2022 Community Edition Git version 2.37.3 (to download Abseil) cmake version 3.24.1 Optional: - ccache v4.6.3 Steps Configure the plugin console PS C:\\Users\\User\\quokka> cmake -B build -S . -DIdaSdk_ROOT_DIR=third_party/idasdk80 -A x64 Perform the build PS C:\\Users\\User\\quokka> cmake --build build --target quokka_plugin --config Release Cross your fingers and hope. Quokka for Windows is experimental and not tested. There are known issues with older Visual Studio versions and Ninja. Feel free to report any bug.","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#python-bindings","text":"","title":"Python Bindings"},{"location":"installation/#system-requirements","text":"python 3.9 is required. It should also work with higher versions and is regularly developed with python 3.10. Note While the IDA plugin requires Linux, the Python bindings should also work on other architectures. However, it has not yet been tested.","title":"System requirements"},{"location":"installation/#installation_1","text":"","title":"Installation"},{"location":"installation/#using-pip","text":"$ pip install quokka-project","title":"Using PIP"},{"location":"installation/#using-the-sources","text":"To have the latest version, you can directly download the source from GitHub and install it locally. $ git clone git@github.com:quarkslab/quokka.git $ cd quokka $ python -m venv .quokka-env $ source .quokka-env/bin/activate (.quokka-env) $ pip install . Note The previous snippet creates a virtualenv, which is a good practice to manage Python dependencies.","title":"Using the sources"},{"location":"installation/#using-a-ci-wheel","text":"CI wheels are available directly on the CI","title":"Using a CI wheel"},{"location":"installation/#final-checks","text":"To check the installation worked, run the following commands: $ source .quokka-env/bin/activate (.quokka-env) $ python -c 'import quokka; print(quokka.__version__)'","title":"Final checks"},{"location":"installation/#ida-plugin","text":"","title":"IDA Plugin"},{"location":"installation/#requirements","text":"","title":"Requirements"},{"location":"installation/#ida-plugin_1","text":"Warning The plugin support for Windows is experimental.","title":"IDA Plugin"},{"location":"installation/#from-the-ci","text":"The plugin is built on the CI and available in the Release . To download the plugin, get the file named quokka_plugin**.so .","title":"From the CI"},{"location":"installation/#building","text":"","title":"Building"},{"location":"installation/#requirements_1","text":"CMake (at least 3.13) A reasonable modern compiler supporting at least Cxx17 IDA Sdk (version 7.7) 64 bits IDA (7.7 and higher)","title":"Requirements :"},{"location":"installation/#standard-build","text":"The first step is to download the sources. You can clone the repository like in here To compile quokka , you first need to generate the configuration using CMake . user@host:~$ cd quokka user@host:~/quokka$ cmake -B build \\ # Where to build -S . \\ # Where are the sources -DIdaSdk_ROOT_DIR:STRING=path/to/ida_sdk \\ # Path to IDA SDK -DCMAKE_BUILD_TYPE:STRING=Release # Build Type If the first step succeeded, you can now do the actual building. user@host:~/quokka$ cmake --build build --target quokka_plugin -- -j # use as many core as possible","title":"Standard build"},{"location":"installation/#build-on-windows","text":"Warning This is only experimental.","title":"Build On Windows"},{"location":"installation/#requirements_2","text":"This procedure has only been tested with using a Windows Dev Machine : Windows 11 Entreprise Visual Studio 2022 Community Edition Git version 2.37.3 (to download Abseil) cmake version 3.24.1 Optional: - ccache v4.6.3","title":"Requirements"},{"location":"installation/#steps","text":"Configure the plugin console PS C:\\Users\\User\\quokka> cmake -B build -S . -DIdaSdk_ROOT_DIR=third_party/idasdk80 -A x64 Perform the build PS C:\\Users\\User\\quokka> cmake --build build --target quokka_plugin --config Release Cross your fingers and hope. Quokka for Windows is experimental and not tested. There are known issues with older Visual Studio versions and Ninja. Feel free to report any bug.","title":"Steps"},{"location":"philosophy/","text":"Philosophy Quokka and its bindings were created in order to manipulate a binary without using IDA. To be usable, we needed something (reasonably) fast and compact. It leads to the following properties we try to enforce: Exhaustive The plugin should export as much data as possible from IDA Compact The export file should be as compact as possible to reduce disk usage. Fast Waiting for the export should be kept as a minimum. Intuitive The plugin should be usable without documentation with an intuitive interface.","title":"Philosophy"},{"location":"philosophy/#philosophy","text":"Quokka and its bindings were created in order to manipulate a binary without using IDA. To be usable, we needed something (reasonably) fast and compact. It leads to the following properties we try to enforce: Exhaustive The plugin should export as much data as possible from IDA Compact The export file should be as compact as possible to reduce disk usage. Fast Waiting for the export should be kept as a minimum. Intuitive The plugin should be usable without documentation with an intuitive interface.","title":"Philosophy"},{"location":"roadmap/","text":"Roadmap Quokka is not perfect and some features could be improved. The list below is not a Roadmap per se but more like a whishlist. Do not hesitate to open Issues for requesting features. Export Information Types Information For the moment, Quokka does not export types information. This feature would be super useful for various analyses. Stack Variable IDA defines stack variables in the function. Exporting them could be valuable for some workflows Decompiler Hex-Rays generates a pseudo C-code from binary code. Exporting it as well could also be nice Operands Data While the operands are exported, it is hard to understand them outside IDA without having the disassembler documentation. Exporting information on them could be interesting. Refactor Rewrite the Reference Manager The Reference Manager is hard to understand, to maintain and to use. Plus, it has some performances issues. It has to be rewritten to be improved while not losing any functionalities. Remove the interface for Function Chunks A Function Chunk is an IDA abstraction for function parts. However, it is meaningless to expose them in the user interface because users do not care about them. Use weakref for Program Program has backref in most items in Quokka . However, we should use weakref to allow the garbage collector to do its magic when cleaning some parts of the program. Disassemblers Quokka for Ghidra / Binary Ninja While IDA works nicely, some researchers have moved to other disassemblers. Having an export working for Binary Ninja and Ghidra could help Quokka adoption! Misc Support Fat binaries IDA supports disassembling Fat Binaries but Quokka will only export the first one. One nice feature would be to select which one to export Verify the support for unknown architectures Quokka should export any binary but it has been barely tested with other architectures. Documentation Document Export Modes Quokka has three export modes, but only one is properly documented (NORMAL)","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"Quokka is not perfect and some features could be improved. The list below is not a Roadmap per se but more like a whishlist. Do not hesitate to open Issues for requesting features.","title":"Roadmap"},{"location":"roadmap/#export-information","text":"Types Information For the moment, Quokka does not export types information. This feature would be super useful for various analyses. Stack Variable IDA defines stack variables in the function. Exporting them could be valuable for some workflows Decompiler Hex-Rays generates a pseudo C-code from binary code. Exporting it as well could also be nice Operands Data While the operands are exported, it is hard to understand them outside IDA without having the disassembler documentation. Exporting information on them could be interesting.","title":"Export Information"},{"location":"roadmap/#refactor","text":"Rewrite the Reference Manager The Reference Manager is hard to understand, to maintain and to use. Plus, it has some performances issues. It has to be rewritten to be improved while not losing any functionalities. Remove the interface for Function Chunks A Function Chunk is an IDA abstraction for function parts. However, it is meaningless to expose them in the user interface because users do not care about them. Use weakref for Program Program has backref in most items in Quokka . However, we should use weakref to allow the garbage collector to do its magic when cleaning some parts of the program.","title":"Refactor"},{"location":"roadmap/#disassemblers","text":"Quokka for Ghidra / Binary Ninja While IDA works nicely, some researchers have moved to other disassemblers. Having an export working for Binary Ninja and Ghidra could help Quokka adoption!","title":"Disassemblers"},{"location":"roadmap/#misc","text":"Support Fat binaries IDA supports disassembling Fat Binaries but Quokka will only export the first one. One nice feature would be to select which one to export Verify the support for unknown architectures Quokka should export any binary but it has been barely tested with other architectures.","title":"Misc"},{"location":"roadmap/#documentation","text":"Document Export Modes Quokka has three export modes, but only one is properly documented (NORMAL)","title":"Documentation"},{"location":"usage/","text":"Usage Export plugin Note This requires a working IDA installation. Either using command line: $ idat64 -OQuokkaAuto:true -A /path/to/hello.i64 Note: We are using idat64 and not ida64 to increase the export speed because we don't need the graphical interface. Using the plugin shortcut inside IDA: (by default) Alt+A Export Options To pass option to an IDA plugin, use the -O switch on the command line. Ex: -OQuokka<OPTION_NAME>:<OPTION_VALUE> . Log - Log level Usage: -OQuokkaLog:<LEVEL> Values: Debug, Info ,Error This option toggle the reporting of the exporter. Note: The debug log level also prints the line and the function. File - Output filename Usage: -OQuokkaFile:<NAME> Values: A path where the user is allowed to write Use this option to override the file written by quokka. If none is given, .quokka is used. Auto - Auto mode Usage: -OQuokkaAuto:<NON_EMPTY_STRING> Use this option to launch quokka directly from the command line. Export Level Usage: -OQuokkaMode:<MODE> Values: LIGHT, NORMAL , FULL Controls the export level for the instructions: If the Light mode is selected, only the block starting addresses will be exported. For Normal , the instructions with all IDA values will be exported. However, it is challenging to interpret them because you have to read IDA API. For Full , the instruction and the string representation of the instruction is exported. Example: Light mode Normal mode Full mode prog . proto . instructions == [] prog . proto . instructions [ 0 ] = size : 3 mnemonic_index : 3 operand_index : 1 operand_index : 6 prog . proto . instructions [ 0 ] = size : 3 mnemonic_index : 3 operand_index : 1 operand_index : 6 operand_strings : 1 operand_strings : 6 How to choose a mode? By default, use the Normal mode. If you know you are going to ask for another disassembler for specific bytes (or have reversed the IDA way of storing data), consider using the Light mode. Finally, if you have an exotic architecture, you may be interested in the full disassembly: in this case, use the Full mode.","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#export-plugin","text":"Note This requires a working IDA installation. Either using command line: $ idat64 -OQuokkaAuto:true -A /path/to/hello.i64 Note: We are using idat64 and not ida64 to increase the export speed because we don't need the graphical interface. Using the plugin shortcut inside IDA: (by default) Alt+A","title":"Export plugin"},{"location":"usage/#export-options","text":"To pass option to an IDA plugin, use the -O switch on the command line. Ex: -OQuokka<OPTION_NAME>:<OPTION_VALUE> .","title":"Export Options"},{"location":"usage/#log-log-level","text":"Usage: -OQuokkaLog:<LEVEL> Values: Debug, Info ,Error This option toggle the reporting of the exporter. Note: The debug log level also prints the line and the function.","title":"Log - Log level"},{"location":"usage/#file-output-filename","text":"Usage: -OQuokkaFile:<NAME> Values: A path where the user is allowed to write Use this option to override the file written by quokka. If none is given, .quokka is used.","title":"File - Output filename"},{"location":"usage/#auto-auto-mode","text":"Usage: -OQuokkaAuto:<NON_EMPTY_STRING> Use this option to launch quokka directly from the command line.","title":"Auto - Auto mode"},{"location":"usage/#export-level","text":"Usage: -OQuokkaMode:<MODE> Values: LIGHT, NORMAL , FULL Controls the export level for the instructions: If the Light mode is selected, only the block starting addresses will be exported. For Normal , the instructions with all IDA values will be exported. However, it is challenging to interpret them because you have to read IDA API. For Full , the instruction and the string representation of the instruction is exported. Example: Light mode Normal mode Full mode prog . proto . instructions == [] prog . proto . instructions [ 0 ] = size : 3 mnemonic_index : 3 operand_index : 1 operand_index : 6 prog . proto . instructions [ 0 ] = size : 3 mnemonic_index : 3 operand_index : 1 operand_index : 6 operand_strings : 1 operand_strings : 6 How to choose a mode? By default, use the Normal mode. If you know you are going to ask for another disassembler for specific bytes (or have reversed the IDA way of storing data), consider using the Light mode. Finally, if you have an exotic architecture, you may be interested in the full disassembly: in this case, use the Full mode.","title":"Export Level"},{"location":"reference/python/SUMMARY/","text":"structure data addresser instruction utils reference types exc program segment block executable function backends capstone pypcode analysis calling_convention utils env replacer arch","title":"SUMMARY"},{"location":"reference/python/addresser/","text":"Addresser : handle addresses management Addresser Class for managing addresses. Parameters: Name Type Description Default program quokka . Program A backref to the program required base_address AddressT Program's base address required Attributes: Name Type Description logger A logger instance program quokka . Program Program reference base_address AddressT Program base address Source code in quokka/addresser.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class Addresser : \"\"\"Class for managing addresses. Arguments: program: A backref to the program base_address: Program's base address Attributes: logger: A logger instance program: Program reference base_address: Program base address \"\"\" def __init__ ( self , program : quokka . Program , base_address : AddressT ): \"\"\"Constructor\"\"\" self . logger = logging . getLogger ( __name__ ) self . program : quokka . Program = program self . base_address : AddressT = base_address def absolute ( self , offset : int ) -> AddressT : \"\"\"Converts an offset in the file to an absolute address Arguments: offset: Offset in the file Returns: An absolute address \"\"\" return self . base_address + offset def file ( self , offset : int ) -> int : \"\"\"Converts a program offset to a file offset. Arguments: offset: A virtual address Returns: A file offset \"\"\" try : segment = self . program . get_segment ( offset ) except KeyError as exc : raise quokka . NotInFileError ( \"Unable to find the segment\" ) from exc if segment . file_offset != - 1 : return offset + segment . file_offset raise quokka . NotInFileError ( \"Unable to find the offset in the file\" ) __init__ ( program , base_address ) Constructor Source code in quokka/addresser.py 38 39 40 41 42 def __init__ ( self , program : quokka . Program , base_address : AddressT ): \"\"\"Constructor\"\"\" self . logger = logging . getLogger ( __name__ ) self . program : quokka . Program = program self . base_address : AddressT = base_address absolute ( offset ) Converts an offset in the file to an absolute address Parameters: Name Type Description Default offset int Offset in the file required Returns: Type Description AddressT An absolute address Source code in quokka/addresser.py 44 45 46 47 48 49 50 51 52 53 def absolute ( self , offset : int ) -> AddressT : \"\"\"Converts an offset in the file to an absolute address Arguments: offset: Offset in the file Returns: An absolute address \"\"\" return self . base_address + offset file ( offset ) Converts a program offset to a file offset. Parameters: Name Type Description Default offset int A virtual address required Returns: Type Description int A file offset Source code in quokka/addresser.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def file ( self , offset : int ) -> int : \"\"\"Converts a program offset to a file offset. Arguments: offset: A virtual address Returns: A file offset \"\"\" try : segment = self . program . get_segment ( offset ) except KeyError as exc : raise quokka . NotInFileError ( \"Unable to find the segment\" ) from exc if segment . file_offset != - 1 : return offset + segment . file_offset raise quokka . NotInFileError ( \"Unable to find the offset in the file\" )","title":"addresser"},{"location":"reference/python/addresser/#quokka.addresser.Addresser","text":"Class for managing addresses. Parameters: Name Type Description Default program quokka . Program A backref to the program required base_address AddressT Program's base address required Attributes: Name Type Description logger A logger instance program quokka . Program Program reference base_address AddressT Program base address Source code in quokka/addresser.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class Addresser : \"\"\"Class for managing addresses. Arguments: program: A backref to the program base_address: Program's base address Attributes: logger: A logger instance program: Program reference base_address: Program base address \"\"\" def __init__ ( self , program : quokka . Program , base_address : AddressT ): \"\"\"Constructor\"\"\" self . logger = logging . getLogger ( __name__ ) self . program : quokka . Program = program self . base_address : AddressT = base_address def absolute ( self , offset : int ) -> AddressT : \"\"\"Converts an offset in the file to an absolute address Arguments: offset: Offset in the file Returns: An absolute address \"\"\" return self . base_address + offset def file ( self , offset : int ) -> int : \"\"\"Converts a program offset to a file offset. Arguments: offset: A virtual address Returns: A file offset \"\"\" try : segment = self . program . get_segment ( offset ) except KeyError as exc : raise quokka . NotInFileError ( \"Unable to find the segment\" ) from exc if segment . file_offset != - 1 : return offset + segment . file_offset raise quokka . NotInFileError ( \"Unable to find the offset in the file\" )","title":"Addresser"},{"location":"reference/python/addresser/#quokka.addresser.Addresser.__init__","text":"Constructor Source code in quokka/addresser.py 38 39 40 41 42 def __init__ ( self , program : quokka . Program , base_address : AddressT ): \"\"\"Constructor\"\"\" self . logger = logging . getLogger ( __name__ ) self . program : quokka . Program = program self . base_address : AddressT = base_address","title":"__init__()"},{"location":"reference/python/addresser/#quokka.addresser.Addresser.absolute","text":"Converts an offset in the file to an absolute address Parameters: Name Type Description Default offset int Offset in the file required Returns: Type Description AddressT An absolute address Source code in quokka/addresser.py 44 45 46 47 48 49 50 51 52 53 def absolute ( self , offset : int ) -> AddressT : \"\"\"Converts an offset in the file to an absolute address Arguments: offset: Offset in the file Returns: An absolute address \"\"\" return self . base_address + offset","title":"absolute()"},{"location":"reference/python/addresser/#quokka.addresser.Addresser.file","text":"Converts a program offset to a file offset. Parameters: Name Type Description Default offset int A virtual address required Returns: Type Description int A file offset Source code in quokka/addresser.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def file ( self , offset : int ) -> int : \"\"\"Converts a program offset to a file offset. Arguments: offset: A virtual address Returns: A file offset \"\"\" try : segment = self . program . get_segment ( offset ) except KeyError as exc : raise quokka . NotInFileError ( \"Unable to find the segment\" ) from exc if segment . file_offset != - 1 : return offset + segment . file_offset raise quokka . NotInFileError ( \"Unable to find the offset in the file\" )","title":"file()"},{"location":"reference/python/block/","text":"Methods to use and deal with blocks in a binary. Block Bases: MutableMapping Basic Block class A basic block is a sequence of instructions without any (basic) incoming flows disrupting it (except calls returns). While blocks may be serialized in the exported file, a new instance of this class is created for each block in the program (so they all have an unique address). Parameters: Name Type Description Default block_idx Index Index in the protobuf file of the block required start_address AddressT Starting address of the block required chunk quokka . Chunk Parent chunk (e.g. function) of the block. required Attributes: Name Type Description proto_index Index Index inside the protobuf parent quokka . Chunk A reference to the parent Chunk program quokka . Program A reference to the parent Program start int Start address fake bool Is it a fake block (e.g. belongs to a fake chunk) type BlockType Block type address_to_index Dict [ AddressT , Index ] A mapping of addresses to instruction indexes end int End address comments Dict [ AddressT , str ] List of comments attached to the block references Dict [ str , List [ int ]] References mapping attached to the block (TODO(dm): remove me?) Source code in quokka/block.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 class Block ( MutableMapping ): \"\"\"Basic Block class A basic block is a sequence of instructions without any (basic) incoming flows disrupting it (except calls returns). While blocks may be serialized in the exported file, a new instance of this class is created for each block in the program (so they all have an unique address). Arguments: block_idx: Index in the protobuf file of the block start_address: Starting address of the block chunk: Parent chunk (e.g. function) of the block. Attributes: proto_index: Index inside the protobuf parent: A reference to the parent Chunk program: A reference to the parent Program start: Start address fake: Is it a fake block (e.g. belongs to a fake chunk) type: Block type address_to_index: A mapping of addresses to instruction indexes end: End address comments: List of comments attached to the block references: References mapping attached to the block (TODO(dm): remove me?) \"\"\" def __init__ ( self , block_idx : Index , start_address : AddressT , chunk : quokka . Chunk , ): \"\"\"Constructor\"\"\" self . proto_index : Index = block_idx self . parent : quokka . Chunk = chunk self . program : quokka . Program = chunk . program block : \"quokka.pb.Quokka.FunctionChunk.Block\" block = self . program . proto . function_chunks [ chunk . proto_index ] . blocks [ block_idx ] self . start : int = start_address self . fake : bool = block . is_fake self . type : BlockType = BlockType . from_proto ( block . block_type ) self . address_to_index : Dict [ AddressT , Index ] = {} self . _raw_dict : Dict [ AddressT , Index ] = {} current_address : AddressT = self . start for instruction_index , instruction_proto_index in enumerate ( block . instructions_index ): self . address_to_index [ current_address ] = instruction_index self . _raw_dict [ current_address ] = instruction_proto_index current_address += self . program . proto . instructions [ instruction_proto_index ] . size self . end : int = current_address self . comments : Dict [ AddressT , str ] = {} self . references : Dict [ str , List [ int ]] = { \"src\" : [], \"dst\" : []} def __setitem__ ( self , k : AddressT , v : Index ) -> None : \"\"\"Update the instructions mapping\"\"\" self . _raw_dict . __setitem__ ( k , v ) def __delitem__ ( self , v : AddressT ) -> None : \"\"\"Remove an instruction from the mapping\"\"\" self . _raw_dict . __delitem__ ( v ) def add_comment ( self , addr : AddressT , value : str ) -> None : \"\"\"Set the comment at `addr`. Arguments: addr: Comment address value: Comment value \"\"\" self . comments [ addr ] = value @cached_property def strings ( self ) -> List [ str ]: \"\"\"Compute the list of strings used in this block.\"\"\" strings : Set [ str ] = set () for reference in self . program . references . resolve_block_references ( self . parent . proto_index , self . proto_index , ReferenceType . DATA , towards = True , ): reference_source = reference . source if ( isinstance ( reference_source , quokka . data . Data ) and reference_source . type == DataType . ASCII ): strings . add ( reference_source . value ) return list ( strings ) def __getitem__ ( self , address : AddressT ) -> quokka . Instruction : \"\"\"Retrieve an instruction at `address`.\"\"\" item = self . _raw_dict . __getitem__ ( address ) return quokka . Instruction ( proto_index = item , inst_index = self . address_to_index [ address ], address = address , block = self , ) def __len__ ( self ) -> int : \"\"\"Number of instruction in the block\"\"\" return len ( self . _raw_dict ) def __iter__ ( self ) -> Iterator : \"\"\"Return an iterator over the instruction list\"\"\" return iter ( self . _raw_dict ) @property def data_references ( self ): \"\"\"Return (and compute if needed) the data referenced by this block.\"\"\" data_references : List [ quokka . Data ] = [] for instruction in self . values (): data_references . extend ( instruction . data_references ) return data_references @property def size ( self ) -> int : \"\"\"Size of the block. This number is the number of instruction * the size of an instruction for architecture with fixed length instructions (e.g. ARM). \"\"\" return self . end - self . start @cached_property def constants ( self ) -> List [ int ]: \"\"\"Constants used by the block\"\"\" constants : List [ int ] = [] for instruction in self . values (): constants . extend ( instruction . constants ) return constants @property def instructions ( self ): \"\"\"Accessor of the block instructions\"\"\" return self . values () def __repr__ ( self ) -> str : \"\"\"Block Representation\"\"\" return ( f \"<Block at 0x { self . start : x } ( { self . type } ) with { len ( self ) } instructions>\" ) def __hash__ ( self ) -> int : \"\"\"Hash of the block. The proto index is guaranteed to be unique so we can use it as an hash and forget about un-hashable types. TODO(dm): Check this \"\"\" return self . proto_index def successors ( self ) -> Iterator [ AddressT ]: \"\"\"(Addresses of the) Successors of the current block.\"\"\" return self . parent . graph . successors ( self . start ) def predecessors ( self ) -> Iterator [ AddressT ]: \"\"\"(Addresses of) Predecessors of the current block\"\"\" return self . parent . graph . predecessors ( self . start ) @property def last_instruction ( self ) -> quokka . Instruction : \"\"\"Direct accessor of the last instruction in the block\"\"\" deque = collections . deque ( self . instructions , maxlen = 1 ) return deque . pop () @cached_property def bytes ( self ) -> bytes : \"\"\"Retrieve the block bytes All bytes for the block are read at once in the file but the result is not cached. \"\"\" try : file_offset : int = self . program . addresser . file ( self . start ) except quokka . NotInFileError : logger . warning ( \"Trying to get the bytes for a block not in file.\" ) return b \"\" # Read all block at once block_bytes = self . program . executable . read_byte ( offset = file_offset , size = self . size , ) return block_bytes @property def pcode_insts ( self ) -> List [ pypcode . PcodeOp ]: \"\"\"Generate PCode instructions for the block This method will call the backend Pypcode and generate the instruction for the whole block, updating all the instruction inside the block as well. However, all instructions will from now be attached to the block itself, and not the instructions so the list may differ after some optimizations (e.g. len(self.pcode_insts) != sum(len(inst.pcode_insts) for inst in block.values()) ) Returns: A list of PCode instructions \"\"\" return quokka . backends . pypcode_decode_block ( self ) __delitem__ ( v ) Remove an instruction from the mapping Source code in quokka/block.py 109 110 111 def __delitem__ ( self , v : AddressT ) -> None : \"\"\"Remove an instruction from the mapping\"\"\" self . _raw_dict . __delitem__ ( v ) __getitem__ ( address ) Retrieve an instruction at address . Source code in quokka/block.py 143 144 145 146 147 148 149 150 151 def __getitem__ ( self , address : AddressT ) -> quokka . Instruction : \"\"\"Retrieve an instruction at `address`.\"\"\" item = self . _raw_dict . __getitem__ ( address ) return quokka . Instruction ( proto_index = item , inst_index = self . address_to_index [ address ], address = address , block = self , ) __hash__ () Hash of the block. The proto index is guaranteed to be unique so we can use it as an hash and forget about un-hashable types. TODO(dm): Check this Source code in quokka/block.py 199 200 201 202 203 204 205 206 207 208 def __hash__ ( self ) -> int : \"\"\"Hash of the block. The proto index is guaranteed to be unique so we can use it as an hash and forget about un-hashable types. TODO(dm): Check this \"\"\" return self . proto_index __init__ ( block_idx , start_address , chunk ) Constructor Source code in quokka/block.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def __init__ ( self , block_idx : Index , start_address : AddressT , chunk : quokka . Chunk , ): \"\"\"Constructor\"\"\" self . proto_index : Index = block_idx self . parent : quokka . Chunk = chunk self . program : quokka . Program = chunk . program block : \"quokka.pb.Quokka.FunctionChunk.Block\" block = self . program . proto . function_chunks [ chunk . proto_index ] . blocks [ block_idx ] self . start : int = start_address self . fake : bool = block . is_fake self . type : BlockType = BlockType . from_proto ( block . block_type ) self . address_to_index : Dict [ AddressT , Index ] = {} self . _raw_dict : Dict [ AddressT , Index ] = {} current_address : AddressT = self . start for instruction_index , instruction_proto_index in enumerate ( block . instructions_index ): self . address_to_index [ current_address ] = instruction_index self . _raw_dict [ current_address ] = instruction_proto_index current_address += self . program . proto . instructions [ instruction_proto_index ] . size self . end : int = current_address self . comments : Dict [ AddressT , str ] = {} self . references : Dict [ str , List [ int ]] = { \"src\" : [], \"dst\" : []} __iter__ () Return an iterator over the instruction list Source code in quokka/block.py 157 158 159 def __iter__ ( self ) -> Iterator : \"\"\"Return an iterator over the instruction list\"\"\" return iter ( self . _raw_dict ) __len__ () Number of instruction in the block Source code in quokka/block.py 153 154 155 def __len__ ( self ) -> int : \"\"\"Number of instruction in the block\"\"\" return len ( self . _raw_dict ) __repr__ () Block Representation Source code in quokka/block.py 193 194 195 196 197 def __repr__ ( self ) -> str : \"\"\"Block Representation\"\"\" return ( f \"<Block at 0x { self . start : x } ( { self . type } ) with { len ( self ) } instructions>\" ) __setitem__ ( k , v ) Update the instructions mapping Source code in quokka/block.py 105 106 107 def __setitem__ ( self , k : AddressT , v : Index ) -> None : \"\"\"Update the instructions mapping\"\"\" self . _raw_dict . __setitem__ ( k , v ) add_comment ( addr , value ) Set the comment at addr . Parameters: Name Type Description Default addr AddressT Comment address required value str Comment value required Source code in quokka/block.py 113 114 115 116 117 118 119 120 def add_comment ( self , addr : AddressT , value : str ) -> None : \"\"\"Set the comment at `addr`. Arguments: addr: Comment address value: Comment value \"\"\" self . comments [ addr ] = value bytes () cached property Retrieve the block bytes All bytes for the block are read at once in the file but the result is not cached. Source code in quokka/block.py 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 @cached_property def bytes ( self ) -> bytes : \"\"\"Retrieve the block bytes All bytes for the block are read at once in the file but the result is not cached. \"\"\" try : file_offset : int = self . program . addresser . file ( self . start ) except quokka . NotInFileError : logger . warning ( \"Trying to get the bytes for a block not in file.\" ) return b \"\" # Read all block at once block_bytes = self . program . executable . read_byte ( offset = file_offset , size = self . size , ) return block_bytes constants () cached property Constants used by the block Source code in quokka/block.py 179 180 181 182 183 184 185 186 @cached_property def constants ( self ) -> List [ int ]: \"\"\"Constants used by the block\"\"\" constants : List [ int ] = [] for instruction in self . values (): constants . extend ( instruction . constants ) return constants data_references () property Return (and compute if needed) the data referenced by this block. Source code in quokka/block.py 161 162 163 164 165 166 167 168 @property def data_references ( self ): \"\"\"Return (and compute if needed) the data referenced by this block.\"\"\" data_references : List [ quokka . Data ] = [] for instruction in self . values (): data_references . extend ( instruction . data_references ) return data_references instructions () property Accessor of the block instructions Source code in quokka/block.py 188 189 190 191 @property def instructions ( self ): \"\"\"Accessor of the block instructions\"\"\" return self . values () last_instruction () property Direct accessor of the last instruction in the block Source code in quokka/block.py 218 219 220 221 222 @property def last_instruction ( self ) -> quokka . Instruction : \"\"\"Direct accessor of the last instruction in the block\"\"\" deque = collections . deque ( self . instructions , maxlen = 1 ) return deque . pop () pcode_insts () property Generate PCode instructions for the block This method will call the backend Pypcode and generate the instruction for the whole block, updating all the instruction inside the block as well. However, all instructions will from now be attached to the block itself, and not the instructions so the list may differ after some optimizations (e.g. len(self.pcode_insts) != sum(len(inst.pcode_insts) for inst in block.values()) ) Returns: Type Description List [ pypcode . PcodeOp ] A list of PCode instructions Source code in quokka/block.py 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 @property def pcode_insts ( self ) -> List [ pypcode . PcodeOp ]: \"\"\"Generate PCode instructions for the block This method will call the backend Pypcode and generate the instruction for the whole block, updating all the instruction inside the block as well. However, all instructions will from now be attached to the block itself, and not the instructions so the list may differ after some optimizations (e.g. len(self.pcode_insts) != sum(len(inst.pcode_insts) for inst in block.values()) ) Returns: A list of PCode instructions \"\"\" return quokka . backends . pypcode_decode_block ( self ) predecessors () (Addresses of) Predecessors of the current block Source code in quokka/block.py 214 215 216 def predecessors ( self ) -> Iterator [ AddressT ]: \"\"\"(Addresses of) Predecessors of the current block\"\"\" return self . parent . graph . predecessors ( self . start ) size () property Size of the block. This number is the number of instruction * the size of an instruction for architecture with fixed length instructions (e.g. ARM). Source code in quokka/block.py 170 171 172 173 174 175 176 177 @property def size ( self ) -> int : \"\"\"Size of the block. This number is the number of instruction * the size of an instruction for architecture with fixed length instructions (e.g. ARM). \"\"\" return self . end - self . start strings () cached property Compute the list of strings used in this block. Source code in quokka/block.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 @cached_property def strings ( self ) -> List [ str ]: \"\"\"Compute the list of strings used in this block.\"\"\" strings : Set [ str ] = set () for reference in self . program . references . resolve_block_references ( self . parent . proto_index , self . proto_index , ReferenceType . DATA , towards = True , ): reference_source = reference . source if ( isinstance ( reference_source , quokka . data . Data ) and reference_source . type == DataType . ASCII ): strings . add ( reference_source . value ) return list ( strings ) successors () (Addresses of the) Successors of the current block. Source code in quokka/block.py 210 211 212 def successors ( self ) -> Iterator [ AddressT ]: \"\"\"(Addresses of the) Successors of the current block.\"\"\" return self . parent . graph . successors ( self . start )","title":"block"},{"location":"reference/python/block/#quokka.block.Block","text":"Bases: MutableMapping Basic Block class A basic block is a sequence of instructions without any (basic) incoming flows disrupting it (except calls returns). While blocks may be serialized in the exported file, a new instance of this class is created for each block in the program (so they all have an unique address). Parameters: Name Type Description Default block_idx Index Index in the protobuf file of the block required start_address AddressT Starting address of the block required chunk quokka . Chunk Parent chunk (e.g. function) of the block. required Attributes: Name Type Description proto_index Index Index inside the protobuf parent quokka . Chunk A reference to the parent Chunk program quokka . Program A reference to the parent Program start int Start address fake bool Is it a fake block (e.g. belongs to a fake chunk) type BlockType Block type address_to_index Dict [ AddressT , Index ] A mapping of addresses to instruction indexes end int End address comments Dict [ AddressT , str ] List of comments attached to the block references Dict [ str , List [ int ]] References mapping attached to the block (TODO(dm): remove me?) Source code in quokka/block.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 class Block ( MutableMapping ): \"\"\"Basic Block class A basic block is a sequence of instructions without any (basic) incoming flows disrupting it (except calls returns). While blocks may be serialized in the exported file, a new instance of this class is created for each block in the program (so they all have an unique address). Arguments: block_idx: Index in the protobuf file of the block start_address: Starting address of the block chunk: Parent chunk (e.g. function) of the block. Attributes: proto_index: Index inside the protobuf parent: A reference to the parent Chunk program: A reference to the parent Program start: Start address fake: Is it a fake block (e.g. belongs to a fake chunk) type: Block type address_to_index: A mapping of addresses to instruction indexes end: End address comments: List of comments attached to the block references: References mapping attached to the block (TODO(dm): remove me?) \"\"\" def __init__ ( self , block_idx : Index , start_address : AddressT , chunk : quokka . Chunk , ): \"\"\"Constructor\"\"\" self . proto_index : Index = block_idx self . parent : quokka . Chunk = chunk self . program : quokka . Program = chunk . program block : \"quokka.pb.Quokka.FunctionChunk.Block\" block = self . program . proto . function_chunks [ chunk . proto_index ] . blocks [ block_idx ] self . start : int = start_address self . fake : bool = block . is_fake self . type : BlockType = BlockType . from_proto ( block . block_type ) self . address_to_index : Dict [ AddressT , Index ] = {} self . _raw_dict : Dict [ AddressT , Index ] = {} current_address : AddressT = self . start for instruction_index , instruction_proto_index in enumerate ( block . instructions_index ): self . address_to_index [ current_address ] = instruction_index self . _raw_dict [ current_address ] = instruction_proto_index current_address += self . program . proto . instructions [ instruction_proto_index ] . size self . end : int = current_address self . comments : Dict [ AddressT , str ] = {} self . references : Dict [ str , List [ int ]] = { \"src\" : [], \"dst\" : []} def __setitem__ ( self , k : AddressT , v : Index ) -> None : \"\"\"Update the instructions mapping\"\"\" self . _raw_dict . __setitem__ ( k , v ) def __delitem__ ( self , v : AddressT ) -> None : \"\"\"Remove an instruction from the mapping\"\"\" self . _raw_dict . __delitem__ ( v ) def add_comment ( self , addr : AddressT , value : str ) -> None : \"\"\"Set the comment at `addr`. Arguments: addr: Comment address value: Comment value \"\"\" self . comments [ addr ] = value @cached_property def strings ( self ) -> List [ str ]: \"\"\"Compute the list of strings used in this block.\"\"\" strings : Set [ str ] = set () for reference in self . program . references . resolve_block_references ( self . parent . proto_index , self . proto_index , ReferenceType . DATA , towards = True , ): reference_source = reference . source if ( isinstance ( reference_source , quokka . data . Data ) and reference_source . type == DataType . ASCII ): strings . add ( reference_source . value ) return list ( strings ) def __getitem__ ( self , address : AddressT ) -> quokka . Instruction : \"\"\"Retrieve an instruction at `address`.\"\"\" item = self . _raw_dict . __getitem__ ( address ) return quokka . Instruction ( proto_index = item , inst_index = self . address_to_index [ address ], address = address , block = self , ) def __len__ ( self ) -> int : \"\"\"Number of instruction in the block\"\"\" return len ( self . _raw_dict ) def __iter__ ( self ) -> Iterator : \"\"\"Return an iterator over the instruction list\"\"\" return iter ( self . _raw_dict ) @property def data_references ( self ): \"\"\"Return (and compute if needed) the data referenced by this block.\"\"\" data_references : List [ quokka . Data ] = [] for instruction in self . values (): data_references . extend ( instruction . data_references ) return data_references @property def size ( self ) -> int : \"\"\"Size of the block. This number is the number of instruction * the size of an instruction for architecture with fixed length instructions (e.g. ARM). \"\"\" return self . end - self . start @cached_property def constants ( self ) -> List [ int ]: \"\"\"Constants used by the block\"\"\" constants : List [ int ] = [] for instruction in self . values (): constants . extend ( instruction . constants ) return constants @property def instructions ( self ): \"\"\"Accessor of the block instructions\"\"\" return self . values () def __repr__ ( self ) -> str : \"\"\"Block Representation\"\"\" return ( f \"<Block at 0x { self . start : x } ( { self . type } ) with { len ( self ) } instructions>\" ) def __hash__ ( self ) -> int : \"\"\"Hash of the block. The proto index is guaranteed to be unique so we can use it as an hash and forget about un-hashable types. TODO(dm): Check this \"\"\" return self . proto_index def successors ( self ) -> Iterator [ AddressT ]: \"\"\"(Addresses of the) Successors of the current block.\"\"\" return self . parent . graph . successors ( self . start ) def predecessors ( self ) -> Iterator [ AddressT ]: \"\"\"(Addresses of) Predecessors of the current block\"\"\" return self . parent . graph . predecessors ( self . start ) @property def last_instruction ( self ) -> quokka . Instruction : \"\"\"Direct accessor of the last instruction in the block\"\"\" deque = collections . deque ( self . instructions , maxlen = 1 ) return deque . pop () @cached_property def bytes ( self ) -> bytes : \"\"\"Retrieve the block bytes All bytes for the block are read at once in the file but the result is not cached. \"\"\" try : file_offset : int = self . program . addresser . file ( self . start ) except quokka . NotInFileError : logger . warning ( \"Trying to get the bytes for a block not in file.\" ) return b \"\" # Read all block at once block_bytes = self . program . executable . read_byte ( offset = file_offset , size = self . size , ) return block_bytes @property def pcode_insts ( self ) -> List [ pypcode . PcodeOp ]: \"\"\"Generate PCode instructions for the block This method will call the backend Pypcode and generate the instruction for the whole block, updating all the instruction inside the block as well. However, all instructions will from now be attached to the block itself, and not the instructions so the list may differ after some optimizations (e.g. len(self.pcode_insts) != sum(len(inst.pcode_insts) for inst in block.values()) ) Returns: A list of PCode instructions \"\"\" return quokka . backends . pypcode_decode_block ( self )","title":"Block"},{"location":"reference/python/block/#quokka.block.Block.__delitem__","text":"Remove an instruction from the mapping Source code in quokka/block.py 109 110 111 def __delitem__ ( self , v : AddressT ) -> None : \"\"\"Remove an instruction from the mapping\"\"\" self . _raw_dict . __delitem__ ( v )","title":"__delitem__()"},{"location":"reference/python/block/#quokka.block.Block.__getitem__","text":"Retrieve an instruction at address . Source code in quokka/block.py 143 144 145 146 147 148 149 150 151 def __getitem__ ( self , address : AddressT ) -> quokka . Instruction : \"\"\"Retrieve an instruction at `address`.\"\"\" item = self . _raw_dict . __getitem__ ( address ) return quokka . Instruction ( proto_index = item , inst_index = self . address_to_index [ address ], address = address , block = self , )","title":"__getitem__()"},{"location":"reference/python/block/#quokka.block.Block.__hash__","text":"Hash of the block. The proto index is guaranteed to be unique so we can use it as an hash and forget about un-hashable types. TODO(dm): Check this Source code in quokka/block.py 199 200 201 202 203 204 205 206 207 208 def __hash__ ( self ) -> int : \"\"\"Hash of the block. The proto index is guaranteed to be unique so we can use it as an hash and forget about un-hashable types. TODO(dm): Check this \"\"\" return self . proto_index","title":"__hash__()"},{"location":"reference/python/block/#quokka.block.Block.__init__","text":"Constructor Source code in quokka/block.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def __init__ ( self , block_idx : Index , start_address : AddressT , chunk : quokka . Chunk , ): \"\"\"Constructor\"\"\" self . proto_index : Index = block_idx self . parent : quokka . Chunk = chunk self . program : quokka . Program = chunk . program block : \"quokka.pb.Quokka.FunctionChunk.Block\" block = self . program . proto . function_chunks [ chunk . proto_index ] . blocks [ block_idx ] self . start : int = start_address self . fake : bool = block . is_fake self . type : BlockType = BlockType . from_proto ( block . block_type ) self . address_to_index : Dict [ AddressT , Index ] = {} self . _raw_dict : Dict [ AddressT , Index ] = {} current_address : AddressT = self . start for instruction_index , instruction_proto_index in enumerate ( block . instructions_index ): self . address_to_index [ current_address ] = instruction_index self . _raw_dict [ current_address ] = instruction_proto_index current_address += self . program . proto . instructions [ instruction_proto_index ] . size self . end : int = current_address self . comments : Dict [ AddressT , str ] = {} self . references : Dict [ str , List [ int ]] = { \"src\" : [], \"dst\" : []}","title":"__init__()"},{"location":"reference/python/block/#quokka.block.Block.__iter__","text":"Return an iterator over the instruction list Source code in quokka/block.py 157 158 159 def __iter__ ( self ) -> Iterator : \"\"\"Return an iterator over the instruction list\"\"\" return iter ( self . _raw_dict )","title":"__iter__()"},{"location":"reference/python/block/#quokka.block.Block.__len__","text":"Number of instruction in the block Source code in quokka/block.py 153 154 155 def __len__ ( self ) -> int : \"\"\"Number of instruction in the block\"\"\" return len ( self . _raw_dict )","title":"__len__()"},{"location":"reference/python/block/#quokka.block.Block.__repr__","text":"Block Representation Source code in quokka/block.py 193 194 195 196 197 def __repr__ ( self ) -> str : \"\"\"Block Representation\"\"\" return ( f \"<Block at 0x { self . start : x } ( { self . type } ) with { len ( self ) } instructions>\" )","title":"__repr__()"},{"location":"reference/python/block/#quokka.block.Block.__setitem__","text":"Update the instructions mapping Source code in quokka/block.py 105 106 107 def __setitem__ ( self , k : AddressT , v : Index ) -> None : \"\"\"Update the instructions mapping\"\"\" self . _raw_dict . __setitem__ ( k , v )","title":"__setitem__()"},{"location":"reference/python/block/#quokka.block.Block.add_comment","text":"Set the comment at addr . Parameters: Name Type Description Default addr AddressT Comment address required value str Comment value required Source code in quokka/block.py 113 114 115 116 117 118 119 120 def add_comment ( self , addr : AddressT , value : str ) -> None : \"\"\"Set the comment at `addr`. Arguments: addr: Comment address value: Comment value \"\"\" self . comments [ addr ] = value","title":"add_comment()"},{"location":"reference/python/block/#quokka.block.Block.bytes","text":"Retrieve the block bytes All bytes for the block are read at once in the file but the result is not cached. Source code in quokka/block.py 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 @cached_property def bytes ( self ) -> bytes : \"\"\"Retrieve the block bytes All bytes for the block are read at once in the file but the result is not cached. \"\"\" try : file_offset : int = self . program . addresser . file ( self . start ) except quokka . NotInFileError : logger . warning ( \"Trying to get the bytes for a block not in file.\" ) return b \"\" # Read all block at once block_bytes = self . program . executable . read_byte ( offset = file_offset , size = self . size , ) return block_bytes","title":"bytes()"},{"location":"reference/python/block/#quokka.block.Block.constants","text":"Constants used by the block Source code in quokka/block.py 179 180 181 182 183 184 185 186 @cached_property def constants ( self ) -> List [ int ]: \"\"\"Constants used by the block\"\"\" constants : List [ int ] = [] for instruction in self . values (): constants . extend ( instruction . constants ) return constants","title":"constants()"},{"location":"reference/python/block/#quokka.block.Block.data_references","text":"Return (and compute if needed) the data referenced by this block. Source code in quokka/block.py 161 162 163 164 165 166 167 168 @property def data_references ( self ): \"\"\"Return (and compute if needed) the data referenced by this block.\"\"\" data_references : List [ quokka . Data ] = [] for instruction in self . values (): data_references . extend ( instruction . data_references ) return data_references","title":"data_references()"},{"location":"reference/python/block/#quokka.block.Block.instructions","text":"Accessor of the block instructions Source code in quokka/block.py 188 189 190 191 @property def instructions ( self ): \"\"\"Accessor of the block instructions\"\"\" return self . values ()","title":"instructions()"},{"location":"reference/python/block/#quokka.block.Block.last_instruction","text":"Direct accessor of the last instruction in the block Source code in quokka/block.py 218 219 220 221 222 @property def last_instruction ( self ) -> quokka . Instruction : \"\"\"Direct accessor of the last instruction in the block\"\"\" deque = collections . deque ( self . instructions , maxlen = 1 ) return deque . pop ()","title":"last_instruction()"},{"location":"reference/python/block/#quokka.block.Block.pcode_insts","text":"Generate PCode instructions for the block This method will call the backend Pypcode and generate the instruction for the whole block, updating all the instruction inside the block as well. However, all instructions will from now be attached to the block itself, and not the instructions so the list may differ after some optimizations (e.g. len(self.pcode_insts) != sum(len(inst.pcode_insts) for inst in block.values()) ) Returns: Type Description List [ pypcode . PcodeOp ] A list of PCode instructions Source code in quokka/block.py 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 @property def pcode_insts ( self ) -> List [ pypcode . PcodeOp ]: \"\"\"Generate PCode instructions for the block This method will call the backend Pypcode and generate the instruction for the whole block, updating all the instruction inside the block as well. However, all instructions will from now be attached to the block itself, and not the instructions so the list may differ after some optimizations (e.g. len(self.pcode_insts) != sum(len(inst.pcode_insts) for inst in block.values()) ) Returns: A list of PCode instructions \"\"\" return quokka . backends . pypcode_decode_block ( self )","title":"pcode_insts()"},{"location":"reference/python/block/#quokka.block.Block.predecessors","text":"(Addresses of) Predecessors of the current block Source code in quokka/block.py 214 215 216 def predecessors ( self ) -> Iterator [ AddressT ]: \"\"\"(Addresses of) Predecessors of the current block\"\"\" return self . parent . graph . predecessors ( self . start )","title":"predecessors()"},{"location":"reference/python/block/#quokka.block.Block.size","text":"Size of the block. This number is the number of instruction * the size of an instruction for architecture with fixed length instructions (e.g. ARM). Source code in quokka/block.py 170 171 172 173 174 175 176 177 @property def size ( self ) -> int : \"\"\"Size of the block. This number is the number of instruction * the size of an instruction for architecture with fixed length instructions (e.g. ARM). \"\"\" return self . end - self . start","title":"size()"},{"location":"reference/python/block/#quokka.block.Block.strings","text":"Compute the list of strings used in this block. Source code in quokka/block.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 @cached_property def strings ( self ) -> List [ str ]: \"\"\"Compute the list of strings used in this block.\"\"\" strings : Set [ str ] = set () for reference in self . program . references . resolve_block_references ( self . parent . proto_index , self . proto_index , ReferenceType . DATA , towards = True , ): reference_source = reference . source if ( isinstance ( reference_source , quokka . data . Data ) and reference_source . type == DataType . ASCII ): strings . add ( reference_source . value ) return list ( strings )","title":"strings()"},{"location":"reference/python/block/#quokka.block.Block.successors","text":"(Addresses of the) Successors of the current block. Source code in quokka/block.py 210 211 212 def successors ( self ) -> Iterator [ AddressT ]: \"\"\"(Addresses of the) Successors of the current block.\"\"\" return self . parent . graph . successors ( self . start )","title":"successors()"},{"location":"reference/python/data/","text":"Data management. A data is a piece of information that isn't code. Data Base class for data. All data have at least a type and a value. They are referenced inside the program by and to other data and code. Parameters: Name Type Description Default proto_index Index Index in the protobuf required data Data Protobuf value of the data. required program quokka . Program Program backref required Attributes: Name Type Description proto_index Index Index in the protobuf address AddressT Data address type DataType Data type program quokka . Program Reference to the Program is_initialized bool Is the data initialized? size Optional [ int ] Data size (depends on the type usually) name Optional [ str ] Data name (if any) Source code in quokka/data.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 class Data : \"\"\"Base class for data. All data have at least a type and a value. They are referenced inside the program by and to other data and code. Parameters: proto_index: Index in the protobuf data: Protobuf value of the data. program: Program backref Attributes: proto_index: Index in the protobuf address: Data address type: Data type program: Reference to the Program is_initialized: Is the data initialized? size: Data size (depends on the type usually) name: Data name (if any) \"\"\" def __init__ ( self , proto_index : Index , data : \"quokka.pb.Quokka.Data\" , program : quokka . Program ): \"\"\"Constructor\"\"\" self . proto_index : Index = proto_index self . address : AddressT = program . addresser . absolute ( data . offset ) self . type : \"DataType\" = DataType . from_proto ( data . type ) self . program : quokka . Program = program self . is_initialized : bool = not data . not_initialized self . size : Optional [ int ] = ( data . size if data . WhichOneof ( \"DataSize\" ) != \"no_size\" else None ) self . _value : Optional [ str ] = ( self . program . proto . string_table [ data . value_index ] if data . value_index > 0 else None ) self . name : Optional [ str ] = ( self . program . proto . string_table [ data . name_index ] if data . name_index > 0 else None ) def __eq__ ( self , other : Any ) -> bool : \"\"\"Check equality between two Data instances\"\"\" return type ( other ) is type ( self ) and other . proto_index == self . proto_index @property def value ( self ) -> Any : \"\"\"Data value. The value is read in the program binary file. \"\"\" # Uninitialized memory if not self . is_initialized : return None address = self . program . addresser . file ( self . address ) if self . type in ( DataType . ALIGN , DataType . POINTER , DataType . STRUCT , DataType . UNKNOWN , ): return self . _value if self . type == DataType . ASCII : try : return self . program . executable . read_data ( address , self . type , size = self . size ) except quokka . exc . NotInFileError : logger . error ( \"Try to read a string which is not in file\" ) return \"\" else : return self . program . executable . read_data ( address , self . type ) @property def references ( self ) -> List [ quokka . Reference ]: \"\"\"References to/from this data\"\"\" return self . program . references . resolve_data ( self . proto_index ) @property def code_references ( self ) -> List [ quokka . Reference ]: \"\"\"Returns code referencing this Data\"\"\" return [ ref for ref in self . references if isinstance ( ref . destination , tuple )] @property def data_references ( self ) -> List [ quokka . Reference ]: \"\"\"Returns data references to/from this Data\"\"\" return [ ref for ref in self . references if isinstance ( ref . destination , Data )] __eq__ ( other ) Check equality between two Data instances Source code in quokka/data.py 84 85 86 def __eq__ ( self , other : Any ) -> bool : \"\"\"Check equality between two Data instances\"\"\" return type ( other ) is type ( self ) and other . proto_index == self . proto_index __init__ ( proto_index , data , program ) Constructor Source code in quokka/data.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def __init__ ( self , proto_index : Index , data : \"quokka.pb.Quokka.Data\" , program : quokka . Program ): \"\"\"Constructor\"\"\" self . proto_index : Index = proto_index self . address : AddressT = program . addresser . absolute ( data . offset ) self . type : \"DataType\" = DataType . from_proto ( data . type ) self . program : quokka . Program = program self . is_initialized : bool = not data . not_initialized self . size : Optional [ int ] = ( data . size if data . WhichOneof ( \"DataSize\" ) != \"no_size\" else None ) self . _value : Optional [ str ] = ( self . program . proto . string_table [ data . value_index ] if data . value_index > 0 else None ) self . name : Optional [ str ] = ( self . program . proto . string_table [ data . name_index ] if data . name_index > 0 else None ) code_references () property Returns code referencing this Data Source code in quokka/data.py 125 126 127 128 @property def code_references ( self ) -> List [ quokka . Reference ]: \"\"\"Returns code referencing this Data\"\"\" return [ ref for ref in self . references if isinstance ( ref . destination , tuple )] data_references () property Returns data references to/from this Data Source code in quokka/data.py 130 131 132 133 @property def data_references ( self ) -> List [ quokka . Reference ]: \"\"\"Returns data references to/from this Data\"\"\" return [ ref for ref in self . references if isinstance ( ref . destination , Data )] references () property References to/from this data Source code in quokka/data.py 120 121 122 123 @property def references ( self ) -> List [ quokka . Reference ]: \"\"\"References to/from this data\"\"\" return self . program . references . resolve_data ( self . proto_index ) value () property Data value. The value is read in the program binary file. Source code in quokka/data.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 @property def value ( self ) -> Any : \"\"\"Data value. The value is read in the program binary file. \"\"\" # Uninitialized memory if not self . is_initialized : return None address = self . program . addresser . file ( self . address ) if self . type in ( DataType . ALIGN , DataType . POINTER , DataType . STRUCT , DataType . UNKNOWN , ): return self . _value if self . type == DataType . ASCII : try : return self . program . executable . read_data ( address , self . type , size = self . size ) except quokka . exc . NotInFileError : logger . error ( \"Try to read a string which is not in file\" ) return \"\" else : return self . program . executable . read_data ( address , self . type ) DataHolder Bases: Mapping Data bucket All the data of the program are referenced in this bucket and allow to store them only once. Attributes: Name Type Description proto_data The protobuf data themselves program quokka . Program A reference to the Program Parameters: Name Type Description Default proto The protobuf data required program quokka . Program The program required TODO Type hinting for proto parameter (RepeatedCompositeFieldContainer) Source code in quokka/data.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 class DataHolder ( Mapping ): \"\"\"Data bucket All the data of the program are referenced in this bucket and allow to store them only once. Attributes: proto_data: The protobuf data themselves program: A reference to the Program Arguments: proto: The protobuf data program: The program TODO: Type hinting for proto parameter (RepeatedCompositeFieldContainer) \"\"\" def __init__ ( self , proto , program : quokka . Program ): \"\"\"Init method Arguments: proto: List of data in the protobuf program: Backref to the program \"\"\" self . proto_data = proto . data self . program : quokka . Program = program def __setitem__ ( self , key : Index , value : Data ) -> None : \"\"\"Set a data\"\"\" raise ValueError ( \"Should not be accessed\" ) def __delitem__ ( self , value : Index ) -> None : \"\"\"Remove a data from the bucket\"\"\" raise ValueError ( \"Should not be accessed\" ) def __getitem__ ( self , key : Index ) -> Data : \"\"\"Get a data from the bucket. Arguments: key: Data Index Returns: A Data \"\"\" return Data ( key , self . proto_data [ key ], self . program ) def get_data ( self , address : AddressT ) -> Data : \"\"\"Find a data by address Iterates over the data to find the one at a specified offset Arguments: address: Offset to query Returns: A Data Raises: ValueError: if no data is found \"\"\" # We have to iterate over every data because they are not sorted by offset for index , data_proto in enumerate ( self . proto_data ): if data_proto . offset + self . program . base_address == address : return self [ index ] raise ValueError ( f \"No data at offset 0x { address : x } \" ) def __len__ ( self ) -> int : \"\"\"Number of data in the program\"\"\" return len ( self . proto_data ) def __iter__ ( self ): \"\"\"Do not allow the iteration over the data\"\"\" raise ValueError ( \"Should not be accessed\" ) __delitem__ ( value ) Remove a data from the bucket Source code in quokka/data.py 168 169 170 def __delitem__ ( self , value : Index ) -> None : \"\"\"Remove a data from the bucket\"\"\" raise ValueError ( \"Should not be accessed\" ) __getitem__ ( key ) Get a data from the bucket. Parameters: Name Type Description Default key Index Data Index required Returns: Type Description Data A Data Source code in quokka/data.py 172 173 174 175 176 177 178 179 180 181 def __getitem__ ( self , key : Index ) -> Data : \"\"\"Get a data from the bucket. Arguments: key: Data Index Returns: A Data \"\"\" return Data ( key , self . proto_data [ key ], self . program ) __init__ ( proto , program ) Init method Parameters: Name Type Description Default proto List of data in the protobuf required program quokka . Program Backref to the program required Source code in quokka/data.py 154 155 156 157 158 159 160 161 162 def __init__ ( self , proto , program : quokka . Program ): \"\"\"Init method Arguments: proto: List of data in the protobuf program: Backref to the program \"\"\" self . proto_data = proto . data self . program : quokka . Program = program __iter__ () Do not allow the iteration over the data Source code in quokka/data.py 209 210 211 def __iter__ ( self ): \"\"\"Do not allow the iteration over the data\"\"\" raise ValueError ( \"Should not be accessed\" ) __len__ () Number of data in the program Source code in quokka/data.py 205 206 207 def __len__ ( self ) -> int : \"\"\"Number of data in the program\"\"\" return len ( self . proto_data ) __setitem__ ( key , value ) Set a data Source code in quokka/data.py 164 165 166 def __setitem__ ( self , key : Index , value : Data ) -> None : \"\"\"Set a data\"\"\" raise ValueError ( \"Should not be accessed\" ) get_data ( address ) Find a data by address Iterates over the data to find the one at a specified offset Parameters: Name Type Description Default address AddressT Offset to query required Returns: Type Description Data A Data Raises: Type Description ValueError if no data is found Source code in quokka/data.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def get_data ( self , address : AddressT ) -> Data : \"\"\"Find a data by address Iterates over the data to find the one at a specified offset Arguments: address: Offset to query Returns: A Data Raises: ValueError: if no data is found \"\"\" # We have to iterate over every data because they are not sorted by offset for index , data_proto in enumerate ( self . proto_data ): if data_proto . offset + self . program . base_address == address : return self [ index ] raise ValueError ( f \"No data at offset 0x { address : x } \" )","title":"data"},{"location":"reference/python/data/#quokka.data.Data","text":"Base class for data. All data have at least a type and a value. They are referenced inside the program by and to other data and code. Parameters: Name Type Description Default proto_index Index Index in the protobuf required data Data Protobuf value of the data. required program quokka . Program Program backref required Attributes: Name Type Description proto_index Index Index in the protobuf address AddressT Data address type DataType Data type program quokka . Program Reference to the Program is_initialized bool Is the data initialized? size Optional [ int ] Data size (depends on the type usually) name Optional [ str ] Data name (if any) Source code in quokka/data.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 class Data : \"\"\"Base class for data. All data have at least a type and a value. They are referenced inside the program by and to other data and code. Parameters: proto_index: Index in the protobuf data: Protobuf value of the data. program: Program backref Attributes: proto_index: Index in the protobuf address: Data address type: Data type program: Reference to the Program is_initialized: Is the data initialized? size: Data size (depends on the type usually) name: Data name (if any) \"\"\" def __init__ ( self , proto_index : Index , data : \"quokka.pb.Quokka.Data\" , program : quokka . Program ): \"\"\"Constructor\"\"\" self . proto_index : Index = proto_index self . address : AddressT = program . addresser . absolute ( data . offset ) self . type : \"DataType\" = DataType . from_proto ( data . type ) self . program : quokka . Program = program self . is_initialized : bool = not data . not_initialized self . size : Optional [ int ] = ( data . size if data . WhichOneof ( \"DataSize\" ) != \"no_size\" else None ) self . _value : Optional [ str ] = ( self . program . proto . string_table [ data . value_index ] if data . value_index > 0 else None ) self . name : Optional [ str ] = ( self . program . proto . string_table [ data . name_index ] if data . name_index > 0 else None ) def __eq__ ( self , other : Any ) -> bool : \"\"\"Check equality between two Data instances\"\"\" return type ( other ) is type ( self ) and other . proto_index == self . proto_index @property def value ( self ) -> Any : \"\"\"Data value. The value is read in the program binary file. \"\"\" # Uninitialized memory if not self . is_initialized : return None address = self . program . addresser . file ( self . address ) if self . type in ( DataType . ALIGN , DataType . POINTER , DataType . STRUCT , DataType . UNKNOWN , ): return self . _value if self . type == DataType . ASCII : try : return self . program . executable . read_data ( address , self . type , size = self . size ) except quokka . exc . NotInFileError : logger . error ( \"Try to read a string which is not in file\" ) return \"\" else : return self . program . executable . read_data ( address , self . type ) @property def references ( self ) -> List [ quokka . Reference ]: \"\"\"References to/from this data\"\"\" return self . program . references . resolve_data ( self . proto_index ) @property def code_references ( self ) -> List [ quokka . Reference ]: \"\"\"Returns code referencing this Data\"\"\" return [ ref for ref in self . references if isinstance ( ref . destination , tuple )] @property def data_references ( self ) -> List [ quokka . Reference ]: \"\"\"Returns data references to/from this Data\"\"\" return [ ref for ref in self . references if isinstance ( ref . destination , Data )]","title":"Data"},{"location":"reference/python/data/#quokka.data.Data.__eq__","text":"Check equality between two Data instances Source code in quokka/data.py 84 85 86 def __eq__ ( self , other : Any ) -> bool : \"\"\"Check equality between two Data instances\"\"\" return type ( other ) is type ( self ) and other . proto_index == self . proto_index","title":"__eq__()"},{"location":"reference/python/data/#quokka.data.Data.__init__","text":"Constructor Source code in quokka/data.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def __init__ ( self , proto_index : Index , data : \"quokka.pb.Quokka.Data\" , program : quokka . Program ): \"\"\"Constructor\"\"\" self . proto_index : Index = proto_index self . address : AddressT = program . addresser . absolute ( data . offset ) self . type : \"DataType\" = DataType . from_proto ( data . type ) self . program : quokka . Program = program self . is_initialized : bool = not data . not_initialized self . size : Optional [ int ] = ( data . size if data . WhichOneof ( \"DataSize\" ) != \"no_size\" else None ) self . _value : Optional [ str ] = ( self . program . proto . string_table [ data . value_index ] if data . value_index > 0 else None ) self . name : Optional [ str ] = ( self . program . proto . string_table [ data . name_index ] if data . name_index > 0 else None )","title":"__init__()"},{"location":"reference/python/data/#quokka.data.Data.code_references","text":"Returns code referencing this Data Source code in quokka/data.py 125 126 127 128 @property def code_references ( self ) -> List [ quokka . Reference ]: \"\"\"Returns code referencing this Data\"\"\" return [ ref for ref in self . references if isinstance ( ref . destination , tuple )]","title":"code_references()"},{"location":"reference/python/data/#quokka.data.Data.data_references","text":"Returns data references to/from this Data Source code in quokka/data.py 130 131 132 133 @property def data_references ( self ) -> List [ quokka . Reference ]: \"\"\"Returns data references to/from this Data\"\"\" return [ ref for ref in self . references if isinstance ( ref . destination , Data )]","title":"data_references()"},{"location":"reference/python/data/#quokka.data.Data.references","text":"References to/from this data Source code in quokka/data.py 120 121 122 123 @property def references ( self ) -> List [ quokka . Reference ]: \"\"\"References to/from this data\"\"\" return self . program . references . resolve_data ( self . proto_index )","title":"references()"},{"location":"reference/python/data/#quokka.data.Data.value","text":"Data value. The value is read in the program binary file. Source code in quokka/data.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 @property def value ( self ) -> Any : \"\"\"Data value. The value is read in the program binary file. \"\"\" # Uninitialized memory if not self . is_initialized : return None address = self . program . addresser . file ( self . address ) if self . type in ( DataType . ALIGN , DataType . POINTER , DataType . STRUCT , DataType . UNKNOWN , ): return self . _value if self . type == DataType . ASCII : try : return self . program . executable . read_data ( address , self . type , size = self . size ) except quokka . exc . NotInFileError : logger . error ( \"Try to read a string which is not in file\" ) return \"\" else : return self . program . executable . read_data ( address , self . type )","title":"value()"},{"location":"reference/python/data/#quokka.data.DataHolder","text":"Bases: Mapping Data bucket All the data of the program are referenced in this bucket and allow to store them only once. Attributes: Name Type Description proto_data The protobuf data themselves program quokka . Program A reference to the Program Parameters: Name Type Description Default proto The protobuf data required program quokka . Program The program required TODO Type hinting for proto parameter (RepeatedCompositeFieldContainer) Source code in quokka/data.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 class DataHolder ( Mapping ): \"\"\"Data bucket All the data of the program are referenced in this bucket and allow to store them only once. Attributes: proto_data: The protobuf data themselves program: A reference to the Program Arguments: proto: The protobuf data program: The program TODO: Type hinting for proto parameter (RepeatedCompositeFieldContainer) \"\"\" def __init__ ( self , proto , program : quokka . Program ): \"\"\"Init method Arguments: proto: List of data in the protobuf program: Backref to the program \"\"\" self . proto_data = proto . data self . program : quokka . Program = program def __setitem__ ( self , key : Index , value : Data ) -> None : \"\"\"Set a data\"\"\" raise ValueError ( \"Should not be accessed\" ) def __delitem__ ( self , value : Index ) -> None : \"\"\"Remove a data from the bucket\"\"\" raise ValueError ( \"Should not be accessed\" ) def __getitem__ ( self , key : Index ) -> Data : \"\"\"Get a data from the bucket. Arguments: key: Data Index Returns: A Data \"\"\" return Data ( key , self . proto_data [ key ], self . program ) def get_data ( self , address : AddressT ) -> Data : \"\"\"Find a data by address Iterates over the data to find the one at a specified offset Arguments: address: Offset to query Returns: A Data Raises: ValueError: if no data is found \"\"\" # We have to iterate over every data because they are not sorted by offset for index , data_proto in enumerate ( self . proto_data ): if data_proto . offset + self . program . base_address == address : return self [ index ] raise ValueError ( f \"No data at offset 0x { address : x } \" ) def __len__ ( self ) -> int : \"\"\"Number of data in the program\"\"\" return len ( self . proto_data ) def __iter__ ( self ): \"\"\"Do not allow the iteration over the data\"\"\" raise ValueError ( \"Should not be accessed\" )","title":"DataHolder"},{"location":"reference/python/data/#quokka.data.DataHolder.__delitem__","text":"Remove a data from the bucket Source code in quokka/data.py 168 169 170 def __delitem__ ( self , value : Index ) -> None : \"\"\"Remove a data from the bucket\"\"\" raise ValueError ( \"Should not be accessed\" )","title":"__delitem__()"},{"location":"reference/python/data/#quokka.data.DataHolder.__getitem__","text":"Get a data from the bucket. Parameters: Name Type Description Default key Index Data Index required Returns: Type Description Data A Data Source code in quokka/data.py 172 173 174 175 176 177 178 179 180 181 def __getitem__ ( self , key : Index ) -> Data : \"\"\"Get a data from the bucket. Arguments: key: Data Index Returns: A Data \"\"\" return Data ( key , self . proto_data [ key ], self . program )","title":"__getitem__()"},{"location":"reference/python/data/#quokka.data.DataHolder.__init__","text":"Init method Parameters: Name Type Description Default proto List of data in the protobuf required program quokka . Program Backref to the program required Source code in quokka/data.py 154 155 156 157 158 159 160 161 162 def __init__ ( self , proto , program : quokka . Program ): \"\"\"Init method Arguments: proto: List of data in the protobuf program: Backref to the program \"\"\" self . proto_data = proto . data self . program : quokka . Program = program","title":"__init__()"},{"location":"reference/python/data/#quokka.data.DataHolder.__iter__","text":"Do not allow the iteration over the data Source code in quokka/data.py 209 210 211 def __iter__ ( self ): \"\"\"Do not allow the iteration over the data\"\"\" raise ValueError ( \"Should not be accessed\" )","title":"__iter__()"},{"location":"reference/python/data/#quokka.data.DataHolder.__len__","text":"Number of data in the program Source code in quokka/data.py 205 206 207 def __len__ ( self ) -> int : \"\"\"Number of data in the program\"\"\" return len ( self . proto_data )","title":"__len__()"},{"location":"reference/python/data/#quokka.data.DataHolder.__setitem__","text":"Set a data Source code in quokka/data.py 164 165 166 def __setitem__ ( self , key : Index , value : Data ) -> None : \"\"\"Set a data\"\"\" raise ValueError ( \"Should not be accessed\" )","title":"__setitem__()"},{"location":"reference/python/data/#quokka.data.DataHolder.get_data","text":"Find a data by address Iterates over the data to find the one at a specified offset Parameters: Name Type Description Default address AddressT Offset to query required Returns: Type Description Data A Data Raises: Type Description ValueError if no data is found Source code in quokka/data.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def get_data ( self , address : AddressT ) -> Data : \"\"\"Find a data by address Iterates over the data to find the one at a specified offset Arguments: address: Offset to query Returns: A Data Raises: ValueError: if no data is found \"\"\" # We have to iterate over every data because they are not sorted by offset for index , data_proto in enumerate ( self . proto_data ): if data_proto . offset + self . program . base_address == address : return self [ index ] raise ValueError ( f \"No data at offset 0x { address : x } \" )","title":"get_data()"},{"location":"reference/python/exc/","text":"Exceptions for quokka. All exceptions must derive from the QuokkaError. CapstoneError Bases: QuokkaError Exceptions used for Capstone integration Source code in quokka/exc.py 45 46 class CapstoneError ( QuokkaError ): \"\"\"Exceptions used for Capstone integration\"\"\" ChunkMissingError Bases: QuokkaError Raised when a chunk has not been found Source code in quokka/exc.py 29 30 class ChunkMissingError ( QuokkaError ): \"\"\"Raised when a chunk has not been found\"\"\" FunctionMissingError Bases: QuokkaError Raised when a function has not been found Source code in quokka/exc.py 33 34 class FunctionMissingError ( QuokkaError ): \"\"\"Raised when a function has not been found\"\"\" InstructionError Bases: QuokkaError Raised when serious errors in Instructions handling Source code in quokka/exc.py 41 42 class InstructionError ( QuokkaError ): \"\"\"Raised when serious errors in Instructions handling\"\"\" NotInFileError Bases: QuokkaError Raised when trying to read a string outside the file Source code in quokka/exc.py 25 26 class NotInFileError ( QuokkaError ): \"\"\"Raised when trying to read a string outside the file\"\"\" PypcodeError Bases: QuokkaError Main exception for pypcode integration Source code in quokka/exc.py 49 50 class PypcodeError ( QuokkaError ): \"\"\"Main exception for pypcode integration\"\"\" QuokkaError Bases: Exception Base exception in Quokka Source code in quokka/exc.py 21 22 class QuokkaError ( Exception ): \"\"\"Base exception in Quokka\"\"\" ThunkMissingError Bases: QuokkaError Raised when a thunk has not been found Source code in quokka/exc.py 37 38 class ThunkMissingError ( QuokkaError ): \"\"\"Raised when a thunk has not been found\"\"\"","title":"exc"},{"location":"reference/python/exc/#quokka.exc.CapstoneError","text":"Bases: QuokkaError Exceptions used for Capstone integration Source code in quokka/exc.py 45 46 class CapstoneError ( QuokkaError ): \"\"\"Exceptions used for Capstone integration\"\"\"","title":"CapstoneError"},{"location":"reference/python/exc/#quokka.exc.ChunkMissingError","text":"Bases: QuokkaError Raised when a chunk has not been found Source code in quokka/exc.py 29 30 class ChunkMissingError ( QuokkaError ): \"\"\"Raised when a chunk has not been found\"\"\"","title":"ChunkMissingError"},{"location":"reference/python/exc/#quokka.exc.FunctionMissingError","text":"Bases: QuokkaError Raised when a function has not been found Source code in quokka/exc.py 33 34 class FunctionMissingError ( QuokkaError ): \"\"\"Raised when a function has not been found\"\"\"","title":"FunctionMissingError"},{"location":"reference/python/exc/#quokka.exc.InstructionError","text":"Bases: QuokkaError Raised when serious errors in Instructions handling Source code in quokka/exc.py 41 42 class InstructionError ( QuokkaError ): \"\"\"Raised when serious errors in Instructions handling\"\"\"","title":"InstructionError"},{"location":"reference/python/exc/#quokka.exc.NotInFileError","text":"Bases: QuokkaError Raised when trying to read a string outside the file Source code in quokka/exc.py 25 26 class NotInFileError ( QuokkaError ): \"\"\"Raised when trying to read a string outside the file\"\"\"","title":"NotInFileError"},{"location":"reference/python/exc/#quokka.exc.PypcodeError","text":"Bases: QuokkaError Main exception for pypcode integration Source code in quokka/exc.py 49 50 class PypcodeError ( QuokkaError ): \"\"\"Main exception for pypcode integration\"\"\"","title":"PypcodeError"},{"location":"reference/python/exc/#quokka.exc.QuokkaError","text":"Bases: Exception Base exception in Quokka Source code in quokka/exc.py 21 22 class QuokkaError ( Exception ): \"\"\"Base exception in Quokka\"\"\"","title":"QuokkaError"},{"location":"reference/python/exc/#quokka.exc.ThunkMissingError","text":"Bases: QuokkaError Raised when a thunk has not been found Source code in quokka/exc.py 37 38 class ThunkMissingError ( QuokkaError ): \"\"\"Raised when a thunk has not been found\"\"\"","title":"ThunkMissingError"},{"location":"reference/python/executable/","text":"Executable: management of the binary file in itself. Executable The executable class is used to interact with the binary file. It handles access to the binary file itself (not the exported) for reads. Note: The binary is read only once and stored in memory. This is done for performance purposes but does not cope well with low RAM systems and/or huge binaries. Parameters: Name Type Description Default path Union [ str , pathlib . Path ] Path towards the executable file required endianness Endianness How are stored the data required Attributes: Name Type Description exec_file pathlib . Path Path towards the executable file endianness Endianness Binary endianness content bytes Bytes of the binary Raises: Type Description ValueError If the file is not found Source code in quokka/executable.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 class Executable : \"\"\"The executable class is used to interact with the binary file. It handles access to the binary file itself (not the exported) for reads. Note: The binary is read only once and stored in memory. This is done for performance purposes but does not cope well with low RAM systems and/or huge binaries. Arguments: path: Path towards the executable file endianness: How are stored the data Attributes: exec_file: Path towards the executable file endianness: Binary endianness content: Bytes of the binary Raises: ValueError: If the file is not found \"\"\" def __init__ ( self , path : Union [ str , pathlib . Path ], endianness : Endianness ): \"\"\"Constructor\"\"\" try : with open ( path , \"rb\" ) as file : self . content : bytes = file . read () except FileNotFoundError : raise ValueError ( \"File not found\" ) self . exec_file : pathlib . Path = pathlib . Path ( path ) self . endianness : Endianness = endianness def read ( self , offset : int , size : int ) -> bytes : \"\"\"Read `size` at `offset` in the file. This method should not be used directly and considered as part of a private API. The preferred method are read_byte / read_string . Arguments: offset: File offset size: Read size Returns: The content that has been read Raises: ValueError: when the value is not in the file \"\"\" try : return self . content [ offset : offset + size ] except IndexError as exc : raise ValueError ( f \"Content not found at offset { offset } \" ) from exc def read_string ( self , offset : int , size : Optional [ int ] = None ) -> str : \"\"\"Read a string in the file. If the size is not given, Quokka will try to read the string until the first null byte. That works only for null-terminated strings. If the string is null terminated, remove the trailing 0. Arguments: offset: String file offset size: String size if known. Returns: The decoded string Raises: ValueError: If the string is not found nor decoded. \"\"\" if size is not None : try : string = self . read ( offset , size ) . decode ( \"utf-8\" ) except UnicodeDecodeError as exc : raise ValueError ( \"Unable to read or decode the string.\" ) from exc else : try : null_byte = self . content . index ( b \" \\x00 \" , offset ) except ValueError as exc : raise ValueError ( \"String is not null-terminated and size was not given\" ) from exc string = self . content [ offset : null_byte ] . decode ( \"utf-8\" ) # FIX: When returning a single character string, it does not end with a '\\0' if len ( string ) > 1 and string . endswith ( \" \\x00 \" ): return string [: - 1 ] return string def read_data ( self , offset : int , data_type : DataType , size : Optional [ int ] = None ) -> Union [ int , float , str ]: \"\"\"Read the data value. If the size is not specified, it is inferred from the data type. Arguments: offset: Data file offset data_type: Data type size: Read size Returns: The data value \"\"\" # Read an int of size `read_size` def read_int ( read_size : int ) -> int : \"\"\"Read an integer from the binary\"\"\" return int . from_bytes ( self . read_byte ( offset , read_size ), endianness ) endianness : Literal [ \"big\" , \"little\" ] if self . endianness == Endianness . BIG_ENDIAN : endianness = \"big\" endianness_sign = \">\" else : endianness = \"little\" endianness_sign = \"<\" if data_type == DataType . ASCII : if size is None : raise ValueError ( \"No size specified when reading a DataType.ASCII\" ) return self . read_string ( offset , size ) elif data_type == DataType . BYTE : return read_int ( 1 if size is None else size ) elif data_type == DataType . WORD : return read_int ( 2 if size is None else size ) elif data_type == DataType . DOUBLE_WORD : return read_int ( 4 if size is None else size ) elif data_type == DataType . QUAD_WORD : return read_int ( 8 if size is None else size ) elif data_type == DataType . OCTO_WORD : return read_int ( 16 if size is None else size ) elif data_type == DataType . FLOAT : s = 4 if size is None else size return struct . unpack ( f \" { endianness_sign } f\" , self . read_byte ( offset , s )) elif data_type == DataType . DOUBLE : s = 8 if size is None else size return struct . unpack ( f \" { endianness_sign } d\" , self . read_byte ( offset , s )) else : raise NotImplementedError ( f \"Cannot read { data_type } . DataType not implemented.\" ) def read_byte ( self , offset : int , size : int ) -> bytes : \"\"\"Read one (or more) byte(s) in the file at `offset`. This is mostly used to read instructions. Arguments: offset: File offset to read size: Number of bytes to read Returns: The bytes values \"\"\" return self . read ( offset , size ) __init__ ( path , endianness ) Constructor Source code in quokka/executable.py 45 46 47 48 49 50 51 52 53 54 55 def __init__ ( self , path : Union [ str , pathlib . Path ], endianness : Endianness ): \"\"\"Constructor\"\"\" try : with open ( path , \"rb\" ) as file : self . content : bytes = file . read () except FileNotFoundError : raise ValueError ( \"File not found\" ) self . exec_file : pathlib . Path = pathlib . Path ( path ) self . endianness : Endianness = endianness read ( offset , size ) Read size at offset in the file. This method should not be used directly and considered as part of a private API. The preferred method are read_byte / read_string . Parameters: Name Type Description Default offset int File offset required size int Read size required Returns: Type Description bytes The content that has been read Raises: Type Description ValueError when the value is not in the file Source code in quokka/executable.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def read ( self , offset : int , size : int ) -> bytes : \"\"\"Read `size` at `offset` in the file. This method should not be used directly and considered as part of a private API. The preferred method are read_byte / read_string . Arguments: offset: File offset size: Read size Returns: The content that has been read Raises: ValueError: when the value is not in the file \"\"\" try : return self . content [ offset : offset + size ] except IndexError as exc : raise ValueError ( f \"Content not found at offset { offset } \" ) from exc read_byte ( offset , size ) Read one (or more) byte(s) in the file at offset . This is mostly used to read instructions. Parameters: Name Type Description Default offset int File offset to read required size int Number of bytes to read required Returns: Type Description bytes The bytes values Source code in quokka/executable.py 170 171 172 173 174 175 176 177 178 179 180 181 182 def read_byte ( self , offset : int , size : int ) -> bytes : \"\"\"Read one (or more) byte(s) in the file at `offset`. This is mostly used to read instructions. Arguments: offset: File offset to read size: Number of bytes to read Returns: The bytes values \"\"\" return self . read ( offset , size ) read_data ( offset , data_type , size = None ) Read the data value. If the size is not specified, it is inferred from the data type. Parameters: Name Type Description Default offset int Data file offset required data_type DataType Data type required size Optional [ int ] Read size None Returns: Type Description Union [ int , float , str ] The data value Source code in quokka/executable.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def read_data ( self , offset : int , data_type : DataType , size : Optional [ int ] = None ) -> Union [ int , float , str ]: \"\"\"Read the data value. If the size is not specified, it is inferred from the data type. Arguments: offset: Data file offset data_type: Data type size: Read size Returns: The data value \"\"\" # Read an int of size `read_size` def read_int ( read_size : int ) -> int : \"\"\"Read an integer from the binary\"\"\" return int . from_bytes ( self . read_byte ( offset , read_size ), endianness ) endianness : Literal [ \"big\" , \"little\" ] if self . endianness == Endianness . BIG_ENDIAN : endianness = \"big\" endianness_sign = \">\" else : endianness = \"little\" endianness_sign = \"<\" if data_type == DataType . ASCII : if size is None : raise ValueError ( \"No size specified when reading a DataType.ASCII\" ) return self . read_string ( offset , size ) elif data_type == DataType . BYTE : return read_int ( 1 if size is None else size ) elif data_type == DataType . WORD : return read_int ( 2 if size is None else size ) elif data_type == DataType . DOUBLE_WORD : return read_int ( 4 if size is None else size ) elif data_type == DataType . QUAD_WORD : return read_int ( 8 if size is None else size ) elif data_type == DataType . OCTO_WORD : return read_int ( 16 if size is None else size ) elif data_type == DataType . FLOAT : s = 4 if size is None else size return struct . unpack ( f \" { endianness_sign } f\" , self . read_byte ( offset , s )) elif data_type == DataType . DOUBLE : s = 8 if size is None else size return struct . unpack ( f \" { endianness_sign } d\" , self . read_byte ( offset , s )) else : raise NotImplementedError ( f \"Cannot read { data_type } . DataType not implemented.\" ) read_string ( offset , size = None ) Read a string in the file. If the size is not given, Quokka will try to read the string until the first null byte. That works only for null-terminated strings. If the string is null terminated, remove the trailing 0. Parameters: Name Type Description Default offset int String file offset required size Optional [ int ] String size if known. None Returns: Type Description str The decoded string Raises: Type Description ValueError If the string is not found nor decoded. Source code in quokka/executable.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def read_string ( self , offset : int , size : Optional [ int ] = None ) -> str : \"\"\"Read a string in the file. If the size is not given, Quokka will try to read the string until the first null byte. That works only for null-terminated strings. If the string is null terminated, remove the trailing 0. Arguments: offset: String file offset size: String size if known. Returns: The decoded string Raises: ValueError: If the string is not found nor decoded. \"\"\" if size is not None : try : string = self . read ( offset , size ) . decode ( \"utf-8\" ) except UnicodeDecodeError as exc : raise ValueError ( \"Unable to read or decode the string.\" ) from exc else : try : null_byte = self . content . index ( b \" \\x00 \" , offset ) except ValueError as exc : raise ValueError ( \"String is not null-terminated and size was not given\" ) from exc string = self . content [ offset : null_byte ] . decode ( \"utf-8\" ) # FIX: When returning a single character string, it does not end with a '\\0' if len ( string ) > 1 and string . endswith ( \" \\x00 \" ): return string [: - 1 ] return string","title":"executable"},{"location":"reference/python/executable/#quokka.executable.Executable","text":"The executable class is used to interact with the binary file. It handles access to the binary file itself (not the exported) for reads. Note: The binary is read only once and stored in memory. This is done for performance purposes but does not cope well with low RAM systems and/or huge binaries. Parameters: Name Type Description Default path Union [ str , pathlib . Path ] Path towards the executable file required endianness Endianness How are stored the data required Attributes: Name Type Description exec_file pathlib . Path Path towards the executable file endianness Endianness Binary endianness content bytes Bytes of the binary Raises: Type Description ValueError If the file is not found Source code in quokka/executable.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 class Executable : \"\"\"The executable class is used to interact with the binary file. It handles access to the binary file itself (not the exported) for reads. Note: The binary is read only once and stored in memory. This is done for performance purposes but does not cope well with low RAM systems and/or huge binaries. Arguments: path: Path towards the executable file endianness: How are stored the data Attributes: exec_file: Path towards the executable file endianness: Binary endianness content: Bytes of the binary Raises: ValueError: If the file is not found \"\"\" def __init__ ( self , path : Union [ str , pathlib . Path ], endianness : Endianness ): \"\"\"Constructor\"\"\" try : with open ( path , \"rb\" ) as file : self . content : bytes = file . read () except FileNotFoundError : raise ValueError ( \"File not found\" ) self . exec_file : pathlib . Path = pathlib . Path ( path ) self . endianness : Endianness = endianness def read ( self , offset : int , size : int ) -> bytes : \"\"\"Read `size` at `offset` in the file. This method should not be used directly and considered as part of a private API. The preferred method are read_byte / read_string . Arguments: offset: File offset size: Read size Returns: The content that has been read Raises: ValueError: when the value is not in the file \"\"\" try : return self . content [ offset : offset + size ] except IndexError as exc : raise ValueError ( f \"Content not found at offset { offset } \" ) from exc def read_string ( self , offset : int , size : Optional [ int ] = None ) -> str : \"\"\"Read a string in the file. If the size is not given, Quokka will try to read the string until the first null byte. That works only for null-terminated strings. If the string is null terminated, remove the trailing 0. Arguments: offset: String file offset size: String size if known. Returns: The decoded string Raises: ValueError: If the string is not found nor decoded. \"\"\" if size is not None : try : string = self . read ( offset , size ) . decode ( \"utf-8\" ) except UnicodeDecodeError as exc : raise ValueError ( \"Unable to read or decode the string.\" ) from exc else : try : null_byte = self . content . index ( b \" \\x00 \" , offset ) except ValueError as exc : raise ValueError ( \"String is not null-terminated and size was not given\" ) from exc string = self . content [ offset : null_byte ] . decode ( \"utf-8\" ) # FIX: When returning a single character string, it does not end with a '\\0' if len ( string ) > 1 and string . endswith ( \" \\x00 \" ): return string [: - 1 ] return string def read_data ( self , offset : int , data_type : DataType , size : Optional [ int ] = None ) -> Union [ int , float , str ]: \"\"\"Read the data value. If the size is not specified, it is inferred from the data type. Arguments: offset: Data file offset data_type: Data type size: Read size Returns: The data value \"\"\" # Read an int of size `read_size` def read_int ( read_size : int ) -> int : \"\"\"Read an integer from the binary\"\"\" return int . from_bytes ( self . read_byte ( offset , read_size ), endianness ) endianness : Literal [ \"big\" , \"little\" ] if self . endianness == Endianness . BIG_ENDIAN : endianness = \"big\" endianness_sign = \">\" else : endianness = \"little\" endianness_sign = \"<\" if data_type == DataType . ASCII : if size is None : raise ValueError ( \"No size specified when reading a DataType.ASCII\" ) return self . read_string ( offset , size ) elif data_type == DataType . BYTE : return read_int ( 1 if size is None else size ) elif data_type == DataType . WORD : return read_int ( 2 if size is None else size ) elif data_type == DataType . DOUBLE_WORD : return read_int ( 4 if size is None else size ) elif data_type == DataType . QUAD_WORD : return read_int ( 8 if size is None else size ) elif data_type == DataType . OCTO_WORD : return read_int ( 16 if size is None else size ) elif data_type == DataType . FLOAT : s = 4 if size is None else size return struct . unpack ( f \" { endianness_sign } f\" , self . read_byte ( offset , s )) elif data_type == DataType . DOUBLE : s = 8 if size is None else size return struct . unpack ( f \" { endianness_sign } d\" , self . read_byte ( offset , s )) else : raise NotImplementedError ( f \"Cannot read { data_type } . DataType not implemented.\" ) def read_byte ( self , offset : int , size : int ) -> bytes : \"\"\"Read one (or more) byte(s) in the file at `offset`. This is mostly used to read instructions. Arguments: offset: File offset to read size: Number of bytes to read Returns: The bytes values \"\"\" return self . read ( offset , size )","title":"Executable"},{"location":"reference/python/executable/#quokka.executable.Executable.__init__","text":"Constructor Source code in quokka/executable.py 45 46 47 48 49 50 51 52 53 54 55 def __init__ ( self , path : Union [ str , pathlib . Path ], endianness : Endianness ): \"\"\"Constructor\"\"\" try : with open ( path , \"rb\" ) as file : self . content : bytes = file . read () except FileNotFoundError : raise ValueError ( \"File not found\" ) self . exec_file : pathlib . Path = pathlib . Path ( path ) self . endianness : Endianness = endianness","title":"__init__()"},{"location":"reference/python/executable/#quokka.executable.Executable.read","text":"Read size at offset in the file. This method should not be used directly and considered as part of a private API. The preferred method are read_byte / read_string . Parameters: Name Type Description Default offset int File offset required size int Read size required Returns: Type Description bytes The content that has been read Raises: Type Description ValueError when the value is not in the file Source code in quokka/executable.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def read ( self , offset : int , size : int ) -> bytes : \"\"\"Read `size` at `offset` in the file. This method should not be used directly and considered as part of a private API. The preferred method are read_byte / read_string . Arguments: offset: File offset size: Read size Returns: The content that has been read Raises: ValueError: when the value is not in the file \"\"\" try : return self . content [ offset : offset + size ] except IndexError as exc : raise ValueError ( f \"Content not found at offset { offset } \" ) from exc","title":"read()"},{"location":"reference/python/executable/#quokka.executable.Executable.read_byte","text":"Read one (or more) byte(s) in the file at offset . This is mostly used to read instructions. Parameters: Name Type Description Default offset int File offset to read required size int Number of bytes to read required Returns: Type Description bytes The bytes values Source code in quokka/executable.py 170 171 172 173 174 175 176 177 178 179 180 181 182 def read_byte ( self , offset : int , size : int ) -> bytes : \"\"\"Read one (or more) byte(s) in the file at `offset`. This is mostly used to read instructions. Arguments: offset: File offset to read size: Number of bytes to read Returns: The bytes values \"\"\" return self . read ( offset , size )","title":"read_byte()"},{"location":"reference/python/executable/#quokka.executable.Executable.read_data","text":"Read the data value. If the size is not specified, it is inferred from the data type. Parameters: Name Type Description Default offset int Data file offset required data_type DataType Data type required size Optional [ int ] Read size None Returns: Type Description Union [ int , float , str ] The data value Source code in quokka/executable.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def read_data ( self , offset : int , data_type : DataType , size : Optional [ int ] = None ) -> Union [ int , float , str ]: \"\"\"Read the data value. If the size is not specified, it is inferred from the data type. Arguments: offset: Data file offset data_type: Data type size: Read size Returns: The data value \"\"\" # Read an int of size `read_size` def read_int ( read_size : int ) -> int : \"\"\"Read an integer from the binary\"\"\" return int . from_bytes ( self . read_byte ( offset , read_size ), endianness ) endianness : Literal [ \"big\" , \"little\" ] if self . endianness == Endianness . BIG_ENDIAN : endianness = \"big\" endianness_sign = \">\" else : endianness = \"little\" endianness_sign = \"<\" if data_type == DataType . ASCII : if size is None : raise ValueError ( \"No size specified when reading a DataType.ASCII\" ) return self . read_string ( offset , size ) elif data_type == DataType . BYTE : return read_int ( 1 if size is None else size ) elif data_type == DataType . WORD : return read_int ( 2 if size is None else size ) elif data_type == DataType . DOUBLE_WORD : return read_int ( 4 if size is None else size ) elif data_type == DataType . QUAD_WORD : return read_int ( 8 if size is None else size ) elif data_type == DataType . OCTO_WORD : return read_int ( 16 if size is None else size ) elif data_type == DataType . FLOAT : s = 4 if size is None else size return struct . unpack ( f \" { endianness_sign } f\" , self . read_byte ( offset , s )) elif data_type == DataType . DOUBLE : s = 8 if size is None else size return struct . unpack ( f \" { endianness_sign } d\" , self . read_byte ( offset , s )) else : raise NotImplementedError ( f \"Cannot read { data_type } . DataType not implemented.\" )","title":"read_data()"},{"location":"reference/python/executable/#quokka.executable.Executable.read_string","text":"Read a string in the file. If the size is not given, Quokka will try to read the string until the first null byte. That works only for null-terminated strings. If the string is null terminated, remove the trailing 0. Parameters: Name Type Description Default offset int String file offset required size Optional [ int ] String size if known. None Returns: Type Description str The decoded string Raises: Type Description ValueError If the string is not found nor decoded. Source code in quokka/executable.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def read_string ( self , offset : int , size : Optional [ int ] = None ) -> str : \"\"\"Read a string in the file. If the size is not given, Quokka will try to read the string until the first null byte. That works only for null-terminated strings. If the string is null terminated, remove the trailing 0. Arguments: offset: String file offset size: String size if known. Returns: The decoded string Raises: ValueError: If the string is not found nor decoded. \"\"\" if size is not None : try : string = self . read ( offset , size ) . decode ( \"utf-8\" ) except UnicodeDecodeError as exc : raise ValueError ( \"Unable to read or decode the string.\" ) from exc else : try : null_byte = self . content . index ( b \" \\x00 \" , offset ) except ValueError as exc : raise ValueError ( \"String is not null-terminated and size was not given\" ) from exc string = self . content [ offset : null_byte ] . decode ( \"utf-8\" ) # FIX: When returning a single character string, it does not end with a '\\0' if len ( string ) > 1 and string . endswith ( \" \\x00 \" ): return string [: - 1 ] return string","title":"read_string()"},{"location":"reference/python/function/","text":"Functions and chunk management Chunk Bases: MutableMapping , Iterable Chunk object A chunk is an IDA specific item that is used for code reuse across functions. Parameters: Name Type Description Default chunk_idx Index Index of the chunk in the protobuf required program quokka . Program Backref to the program required accepted_addresses List [ AddressT ] A list of address for blocks heads. Used only for fake chunks. None Attributes: Name Type Description program quokka . Program Program reference proto_index Index Index inside the protobuf start AddressT Start address fake bool Is the chunk fake? index_to_address Dict [ int , int ] Mapping from index to block starting address chunk_type FunctionType Chunk type chunk Proto information Source code in quokka/function.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 class Chunk ( MutableMapping , Iterable ): \"\"\"Chunk object A chunk is an IDA specific item that is used for code reuse across functions. Arguments: chunk_idx: Index of the chunk in the protobuf program: Backref to the program accepted_addresses: A list of address for blocks heads. Used only for fake chunks. Attributes: program: Program reference proto_index: Index inside the protobuf start: Start address fake: Is the chunk fake? index_to_address: Mapping from index to block starting address chunk_type: Chunk type chunk: Proto information \"\"\" def __init__ ( self , chunk_idx : Index , program : quokka . Program , accepted_addresses : List [ AddressT ] = None , ): \"\"\"Constructor\"\"\" self . program : quokka . Program = program self . proto_index : Index = chunk_idx chunk = self . program . proto . function_chunks [ chunk_idx ] self . start : AddressT = self . program . addresser . absolute ( chunk . offset_start ) self . fake : bool = chunk . is_fake self . _raw_dict : Dict [ AddressT , Index ] = {} self . _graph : Optional [ \"networkx.DiGraph\" ] = None self . index_to_address : Dict [ int , int ] = {} self . chunk = chunk self . chunk_type : FunctionType = FunctionType . NORMAL for block_index , block in enumerate ( self . chunk . blocks ): block_address : int = self . start + block . offset_start if ( accepted_addresses is not None and block_address not in accepted_addresses ): continue self . index_to_address [ block_index ] = block_address self . _raw_dict [ block_address ] = block_index if self . index_to_address : # We only update the start when we have a fake chunk (because it may have # been split out) if chunk . is_fake : self . start = min ( self . index_to_address . values ()) assert self . start == min ( self . index_to_address . values () ), \"Wrong start of Chunk\" def __len__ ( self ) -> int : \"\"\"Number of blocks in the chunk\"\"\" return len ( self . _raw_dict ) def __iter__ ( self ) -> Iterator : \"\"\"Iterator over the blocks\"\"\" return self . _raw_dict . __iter__ () def __setitem__ ( self , k : AddressT , v : Index ) -> None : \"\"\"Set block\"\"\" self . _raw_dict . __setitem__ ( k , v ) def __delitem__ ( self , k : int ) -> None : \"\"\"Remove a block\"\"\" self . _raw_dict . __delitem__ ( k ) def __getitem__ ( self , address : AddressT ) -> quokka . Block : \"\"\"Lazy loader for blocks\"\"\" index : Index = self . _raw_dict . __getitem__ ( address ) return quokka . block . Block ( index , address , self ) def __str__ ( self ) -> str : \"\"\"Chunk representation\"\"\" return f \"<Chunk at 0x { self . start : x } with { len ( self ) } block(s)>\" @property def block_ranges ( self ) -> List [ Tuple [ AddressT , AddressT ]]: \"\"\"Returns the sorted list of block ranges. A block range is a tuple (block.start, block.end). \"\"\" block_ranges = [] for block in self . values (): block_ranges . append (( block . start , block . end )) block_ranges = sorted ( block_ranges ) return block_ranges @cached_property def graph ( self ) -> \"networkx.DiGraph\" : \"\"\"Return the CFG of the chunk as DiGraph object\"\"\" graph = networkx . DiGraph () graph . add_nodes_from ( n for n in self . _raw_dict ) for edge in self . program . proto . function_chunks [ self . proto_index ] . edges : if ( edge . source . block_id not in self . index_to_address or edge . destination . block_id not in self . index_to_address ): continue graph . add_edge ( self . index_to_address [ edge . source . block_id ], self . index_to_address [ edge . destination . block_id ], condition = EdgeType . from_proto ( edge . edge_type ), ) return graph @cached_property def strings ( self ) -> List [ str ]: \"\"\"Return the strings used in the chunk\"\"\" strings = set () for block in self . values (): strings . update ( block . strings ) return list ( strings ) @cached_property def constants ( self ) -> List [ int ]: \"\"\"Return the constants used in the chunk\"\"\" constants = [] for block in self . values (): constants . extend ( block . constants ) return constants @property def data_references ( self ) -> List [ quokka . Data ]: \"\"\"Returns the data reference in the chunk\"\"\" data_references : List [ quokka . Data ] = [] for instruction in self . values (): data_references . extend ( instruction . data_references ) return data_references @cached_property def end ( self ) -> AddressT : \"\"\"Compute the end address of a chunk\"\"\" try : max_block = max ( self . keys ()) return self [ max_block ] . end except ValueError : return self . start + 1 @cached_property def size ( self ) -> int : \"\"\"Return the size of a chunk\"\"\" return self . end - self . start @property def calls ( self ) -> List [ quokka . Chunk ]: \"\"\"Return the list of calls made by this chunk. Note: The list is not deduplicated so a target may occur multiple time. \"\"\" calls = [] for inst_instance in self . program . references . resolve_calls ( self , towards = False ): if isinstance ( inst_instance , tuple ): calls . append ( inst_instance [ 0 ]) else : calls . append ( inst_instance ) return calls @property def callers ( self ) -> List [ Chunk ]: \"\"\"Return the list of callers of this chunk.\"\"\" callers = [] for inst_instance in self . program . references . resolve_calls ( self , towards = True ): if isinstance ( inst_instance , tuple ): callers . append ( inst_instance [ 0 ]) else : callers . append ( inst_instance ) return callers @cached_property def out_degree ( self ) -> int : \"\"\"Compute the chunk out degree Get the out degree of a chunk (e.g. the number of distinct chunks called by this one). Returns: Number of distinct out edges \"\"\" return len ( set ( self . calls )) @cached_property def in_degree ( self ) -> int : \"\"\"Compute the chunk in degree Get the in-degree of a chunk. This is the number of distinct incoming edges. returns: Chunk in-degree \"\"\" return len ( set ( self . callers )) @property def instructions ( self ) -> Generator : \"\"\"Iterator over instructions in the chunk\"\"\" return ( inst for block in self . values () for inst in block . instructions ) def in_chunk ( self , address : AddressT ) -> bool : \"\"\"Check if an address belongs to the chunk.\"\"\" if len ( self . block_ranges ) == 0 : return False if address < min ( self . block_ranges )[ 0 ] or address > max ( self . block_ranges )[ 1 ]: return False for start , end in self . block_ranges : if start <= address < end : return True return False def get_instruction ( self , address : AddressT ) -> quokka . Instruction : \"\"\"Get the instruction at `address`\"\"\" if not self . in_chunk ( address ): raise IndexError ( f \"Unable to find the instruction at 0x { address : x } \" ) for block in self . values (): if block . start <= address < block . end : return block [ address ] raise IndexError ( f \"Unable to find the instruction at 0x { address : x } \" ) def get_block ( self , address : AddressT ) -> quokka . Block : \"\"\"Get the block at `address`\"\"\" return self . __getitem__ ( address ) def __hash__ ( self ) -> int : \"\"\"Override hash method to return an unique index\"\"\" return self . start @cached_property def name ( self ) -> str : \"\"\"Chunk name. The chunk name is the one of its parent if it exists or is empty otherwise. Returns: Chunk name \"\"\" try : return self . program . get_first_function_by_chunk ( self ) . name except quokka . exc . FunctionMissingError : return \"\" __delitem__ ( k ) Remove a block Source code in quokka/function.py 201 202 203 def __delitem__ ( self , k : int ) -> None : \"\"\"Remove a block\"\"\" self . _raw_dict . __delitem__ ( k ) __getitem__ ( address ) Lazy loader for blocks Source code in quokka/function.py 205 206 207 208 def __getitem__ ( self , address : AddressT ) -> quokka . Block : \"\"\"Lazy loader for blocks\"\"\" index : Index = self . _raw_dict . __getitem__ ( address ) return quokka . block . Block ( index , address , self ) __hash__ () Override hash method to return an unique index Source code in quokka/function.py 375 376 377 def __hash__ ( self ) -> int : \"\"\"Override hash method to return an unique index\"\"\" return self . start __init__ ( chunk_idx , program , accepted_addresses = None ) Constructor Source code in quokka/function.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def __init__ ( self , chunk_idx : Index , program : quokka . Program , accepted_addresses : List [ AddressT ] = None , ): \"\"\"Constructor\"\"\" self . program : quokka . Program = program self . proto_index : Index = chunk_idx chunk = self . program . proto . function_chunks [ chunk_idx ] self . start : AddressT = self . program . addresser . absolute ( chunk . offset_start ) self . fake : bool = chunk . is_fake self . _raw_dict : Dict [ AddressT , Index ] = {} self . _graph : Optional [ \"networkx.DiGraph\" ] = None self . index_to_address : Dict [ int , int ] = {} self . chunk = chunk self . chunk_type : FunctionType = FunctionType . NORMAL for block_index , block in enumerate ( self . chunk . blocks ): block_address : int = self . start + block . offset_start if ( accepted_addresses is not None and block_address not in accepted_addresses ): continue self . index_to_address [ block_index ] = block_address self . _raw_dict [ block_address ] = block_index if self . index_to_address : # We only update the start when we have a fake chunk (because it may have # been split out) if chunk . is_fake : self . start = min ( self . index_to_address . values ()) assert self . start == min ( self . index_to_address . values () ), \"Wrong start of Chunk\" __iter__ () Iterator over the blocks Source code in quokka/function.py 193 194 195 def __iter__ ( self ) -> Iterator : \"\"\"Iterator over the blocks\"\"\" return self . _raw_dict . __iter__ () __len__ () Number of blocks in the chunk Source code in quokka/function.py 189 190 191 def __len__ ( self ) -> int : \"\"\"Number of blocks in the chunk\"\"\" return len ( self . _raw_dict ) __setitem__ ( k , v ) Set block Source code in quokka/function.py 197 198 199 def __setitem__ ( self , k : AddressT , v : Index ) -> None : \"\"\"Set block\"\"\" self . _raw_dict . __setitem__ ( k , v ) __str__ () Chunk representation Source code in quokka/function.py 210 211 212 def __str__ ( self ) -> str : \"\"\"Chunk representation\"\"\" return f \"<Chunk at 0x { self . start : x } with { len ( self ) } block(s)>\" block_ranges () property Returns the sorted list of block ranges. A block range is a tuple (block.start, block.end). Source code in quokka/function.py 214 215 216 217 218 219 220 221 222 223 224 225 @property def block_ranges ( self ) -> List [ Tuple [ AddressT , AddressT ]]: \"\"\"Returns the sorted list of block ranges. A block range is a tuple (block.start, block.end). \"\"\" block_ranges = [] for block in self . values (): block_ranges . append (( block . start , block . end )) block_ranges = sorted ( block_ranges ) return block_ranges callers () property Return the list of callers of this chunk. Source code in quokka/function.py 305 306 307 308 309 310 311 312 313 314 315 316 @property def callers ( self ) -> List [ Chunk ]: \"\"\"Return the list of callers of this chunk.\"\"\" callers = [] for inst_instance in self . program . references . resolve_calls ( self , towards = True ): if isinstance ( inst_instance , tuple ): callers . append ( inst_instance [ 0 ]) else : callers . append ( inst_instance ) return callers calls () property Return the list of calls made by this chunk. Note: The list is not deduplicated so a target may occur multiple time. Source code in quokka/function.py 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 @property def calls ( self ) -> List [ quokka . Chunk ]: \"\"\"Return the list of calls made by this chunk. Note: The list is not deduplicated so a target may occur multiple time. \"\"\" calls = [] for inst_instance in self . program . references . resolve_calls ( self , towards = False ): if isinstance ( inst_instance , tuple ): calls . append ( inst_instance [ 0 ]) else : calls . append ( inst_instance ) return calls constants () cached property Return the constants used in the chunk Source code in quokka/function.py 257 258 259 260 261 262 263 264 @cached_property def constants ( self ) -> List [ int ]: \"\"\"Return the constants used in the chunk\"\"\" constants = [] for block in self . values (): constants . extend ( block . constants ) return constants data_references () property Returns the data reference in the chunk Source code in quokka/function.py 266 267 268 269 270 271 272 273 @property def data_references ( self ) -> List [ quokka . Data ]: \"\"\"Returns the data reference in the chunk\"\"\" data_references : List [ quokka . Data ] = [] for instruction in self . values (): data_references . extend ( instruction . data_references ) return data_references end () cached property Compute the end address of a chunk Source code in quokka/function.py 275 276 277 278 279 280 281 282 @cached_property def end ( self ) -> AddressT : \"\"\"Compute the end address of a chunk\"\"\" try : max_block = max ( self . keys ()) return self [ max_block ] . end except ValueError : return self . start + 1 get_block ( address ) Get the block at address Source code in quokka/function.py 371 372 373 def get_block ( self , address : AddressT ) -> quokka . Block : \"\"\"Get the block at `address`\"\"\" return self . __getitem__ ( address ) get_instruction ( address ) Get the instruction at address Source code in quokka/function.py 360 361 362 363 364 365 366 367 368 369 def get_instruction ( self , address : AddressT ) -> quokka . Instruction : \"\"\"Get the instruction at `address`\"\"\" if not self . in_chunk ( address ): raise IndexError ( f \"Unable to find the instruction at 0x { address : x } \" ) for block in self . values (): if block . start <= address < block . end : return block [ address ] raise IndexError ( f \"Unable to find the instruction at 0x { address : x } \" ) graph () cached property Return the CFG of the chunk as DiGraph object Source code in quokka/function.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 @cached_property def graph ( self ) -> \"networkx.DiGraph\" : \"\"\"Return the CFG of the chunk as DiGraph object\"\"\" graph = networkx . DiGraph () graph . add_nodes_from ( n for n in self . _raw_dict ) for edge in self . program . proto . function_chunks [ self . proto_index ] . edges : if ( edge . source . block_id not in self . index_to_address or edge . destination . block_id not in self . index_to_address ): continue graph . add_edge ( self . index_to_address [ edge . source . block_id ], self . index_to_address [ edge . destination . block_id ], condition = EdgeType . from_proto ( edge . edge_type ), ) return graph in_chunk ( address ) Check if an address belongs to the chunk. Source code in quokka/function.py 346 347 348 349 350 351 352 353 354 355 356 357 358 def in_chunk ( self , address : AddressT ) -> bool : \"\"\"Check if an address belongs to the chunk.\"\"\" if len ( self . block_ranges ) == 0 : return False if address < min ( self . block_ranges )[ 0 ] or address > max ( self . block_ranges )[ 1 ]: return False for start , end in self . block_ranges : if start <= address < end : return True return False in_degree () cached property Compute the chunk in degree Get the in-degree of a chunk. This is the number of distinct incoming edges. Returns: Type Description int Chunk in-degree Source code in quokka/function.py 330 331 332 333 334 335 336 337 338 339 @cached_property def in_degree ( self ) -> int : \"\"\"Compute the chunk in degree Get the in-degree of a chunk. This is the number of distinct incoming edges. returns: Chunk in-degree \"\"\" return len ( set ( self . callers )) instructions () property Iterator over instructions in the chunk Source code in quokka/function.py 341 342 343 344 @property def instructions ( self ) -> Generator : \"\"\"Iterator over instructions in the chunk\"\"\" return ( inst for block in self . values () for inst in block . instructions ) name () cached property Chunk name. The chunk name is the one of its parent if it exists or is empty otherwise. Returns: Type Description str Chunk name Source code in quokka/function.py 379 380 381 382 383 384 385 386 387 388 389 390 391 @cached_property def name ( self ) -> str : \"\"\"Chunk name. The chunk name is the one of its parent if it exists or is empty otherwise. Returns: Chunk name \"\"\" try : return self . program . get_first_function_by_chunk ( self ) . name except quokka . exc . FunctionMissingError : return \"\" out_degree () cached property Compute the chunk out degree Get the out degree of a chunk (e.g. the number of distinct chunks called by this one). Returns: Type Description int Number of distinct out edges Source code in quokka/function.py 318 319 320 321 322 323 324 325 326 327 328 @cached_property def out_degree ( self ) -> int : \"\"\"Compute the chunk out degree Get the out degree of a chunk (e.g. the number of distinct chunks called by this one). Returns: Number of distinct out edges \"\"\" return len ( set ( self . calls )) size () cached property Return the size of a chunk Source code in quokka/function.py 284 285 286 287 @cached_property def size ( self ) -> int : \"\"\"Return the size of a chunk\"\"\" return self . end - self . start strings () cached property Return the strings used in the chunk Source code in quokka/function.py 247 248 249 250 251 252 253 254 255 @cached_property def strings ( self ) -> List [ str ]: \"\"\"Return the strings used in the chunk\"\"\" strings = set () for block in self . values (): strings . update ( block . strings ) return list ( strings ) Function Bases: dict Function object This class represents a binary function within the Program. Parameters: Name Type Description Default func Function Protobuf data required program quokka . Program Program reference required Attributes: Name Type Description start int Start address name str Function name program quokka . Program Program reference type FunctionType Function type index_to_address Dict [ int , int ] Mapping of Chunks to Protobuf indexes func Protobuf data Source code in quokka/function.py 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 class Function ( dict ): \"\"\"Function object This class represents a binary function within the Program. Arguments: func: Protobuf data program: Program reference Attributes: start: Start address name: Function name program: Program reference type: Function type index_to_address: Mapping of Chunks to Protobuf indexes func: Protobuf data \"\"\" def __init__ ( self , func : \"quokka.pb.Quokka.Function\" , program : quokka . Program ): \"\"\"Constructor\"\"\" super ( dict , self ) . __init__ () self . start : int = program . addresser . absolute ( func . offset ) self . name : str = func . name self . program : quokka . Program = program self . type : \"FunctionType\" = FunctionType . from_proto ( func . function_type ) if self . type == FunctionType . NORMAL : segment = self . program . get_segment ( self . start ) if segment and segment . type == SegmentType . EXTERN : self . type = FunctionType . EXTERN self . index_to_address : Dict [ int , int ] = {} for chunk_index in func . function_chunks_index : chunk = self . program . get_chunk ( chunk_index ) if not isinstance ( chunk , quokka . function . Chunk ): logger . error ( \"Found a super chunk in a function which is not possible\" ) continue if chunk . chunk_type not in { FunctionType . NORMAL , self . type }: logger . error ( \"All the chunks of the function are supposed to have the same \" \"type. It is not the case here.\" ) chunk . chunk_type = self . type self [ chunk . start ] = chunk self . index_to_address [ chunk_index ] = chunk . start self . func = func self . _data_references : List [ quokka . Data ] = None def get_block ( self , address : AddressT ) -> quokka . Block : \"\"\"Get the block at `address`\"\"\" for chunk in self . values (): try : return chunk [ address ] except KeyError : pass raise KeyError ( f \"Unable to find the block at address 0x { address : x } \" ) def get_instruction ( self , address : AddressT ) -> quokka . Instruction : \"\"\"Get the instruction at `address`\"\"\" for chunk in self . values (): if chunk . in_chunk ( address ): return chunk . get_instruction ( address ) raise IndexError ( f \"Unable to find the instruction at 0x { address : x } \" ) @cached_property def strings ( self ) -> List [ str ]: \"\"\"Return the list of strings used in the function\"\"\" strings = set () for chunk in self . values (): strings . update ( chunk . strings ) return list ( strings ) @property def data_references ( self ): \"\"\"Lists data references used in the function\"\"\" data_references : List [ quokka . Data ] = [] for instruction in self . values (): data_references . extend ( instruction . data_references ) return data_references @cached_property def constants ( self ) -> List [ int ]: \"\"\"Lists constants used in the function\"\"\" constants : List [ int ] = [] for chunk in self . values (): constants . extend ( chunk . constants ) return constants @cached_property def graph ( self ) -> \"networkx.DiGraph\" : \"\"\"Compute the Control Flow Graph for the function\"\"\" graph = networkx . DiGraph () for chunk in self . values (): graph = networkx . algorithms . operators . compose ( graph , chunk . graph ) for edge in self . func . chunk_edges : source_chunk = self . program . get_chunk ( edge . source . chunk_id , edge . source . block_id ) dest_chunk = self . program . get_chunk ( edge . destination . chunk_id , edge . destination . block_id ) graph . add_edge ( source_chunk . index_to_address [ edge . source . block_id ], dest_chunk . index_to_address [ edge . destination . block_id ], condition = EdgeType . from_proto ( edge . edge_type ), ) return graph @cached_property def end ( self ) -> int : \"\"\"Get the last address of the function\"\"\" max_chunk = max ( self . keys ()) return self [ max_chunk ] . end @property def calls ( self ) -> List [ Chunk ]: \"\"\"Retrieve the function calls (the ones called by the function)\"\"\" targets = [] for chunk in self . values (): targets . extend ( chunk . calls ) return targets @property def callers ( self ) -> List [ Chunk ]: \"\"\"Retrieve the function callers (the ones calling this function)\"\"\" sources = [] for chunk in self . values (): sources . extend ( chunk . callers ) return sources @property def instructions ( self ): \"\"\"Yields the function instruction\"\"\" return itertools . chain . from_iterable ( chunk . instructions for chunk in self . values () ) def in_func ( self , address : AddressT ) -> bool : \"\"\"Check if the `address` belongs to this function.\"\"\" for chunk in self . values (): if chunk . in_chunk ( address ): return True return False @cached_property def out_degree ( self ) -> int : \"\"\"Function out degree\"\"\" return len ( set ( self . calls )) @cached_property def in_degree ( self ) -> int : \"\"\"Function in degree\"\"\" return self [ self . start ] . in_degree def __hash__ ( self ) -> int : # type: ignore \"\"\"Hash value\"\"\" return self . start def __str__ ( self ) -> str : \"\"\"Function representation\"\"\" return f \"<Function { self . name } at 0x { self . start : x } >\" def __repr__ ( self ) -> str : \"\"\"Function representation\"\"\" return self . __str__ () __hash__ () Hash value Source code in quokka/function.py 711 712 713 def __hash__ ( self ) -> int : # type: ignore \"\"\"Hash value\"\"\" return self . start __init__ ( func , program ) Constructor Source code in quokka/function.py 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 def __init__ ( self , func : \"quokka.pb.Quokka.Function\" , program : quokka . Program ): \"\"\"Constructor\"\"\" super ( dict , self ) . __init__ () self . start : int = program . addresser . absolute ( func . offset ) self . name : str = func . name self . program : quokka . Program = program self . type : \"FunctionType\" = FunctionType . from_proto ( func . function_type ) if self . type == FunctionType . NORMAL : segment = self . program . get_segment ( self . start ) if segment and segment . type == SegmentType . EXTERN : self . type = FunctionType . EXTERN self . index_to_address : Dict [ int , int ] = {} for chunk_index in func . function_chunks_index : chunk = self . program . get_chunk ( chunk_index ) if not isinstance ( chunk , quokka . function . Chunk ): logger . error ( \"Found a super chunk in a function which is not possible\" ) continue if chunk . chunk_type not in { FunctionType . NORMAL , self . type }: logger . error ( \"All the chunks of the function are supposed to have the same \" \"type. It is not the case here.\" ) chunk . chunk_type = self . type self [ chunk . start ] = chunk self . index_to_address [ chunk_index ] = chunk . start self . func = func self . _data_references : List [ quokka . Data ] = None __repr__ () Function representation Source code in quokka/function.py 719 720 721 def __repr__ ( self ) -> str : \"\"\"Function representation\"\"\" return self . __str__ () __str__ () Function representation Source code in quokka/function.py 715 716 717 def __str__ ( self ) -> str : \"\"\"Function representation\"\"\" return f \"<Function { self . name } at 0x { self . start : x } >\" callers () property Retrieve the function callers (the ones calling this function) Source code in quokka/function.py 677 678 679 680 681 682 683 684 @property def callers ( self ) -> List [ Chunk ]: \"\"\"Retrieve the function callers (the ones calling this function)\"\"\" sources = [] for chunk in self . values (): sources . extend ( chunk . callers ) return sources calls () property Retrieve the function calls (the ones called by the function) Source code in quokka/function.py 668 669 670 671 672 673 674 675 @property def calls ( self ) -> List [ Chunk ]: \"\"\"Retrieve the function calls (the ones called by the function)\"\"\" targets = [] for chunk in self . values (): targets . extend ( chunk . calls ) return targets constants () cached property Lists constants used in the function Source code in quokka/function.py 630 631 632 633 634 635 636 637 @cached_property def constants ( self ) -> List [ int ]: \"\"\"Lists constants used in the function\"\"\" constants : List [ int ] = [] for chunk in self . values (): constants . extend ( chunk . constants ) return constants data_references () property Lists data references used in the function Source code in quokka/function.py 621 622 623 624 625 626 627 628 @property def data_references ( self ): \"\"\"Lists data references used in the function\"\"\" data_references : List [ quokka . Data ] = [] for instruction in self . values (): data_references . extend ( instruction . data_references ) return data_references end () cached property Get the last address of the function Source code in quokka/function.py 662 663 664 665 666 @cached_property def end ( self ) -> int : \"\"\"Get the last address of the function\"\"\" max_chunk = max ( self . keys ()) return self [ max_chunk ] . end get_block ( address ) Get the block at address Source code in quokka/function.py 594 595 596 597 598 599 600 601 602 def get_block ( self , address : AddressT ) -> quokka . Block : \"\"\"Get the block at `address`\"\"\" for chunk in self . values (): try : return chunk [ address ] except KeyError : pass raise KeyError ( f \"Unable to find the block at address 0x { address : x } \" ) get_instruction ( address ) Get the instruction at address Source code in quokka/function.py 604 605 606 607 608 609 610 def get_instruction ( self , address : AddressT ) -> quokka . Instruction : \"\"\"Get the instruction at `address`\"\"\" for chunk in self . values (): if chunk . in_chunk ( address ): return chunk . get_instruction ( address ) raise IndexError ( f \"Unable to find the instruction at 0x { address : x } \" ) graph () cached property Compute the Control Flow Graph for the function Source code in quokka/function.py 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 @cached_property def graph ( self ) -> \"networkx.DiGraph\" : \"\"\"Compute the Control Flow Graph for the function\"\"\" graph = networkx . DiGraph () for chunk in self . values (): graph = networkx . algorithms . operators . compose ( graph , chunk . graph ) for edge in self . func . chunk_edges : source_chunk = self . program . get_chunk ( edge . source . chunk_id , edge . source . block_id ) dest_chunk = self . program . get_chunk ( edge . destination . chunk_id , edge . destination . block_id ) graph . add_edge ( source_chunk . index_to_address [ edge . source . block_id ], dest_chunk . index_to_address [ edge . destination . block_id ], condition = EdgeType . from_proto ( edge . edge_type ), ) return graph in_degree () cached property Function in degree Source code in quokka/function.py 706 707 708 709 @cached_property def in_degree ( self ) -> int : \"\"\"Function in degree\"\"\" return self [ self . start ] . in_degree in_func ( address ) Check if the address belongs to this function. Source code in quokka/function.py 693 694 695 696 697 698 699 def in_func ( self , address : AddressT ) -> bool : \"\"\"Check if the `address` belongs to this function.\"\"\" for chunk in self . values (): if chunk . in_chunk ( address ): return True return False instructions () property Yields the function instruction Source code in quokka/function.py 686 687 688 689 690 691 @property def instructions ( self ): \"\"\"Yields the function instruction\"\"\" return itertools . chain . from_iterable ( chunk . instructions for chunk in self . values () ) out_degree () cached property Function out degree Source code in quokka/function.py 701 702 703 704 @cached_property def out_degree ( self ) -> int : \"\"\"Function out degree\"\"\" return len ( set ( self . calls )) strings () cached property Return the list of strings used in the function Source code in quokka/function.py 612 613 614 615 616 617 618 619 @cached_property def strings ( self ) -> List [ str ]: \"\"\"Return the list of strings used in the function\"\"\" strings = set () for chunk in self . values (): strings . update ( chunk . strings ) return list ( strings ) SuperChunk Bases: MutableMapping SuperChunk: fake functions A SuperChunk is an abstract construction that has no other meaning that serve as a candidate (or fake) function. Indeed, super chunks are created when a chunk (or a fake chunk) have multiple non-connected components. A superchunk keeps a mapping of chunk index to chunk instance and implements most of a function interface. Parameters: Name Type Description Default initial_chunk Chunk The chunk to split required components Generator The various non-connected components required Attributes: Name Type Description proto_idx Index Initial chunk proto index addresses All addresses belonging to the chunk with the instruction index chunks Dict [ Index , Chunk ] Mapping of chunks within the SuperChunk starts Dict [ AddressT , Chunk ] Mapping of chunk starts to chunks Source code in quokka/function.py 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 class SuperChunk ( MutableMapping ): \"\"\"SuperChunk: fake functions A SuperChunk is an abstract construction that has no other meaning that serve as a candidate (or fake) function. Indeed, super chunks are created when a chunk (or a fake chunk) have multiple non-connected components. A superchunk keeps a mapping of chunk index to chunk instance and implements most of a function interface. Arguments: initial_chunk: The chunk to split components: The various non-connected components Attributes: proto_idx: Initial chunk proto index addresses: All addresses belonging to the chunk with the instruction index chunks: Mapping of chunks within the SuperChunk starts: Mapping of chunk starts to chunks \"\"\" def __init__ ( self , initial_chunk : Chunk , components : Generator ): \"\"\"Init method Arguments: initial_chunk: Original chunk to split components: A generator of sets for each component of the graph \"\"\" self . proto_idx : Index = initial_chunk . proto_index self . addresses : Dict [ AddressT , int ] = {} self . chunks : Dict [ Index , Chunk ] = {} self . starts : Dict [ AddressT , Chunk ] = {} for index , component in enumerate ( components ): self . addresses . update ({ block_addr : index for block_addr in component }) chunk = Chunk ( initial_chunk . proto_index , initial_chunk . program , component ) self . chunks [ index ] = chunk self . starts [ min ( component )] = chunk # We need to keep this mapping sorted to improve efficiency self . addresses = { k : self . addresses [ k ] for k in sorted ( self . addresses )} def __setitem__ ( self , k : Index , v : Chunk ) -> None : \"\"\"Set a chunk\"\"\" self . chunks . __setitem__ ( k , v ) def __delitem__ ( self , v : Index ) -> None : \"\"\"Delete a chunk\"\"\" self . chunks . __delitem__ ( v ) def __getitem__ ( self , k : Index ) -> Chunk : \"\"\"Get a chunk\"\"\" return self . chunks . __getitem__ ( k ) def __len__ ( self ) -> int : \"\"\"Number of chunk\"\"\" return self . chunks . __len__ () def __iter__ ( self ) -> Iterator [ Index ]: \"\"\"Iterator over chunk\"\"\" return self . chunks . __iter__ () def __str__ ( self ) -> str : \"\"\"SuperChunk representation\"\"\" return f \"<SuperChunk with { len ( self . starts ) } chunks(s)>\" def get_chunk ( self , address : AddressT ) -> Chunk : \"\"\"Return a chunk by an address. To resolve an address and retrieve the appropriate chunk, we enumerate the chunks and look within the blocks. Arguments: address: Address to query Raises: IndexError: When no chunk is found \"\"\" if address in self . addresses : return self . chunks [ self . addresses [ address ]] if address < min ( self . addresses ): raise IndexError ( \"Address is before the chunk\" ) # TODO(dm) CHECK OR FIXME chunk_index = self . addresses [ min ( self . addresses )] for blocks_head , chunk_index in self . addresses . items (): if blocks_head > address : break candidate_chunk = self . chunks [ chunk_index ] if candidate_chunk . in_chunk ( address ): return candidate_chunk raise IndexError ( \"Address does not belong in this SuperChunk\" ) def get_chunk_by_index ( self , chunk_index : Index , block_index : Index ) -> Chunk : \"\"\"Return a chunk by its index This must be reimplemented because the chunk_index is unique for the proto but there are multiple chunks existing with the same index because of a SuperChunk. Arguments: chunk_index: Chunk index block_index: Block index Raises: ChunkMissingError: if the chunk is not found \"\"\" if chunk_index != self . proto_idx : raise quokka . exc . ChunkMissingError ( \"Wrong chunk index\" ) for chunk in self . chunks . values (): if chunk . index_to_address . get ( block_index , None ) is not None : return chunk raise quokka . exc . ChunkMissingError ( \"Unable to find the correct chunk for this block\" ) def in_chunk ( self , address : AddressT ) -> bool : \"\"\"Check if address belongs to this SuperChunk\"\"\" if address < min ( self . starts ): return False for chunk in self . chunks . values (): if chunk . in_chunk ( address ): return True return False def get_instruction ( self , address : AddressT ) -> quokka . Instruction : \"\"\"Get the instruction at `address`\"\"\" for chunk in self . chunks . values (): if chunk . in_chunk ( address ): return chunk . get_instruction ( address ) raise IndexError ( f \"Unable to find the instruction at 0x { address : x } \" ) __delitem__ ( v ) Delete a chunk Source code in quokka/function.py 443 444 445 def __delitem__ ( self , v : Index ) -> None : \"\"\"Delete a chunk\"\"\" self . chunks . __delitem__ ( v ) __getitem__ ( k ) Get a chunk Source code in quokka/function.py 447 448 449 def __getitem__ ( self , k : Index ) -> Chunk : \"\"\"Get a chunk\"\"\" return self . chunks . __getitem__ ( k ) __init__ ( initial_chunk , components ) Init method Parameters: Name Type Description Default initial_chunk Chunk Original chunk to split required components Generator A generator of sets for each component of the graph required Source code in quokka/function.py 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 def __init__ ( self , initial_chunk : Chunk , components : Generator ): \"\"\"Init method Arguments: initial_chunk: Original chunk to split components: A generator of sets for each component of the graph \"\"\" self . proto_idx : Index = initial_chunk . proto_index self . addresses : Dict [ AddressT , int ] = {} self . chunks : Dict [ Index , Chunk ] = {} self . starts : Dict [ AddressT , Chunk ] = {} for index , component in enumerate ( components ): self . addresses . update ({ block_addr : index for block_addr in component }) chunk = Chunk ( initial_chunk . proto_index , initial_chunk . program , component ) self . chunks [ index ] = chunk self . starts [ min ( component )] = chunk # We need to keep this mapping sorted to improve efficiency self . addresses = { k : self . addresses [ k ] for k in sorted ( self . addresses )} __iter__ () Iterator over chunk Source code in quokka/function.py 455 456 457 def __iter__ ( self ) -> Iterator [ Index ]: \"\"\"Iterator over chunk\"\"\" return self . chunks . __iter__ () __len__ () Number of chunk Source code in quokka/function.py 451 452 453 def __len__ ( self ) -> int : \"\"\"Number of chunk\"\"\" return self . chunks . __len__ () __setitem__ ( k , v ) Set a chunk Source code in quokka/function.py 439 440 441 def __setitem__ ( self , k : Index , v : Chunk ) -> None : \"\"\"Set a chunk\"\"\" self . chunks . __setitem__ ( k , v ) __str__ () SuperChunk representation Source code in quokka/function.py 459 460 461 def __str__ ( self ) -> str : \"\"\"SuperChunk representation\"\"\" return f \"<SuperChunk with { len ( self . starts ) } chunks(s)>\" get_chunk ( address ) Return a chunk by an address. To resolve an address and retrieve the appropriate chunk, we enumerate the chunks and look within the blocks. Parameters: Name Type Description Default address AddressT Address to query required Raises: Type Description IndexError When no chunk is found Source code in quokka/function.py 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 def get_chunk ( self , address : AddressT ) -> Chunk : \"\"\"Return a chunk by an address. To resolve an address and retrieve the appropriate chunk, we enumerate the chunks and look within the blocks. Arguments: address: Address to query Raises: IndexError: When no chunk is found \"\"\" if address in self . addresses : return self . chunks [ self . addresses [ address ]] if address < min ( self . addresses ): raise IndexError ( \"Address is before the chunk\" ) # TODO(dm) CHECK OR FIXME chunk_index = self . addresses [ min ( self . addresses )] for blocks_head , chunk_index in self . addresses . items (): if blocks_head > address : break candidate_chunk = self . chunks [ chunk_index ] if candidate_chunk . in_chunk ( address ): return candidate_chunk raise IndexError ( \"Address does not belong in this SuperChunk\" ) get_chunk_by_index ( chunk_index , block_index ) Return a chunk by its index This must be reimplemented because the chunk_index is unique for the proto but there are multiple chunks existing with the same index because of a SuperChunk. Parameters: Name Type Description Default chunk_index Index Chunk index required block_index Index Block index required Raises: Type Description ChunkMissingError if the chunk is not found Source code in quokka/function.py 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 def get_chunk_by_index ( self , chunk_index : Index , block_index : Index ) -> Chunk : \"\"\"Return a chunk by its index This must be reimplemented because the chunk_index is unique for the proto but there are multiple chunks existing with the same index because of a SuperChunk. Arguments: chunk_index: Chunk index block_index: Block index Raises: ChunkMissingError: if the chunk is not found \"\"\" if chunk_index != self . proto_idx : raise quokka . exc . ChunkMissingError ( \"Wrong chunk index\" ) for chunk in self . chunks . values (): if chunk . index_to_address . get ( block_index , None ) is not None : return chunk raise quokka . exc . ChunkMissingError ( \"Unable to find the correct chunk for this block\" ) get_instruction ( address ) Get the instruction at address Source code in quokka/function.py 530 531 532 533 534 535 536 def get_instruction ( self , address : AddressT ) -> quokka . Instruction : \"\"\"Get the instruction at `address`\"\"\" for chunk in self . chunks . values (): if chunk . in_chunk ( address ): return chunk . get_instruction ( address ) raise IndexError ( f \"Unable to find the instruction at 0x { address : x } \" ) in_chunk ( address ) Check if address belongs to this SuperChunk Source code in quokka/function.py 519 520 521 522 523 524 525 526 527 528 def in_chunk ( self , address : AddressT ) -> bool : \"\"\"Check if address belongs to this SuperChunk\"\"\" if address < min ( self . starts ): return False for chunk in self . chunks . values (): if chunk . in_chunk ( address ): return True return False dereference_thunk ( item , caller = False ) Dereference a thunk This method is used to resolve a thunk calls / callers. As thunk function only have 1 relation : FUNC (call x) -> THUNK X -> X , it disrupts the call graph and heuristics based on graph degrees. Parameters: Name Type Description Default item Union [ Function , Chunk ] Either a function or a chunk required caller bool True if we want to find the callers (e.g. the functions that call item) False if we want to find the callee (e.g. function that are called by item) False Raises: Type Description ThunkMissingError When no thunk has been found FunctionMissingError When no function has been found Source code in quokka/function.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def dereference_thunk ( item : Union [ Function , Chunk ], caller : bool = False ) -> Function : \"\"\"Dereference a thunk This method is used to resolve a thunk calls / callers. As thunk function only have 1 relation : FUNC (call x) -> THUNK X -> X , it disrupts the call graph and heuristics based on graph degrees. Arguments: item: Either a function or a chunk caller: True if we want to find the callers (e.g. the functions that call item) False if we want to find the callee (e.g. function that are called by item) Raises: ThunkMissingError: When no thunk has been found FunctionMissingError: When no function has been found \"\"\" if isinstance ( item , quokka . function . Chunk ): function = item . program . get_first_function_by_chunk ( item ) else : function = item # Do not try to (de)reference if we do not meet the prerequisites if caller is False and function . type != FunctionType . THUNK : # Only dereference THUNK function return function if caller is True and function . in_degree != 1 : # Only try to reference function with in_degree == 1 return function target = \"calls\" if caller is False else \"callers\" reference = getattr ( function , target ) try : candidate = function . program . get_first_function_by_chunk ( reference [ 0 ]) except ( IndexError , quokka . exc . FunctionMissingError ) as exc : if caller is True and reference [ 0 ] . in_degree == 0 : raise quokka . exc . ThunkMissingError ( \"Error while finding thunk\" ) from exc # This will appear when the referenced target is a chunk coming from a # fake chunk for instance # logger.debug(\"Unable to find the (de)reference of the thunk function\") raise quokka . exc . FunctionMissingError ( \"Missing func referenced by thunk\" ) from exc if candidate . type == FunctionType . THUNK and caller is not True : # Recursive call for multi layered THUNK return dereference_thunk ( candidate , caller ) if caller and candidate . type != FunctionType . THUNK : return function return candidate get_degrees ( item ) Compute the {in, out} degrees of an item (Function/Chunk) Source code in quokka/function.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def get_degrees ( item : Union [ Chunk , Function ]) -> Tuple [ int , int ]: \"\"\"Compute the {in, out} degrees of an item (Function/Chunk)\"\"\" in_degree = item . in_degree try : in_func = quokka . function . dereference_thunk ( item , True ) in_degree = in_func . in_degree except quokka . exc . ThunkMissingError : in_degree = 0 except quokka . exc . FunctionMissingError : pass try : out_func : Union [ Function , Chunk ] = quokka . function . dereference_thunk ( item , False ) except quokka . exc . FunctionMissingError : out_func = item return in_degree , out_func . out_degree","title":"function"},{"location":"reference/python/function/#quokka.function.Chunk","text":"Bases: MutableMapping , Iterable Chunk object A chunk is an IDA specific item that is used for code reuse across functions. Parameters: Name Type Description Default chunk_idx Index Index of the chunk in the protobuf required program quokka . Program Backref to the program required accepted_addresses List [ AddressT ] A list of address for blocks heads. Used only for fake chunks. None Attributes: Name Type Description program quokka . Program Program reference proto_index Index Index inside the protobuf start AddressT Start address fake bool Is the chunk fake? index_to_address Dict [ int , int ] Mapping from index to block starting address chunk_type FunctionType Chunk type chunk Proto information Source code in quokka/function.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 class Chunk ( MutableMapping , Iterable ): \"\"\"Chunk object A chunk is an IDA specific item that is used for code reuse across functions. Arguments: chunk_idx: Index of the chunk in the protobuf program: Backref to the program accepted_addresses: A list of address for blocks heads. Used only for fake chunks. Attributes: program: Program reference proto_index: Index inside the protobuf start: Start address fake: Is the chunk fake? index_to_address: Mapping from index to block starting address chunk_type: Chunk type chunk: Proto information \"\"\" def __init__ ( self , chunk_idx : Index , program : quokka . Program , accepted_addresses : List [ AddressT ] = None , ): \"\"\"Constructor\"\"\" self . program : quokka . Program = program self . proto_index : Index = chunk_idx chunk = self . program . proto . function_chunks [ chunk_idx ] self . start : AddressT = self . program . addresser . absolute ( chunk . offset_start ) self . fake : bool = chunk . is_fake self . _raw_dict : Dict [ AddressT , Index ] = {} self . _graph : Optional [ \"networkx.DiGraph\" ] = None self . index_to_address : Dict [ int , int ] = {} self . chunk = chunk self . chunk_type : FunctionType = FunctionType . NORMAL for block_index , block in enumerate ( self . chunk . blocks ): block_address : int = self . start + block . offset_start if ( accepted_addresses is not None and block_address not in accepted_addresses ): continue self . index_to_address [ block_index ] = block_address self . _raw_dict [ block_address ] = block_index if self . index_to_address : # We only update the start when we have a fake chunk (because it may have # been split out) if chunk . is_fake : self . start = min ( self . index_to_address . values ()) assert self . start == min ( self . index_to_address . values () ), \"Wrong start of Chunk\" def __len__ ( self ) -> int : \"\"\"Number of blocks in the chunk\"\"\" return len ( self . _raw_dict ) def __iter__ ( self ) -> Iterator : \"\"\"Iterator over the blocks\"\"\" return self . _raw_dict . __iter__ () def __setitem__ ( self , k : AddressT , v : Index ) -> None : \"\"\"Set block\"\"\" self . _raw_dict . __setitem__ ( k , v ) def __delitem__ ( self , k : int ) -> None : \"\"\"Remove a block\"\"\" self . _raw_dict . __delitem__ ( k ) def __getitem__ ( self , address : AddressT ) -> quokka . Block : \"\"\"Lazy loader for blocks\"\"\" index : Index = self . _raw_dict . __getitem__ ( address ) return quokka . block . Block ( index , address , self ) def __str__ ( self ) -> str : \"\"\"Chunk representation\"\"\" return f \"<Chunk at 0x { self . start : x } with { len ( self ) } block(s)>\" @property def block_ranges ( self ) -> List [ Tuple [ AddressT , AddressT ]]: \"\"\"Returns the sorted list of block ranges. A block range is a tuple (block.start, block.end). \"\"\" block_ranges = [] for block in self . values (): block_ranges . append (( block . start , block . end )) block_ranges = sorted ( block_ranges ) return block_ranges @cached_property def graph ( self ) -> \"networkx.DiGraph\" : \"\"\"Return the CFG of the chunk as DiGraph object\"\"\" graph = networkx . DiGraph () graph . add_nodes_from ( n for n in self . _raw_dict ) for edge in self . program . proto . function_chunks [ self . proto_index ] . edges : if ( edge . source . block_id not in self . index_to_address or edge . destination . block_id not in self . index_to_address ): continue graph . add_edge ( self . index_to_address [ edge . source . block_id ], self . index_to_address [ edge . destination . block_id ], condition = EdgeType . from_proto ( edge . edge_type ), ) return graph @cached_property def strings ( self ) -> List [ str ]: \"\"\"Return the strings used in the chunk\"\"\" strings = set () for block in self . values (): strings . update ( block . strings ) return list ( strings ) @cached_property def constants ( self ) -> List [ int ]: \"\"\"Return the constants used in the chunk\"\"\" constants = [] for block in self . values (): constants . extend ( block . constants ) return constants @property def data_references ( self ) -> List [ quokka . Data ]: \"\"\"Returns the data reference in the chunk\"\"\" data_references : List [ quokka . Data ] = [] for instruction in self . values (): data_references . extend ( instruction . data_references ) return data_references @cached_property def end ( self ) -> AddressT : \"\"\"Compute the end address of a chunk\"\"\" try : max_block = max ( self . keys ()) return self [ max_block ] . end except ValueError : return self . start + 1 @cached_property def size ( self ) -> int : \"\"\"Return the size of a chunk\"\"\" return self . end - self . start @property def calls ( self ) -> List [ quokka . Chunk ]: \"\"\"Return the list of calls made by this chunk. Note: The list is not deduplicated so a target may occur multiple time. \"\"\" calls = [] for inst_instance in self . program . references . resolve_calls ( self , towards = False ): if isinstance ( inst_instance , tuple ): calls . append ( inst_instance [ 0 ]) else : calls . append ( inst_instance ) return calls @property def callers ( self ) -> List [ Chunk ]: \"\"\"Return the list of callers of this chunk.\"\"\" callers = [] for inst_instance in self . program . references . resolve_calls ( self , towards = True ): if isinstance ( inst_instance , tuple ): callers . append ( inst_instance [ 0 ]) else : callers . append ( inst_instance ) return callers @cached_property def out_degree ( self ) -> int : \"\"\"Compute the chunk out degree Get the out degree of a chunk (e.g. the number of distinct chunks called by this one). Returns: Number of distinct out edges \"\"\" return len ( set ( self . calls )) @cached_property def in_degree ( self ) -> int : \"\"\"Compute the chunk in degree Get the in-degree of a chunk. This is the number of distinct incoming edges. returns: Chunk in-degree \"\"\" return len ( set ( self . callers )) @property def instructions ( self ) -> Generator : \"\"\"Iterator over instructions in the chunk\"\"\" return ( inst for block in self . values () for inst in block . instructions ) def in_chunk ( self , address : AddressT ) -> bool : \"\"\"Check if an address belongs to the chunk.\"\"\" if len ( self . block_ranges ) == 0 : return False if address < min ( self . block_ranges )[ 0 ] or address > max ( self . block_ranges )[ 1 ]: return False for start , end in self . block_ranges : if start <= address < end : return True return False def get_instruction ( self , address : AddressT ) -> quokka . Instruction : \"\"\"Get the instruction at `address`\"\"\" if not self . in_chunk ( address ): raise IndexError ( f \"Unable to find the instruction at 0x { address : x } \" ) for block in self . values (): if block . start <= address < block . end : return block [ address ] raise IndexError ( f \"Unable to find the instruction at 0x { address : x } \" ) def get_block ( self , address : AddressT ) -> quokka . Block : \"\"\"Get the block at `address`\"\"\" return self . __getitem__ ( address ) def __hash__ ( self ) -> int : \"\"\"Override hash method to return an unique index\"\"\" return self . start @cached_property def name ( self ) -> str : \"\"\"Chunk name. The chunk name is the one of its parent if it exists or is empty otherwise. Returns: Chunk name \"\"\" try : return self . program . get_first_function_by_chunk ( self ) . name except quokka . exc . FunctionMissingError : return \"\"","title":"Chunk"},{"location":"reference/python/function/#quokka.function.Chunk.__delitem__","text":"Remove a block Source code in quokka/function.py 201 202 203 def __delitem__ ( self , k : int ) -> None : \"\"\"Remove a block\"\"\" self . _raw_dict . __delitem__ ( k )","title":"__delitem__()"},{"location":"reference/python/function/#quokka.function.Chunk.__getitem__","text":"Lazy loader for blocks Source code in quokka/function.py 205 206 207 208 def __getitem__ ( self , address : AddressT ) -> quokka . Block : \"\"\"Lazy loader for blocks\"\"\" index : Index = self . _raw_dict . __getitem__ ( address ) return quokka . block . Block ( index , address , self )","title":"__getitem__()"},{"location":"reference/python/function/#quokka.function.Chunk.__hash__","text":"Override hash method to return an unique index Source code in quokka/function.py 375 376 377 def __hash__ ( self ) -> int : \"\"\"Override hash method to return an unique index\"\"\" return self . start","title":"__hash__()"},{"location":"reference/python/function/#quokka.function.Chunk.__init__","text":"Constructor Source code in quokka/function.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def __init__ ( self , chunk_idx : Index , program : quokka . Program , accepted_addresses : List [ AddressT ] = None , ): \"\"\"Constructor\"\"\" self . program : quokka . Program = program self . proto_index : Index = chunk_idx chunk = self . program . proto . function_chunks [ chunk_idx ] self . start : AddressT = self . program . addresser . absolute ( chunk . offset_start ) self . fake : bool = chunk . is_fake self . _raw_dict : Dict [ AddressT , Index ] = {} self . _graph : Optional [ \"networkx.DiGraph\" ] = None self . index_to_address : Dict [ int , int ] = {} self . chunk = chunk self . chunk_type : FunctionType = FunctionType . NORMAL for block_index , block in enumerate ( self . chunk . blocks ): block_address : int = self . start + block . offset_start if ( accepted_addresses is not None and block_address not in accepted_addresses ): continue self . index_to_address [ block_index ] = block_address self . _raw_dict [ block_address ] = block_index if self . index_to_address : # We only update the start when we have a fake chunk (because it may have # been split out) if chunk . is_fake : self . start = min ( self . index_to_address . values ()) assert self . start == min ( self . index_to_address . values () ), \"Wrong start of Chunk\"","title":"__init__()"},{"location":"reference/python/function/#quokka.function.Chunk.__iter__","text":"Iterator over the blocks Source code in quokka/function.py 193 194 195 def __iter__ ( self ) -> Iterator : \"\"\"Iterator over the blocks\"\"\" return self . _raw_dict . __iter__ ()","title":"__iter__()"},{"location":"reference/python/function/#quokka.function.Chunk.__len__","text":"Number of blocks in the chunk Source code in quokka/function.py 189 190 191 def __len__ ( self ) -> int : \"\"\"Number of blocks in the chunk\"\"\" return len ( self . _raw_dict )","title":"__len__()"},{"location":"reference/python/function/#quokka.function.Chunk.__setitem__","text":"Set block Source code in quokka/function.py 197 198 199 def __setitem__ ( self , k : AddressT , v : Index ) -> None : \"\"\"Set block\"\"\" self . _raw_dict . __setitem__ ( k , v )","title":"__setitem__()"},{"location":"reference/python/function/#quokka.function.Chunk.__str__","text":"Chunk representation Source code in quokka/function.py 210 211 212 def __str__ ( self ) -> str : \"\"\"Chunk representation\"\"\" return f \"<Chunk at 0x { self . start : x } with { len ( self ) } block(s)>\"","title":"__str__()"},{"location":"reference/python/function/#quokka.function.Chunk.block_ranges","text":"Returns the sorted list of block ranges. A block range is a tuple (block.start, block.end). Source code in quokka/function.py 214 215 216 217 218 219 220 221 222 223 224 225 @property def block_ranges ( self ) -> List [ Tuple [ AddressT , AddressT ]]: \"\"\"Returns the sorted list of block ranges. A block range is a tuple (block.start, block.end). \"\"\" block_ranges = [] for block in self . values (): block_ranges . append (( block . start , block . end )) block_ranges = sorted ( block_ranges ) return block_ranges","title":"block_ranges()"},{"location":"reference/python/function/#quokka.function.Chunk.callers","text":"Return the list of callers of this chunk. Source code in quokka/function.py 305 306 307 308 309 310 311 312 313 314 315 316 @property def callers ( self ) -> List [ Chunk ]: \"\"\"Return the list of callers of this chunk.\"\"\" callers = [] for inst_instance in self . program . references . resolve_calls ( self , towards = True ): if isinstance ( inst_instance , tuple ): callers . append ( inst_instance [ 0 ]) else : callers . append ( inst_instance ) return callers","title":"callers()"},{"location":"reference/python/function/#quokka.function.Chunk.calls","text":"Return the list of calls made by this chunk. Note: The list is not deduplicated so a target may occur multiple time. Source code in quokka/function.py 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 @property def calls ( self ) -> List [ quokka . Chunk ]: \"\"\"Return the list of calls made by this chunk. Note: The list is not deduplicated so a target may occur multiple time. \"\"\" calls = [] for inst_instance in self . program . references . resolve_calls ( self , towards = False ): if isinstance ( inst_instance , tuple ): calls . append ( inst_instance [ 0 ]) else : calls . append ( inst_instance ) return calls","title":"calls()"},{"location":"reference/python/function/#quokka.function.Chunk.constants","text":"Return the constants used in the chunk Source code in quokka/function.py 257 258 259 260 261 262 263 264 @cached_property def constants ( self ) -> List [ int ]: \"\"\"Return the constants used in the chunk\"\"\" constants = [] for block in self . values (): constants . extend ( block . constants ) return constants","title":"constants()"},{"location":"reference/python/function/#quokka.function.Chunk.data_references","text":"Returns the data reference in the chunk Source code in quokka/function.py 266 267 268 269 270 271 272 273 @property def data_references ( self ) -> List [ quokka . Data ]: \"\"\"Returns the data reference in the chunk\"\"\" data_references : List [ quokka . Data ] = [] for instruction in self . values (): data_references . extend ( instruction . data_references ) return data_references","title":"data_references()"},{"location":"reference/python/function/#quokka.function.Chunk.end","text":"Compute the end address of a chunk Source code in quokka/function.py 275 276 277 278 279 280 281 282 @cached_property def end ( self ) -> AddressT : \"\"\"Compute the end address of a chunk\"\"\" try : max_block = max ( self . keys ()) return self [ max_block ] . end except ValueError : return self . start + 1","title":"end()"},{"location":"reference/python/function/#quokka.function.Chunk.get_block","text":"Get the block at address Source code in quokka/function.py 371 372 373 def get_block ( self , address : AddressT ) -> quokka . Block : \"\"\"Get the block at `address`\"\"\" return self . __getitem__ ( address )","title":"get_block()"},{"location":"reference/python/function/#quokka.function.Chunk.get_instruction","text":"Get the instruction at address Source code in quokka/function.py 360 361 362 363 364 365 366 367 368 369 def get_instruction ( self , address : AddressT ) -> quokka . Instruction : \"\"\"Get the instruction at `address`\"\"\" if not self . in_chunk ( address ): raise IndexError ( f \"Unable to find the instruction at 0x { address : x } \" ) for block in self . values (): if block . start <= address < block . end : return block [ address ] raise IndexError ( f \"Unable to find the instruction at 0x { address : x } \" )","title":"get_instruction()"},{"location":"reference/python/function/#quokka.function.Chunk.graph","text":"Return the CFG of the chunk as DiGraph object Source code in quokka/function.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 @cached_property def graph ( self ) -> \"networkx.DiGraph\" : \"\"\"Return the CFG of the chunk as DiGraph object\"\"\" graph = networkx . DiGraph () graph . add_nodes_from ( n for n in self . _raw_dict ) for edge in self . program . proto . function_chunks [ self . proto_index ] . edges : if ( edge . source . block_id not in self . index_to_address or edge . destination . block_id not in self . index_to_address ): continue graph . add_edge ( self . index_to_address [ edge . source . block_id ], self . index_to_address [ edge . destination . block_id ], condition = EdgeType . from_proto ( edge . edge_type ), ) return graph","title":"graph()"},{"location":"reference/python/function/#quokka.function.Chunk.in_chunk","text":"Check if an address belongs to the chunk. Source code in quokka/function.py 346 347 348 349 350 351 352 353 354 355 356 357 358 def in_chunk ( self , address : AddressT ) -> bool : \"\"\"Check if an address belongs to the chunk.\"\"\" if len ( self . block_ranges ) == 0 : return False if address < min ( self . block_ranges )[ 0 ] or address > max ( self . block_ranges )[ 1 ]: return False for start , end in self . block_ranges : if start <= address < end : return True return False","title":"in_chunk()"},{"location":"reference/python/function/#quokka.function.Chunk.in_degree","text":"Compute the chunk in degree Get the in-degree of a chunk. This is the number of distinct incoming edges. Returns: Type Description int Chunk in-degree Source code in quokka/function.py 330 331 332 333 334 335 336 337 338 339 @cached_property def in_degree ( self ) -> int : \"\"\"Compute the chunk in degree Get the in-degree of a chunk. This is the number of distinct incoming edges. returns: Chunk in-degree \"\"\" return len ( set ( self . callers ))","title":"in_degree()"},{"location":"reference/python/function/#quokka.function.Chunk.instructions","text":"Iterator over instructions in the chunk Source code in quokka/function.py 341 342 343 344 @property def instructions ( self ) -> Generator : \"\"\"Iterator over instructions in the chunk\"\"\" return ( inst for block in self . values () for inst in block . instructions )","title":"instructions()"},{"location":"reference/python/function/#quokka.function.Chunk.name","text":"Chunk name. The chunk name is the one of its parent if it exists or is empty otherwise. Returns: Type Description str Chunk name Source code in quokka/function.py 379 380 381 382 383 384 385 386 387 388 389 390 391 @cached_property def name ( self ) -> str : \"\"\"Chunk name. The chunk name is the one of its parent if it exists or is empty otherwise. Returns: Chunk name \"\"\" try : return self . program . get_first_function_by_chunk ( self ) . name except quokka . exc . FunctionMissingError : return \"\"","title":"name()"},{"location":"reference/python/function/#quokka.function.Chunk.out_degree","text":"Compute the chunk out degree Get the out degree of a chunk (e.g. the number of distinct chunks called by this one). Returns: Type Description int Number of distinct out edges Source code in quokka/function.py 318 319 320 321 322 323 324 325 326 327 328 @cached_property def out_degree ( self ) -> int : \"\"\"Compute the chunk out degree Get the out degree of a chunk (e.g. the number of distinct chunks called by this one). Returns: Number of distinct out edges \"\"\" return len ( set ( self . calls ))","title":"out_degree()"},{"location":"reference/python/function/#quokka.function.Chunk.size","text":"Return the size of a chunk Source code in quokka/function.py 284 285 286 287 @cached_property def size ( self ) -> int : \"\"\"Return the size of a chunk\"\"\" return self . end - self . start","title":"size()"},{"location":"reference/python/function/#quokka.function.Chunk.strings","text":"Return the strings used in the chunk Source code in quokka/function.py 247 248 249 250 251 252 253 254 255 @cached_property def strings ( self ) -> List [ str ]: \"\"\"Return the strings used in the chunk\"\"\" strings = set () for block in self . values (): strings . update ( block . strings ) return list ( strings )","title":"strings()"},{"location":"reference/python/function/#quokka.function.Function","text":"Bases: dict Function object This class represents a binary function within the Program. Parameters: Name Type Description Default func Function Protobuf data required program quokka . Program Program reference required Attributes: Name Type Description start int Start address name str Function name program quokka . Program Program reference type FunctionType Function type index_to_address Dict [ int , int ] Mapping of Chunks to Protobuf indexes func Protobuf data Source code in quokka/function.py 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 class Function ( dict ): \"\"\"Function object This class represents a binary function within the Program. Arguments: func: Protobuf data program: Program reference Attributes: start: Start address name: Function name program: Program reference type: Function type index_to_address: Mapping of Chunks to Protobuf indexes func: Protobuf data \"\"\" def __init__ ( self , func : \"quokka.pb.Quokka.Function\" , program : quokka . Program ): \"\"\"Constructor\"\"\" super ( dict , self ) . __init__ () self . start : int = program . addresser . absolute ( func . offset ) self . name : str = func . name self . program : quokka . Program = program self . type : \"FunctionType\" = FunctionType . from_proto ( func . function_type ) if self . type == FunctionType . NORMAL : segment = self . program . get_segment ( self . start ) if segment and segment . type == SegmentType . EXTERN : self . type = FunctionType . EXTERN self . index_to_address : Dict [ int , int ] = {} for chunk_index in func . function_chunks_index : chunk = self . program . get_chunk ( chunk_index ) if not isinstance ( chunk , quokka . function . Chunk ): logger . error ( \"Found a super chunk in a function which is not possible\" ) continue if chunk . chunk_type not in { FunctionType . NORMAL , self . type }: logger . error ( \"All the chunks of the function are supposed to have the same \" \"type. It is not the case here.\" ) chunk . chunk_type = self . type self [ chunk . start ] = chunk self . index_to_address [ chunk_index ] = chunk . start self . func = func self . _data_references : List [ quokka . Data ] = None def get_block ( self , address : AddressT ) -> quokka . Block : \"\"\"Get the block at `address`\"\"\" for chunk in self . values (): try : return chunk [ address ] except KeyError : pass raise KeyError ( f \"Unable to find the block at address 0x { address : x } \" ) def get_instruction ( self , address : AddressT ) -> quokka . Instruction : \"\"\"Get the instruction at `address`\"\"\" for chunk in self . values (): if chunk . in_chunk ( address ): return chunk . get_instruction ( address ) raise IndexError ( f \"Unable to find the instruction at 0x { address : x } \" ) @cached_property def strings ( self ) -> List [ str ]: \"\"\"Return the list of strings used in the function\"\"\" strings = set () for chunk in self . values (): strings . update ( chunk . strings ) return list ( strings ) @property def data_references ( self ): \"\"\"Lists data references used in the function\"\"\" data_references : List [ quokka . Data ] = [] for instruction in self . values (): data_references . extend ( instruction . data_references ) return data_references @cached_property def constants ( self ) -> List [ int ]: \"\"\"Lists constants used in the function\"\"\" constants : List [ int ] = [] for chunk in self . values (): constants . extend ( chunk . constants ) return constants @cached_property def graph ( self ) -> \"networkx.DiGraph\" : \"\"\"Compute the Control Flow Graph for the function\"\"\" graph = networkx . DiGraph () for chunk in self . values (): graph = networkx . algorithms . operators . compose ( graph , chunk . graph ) for edge in self . func . chunk_edges : source_chunk = self . program . get_chunk ( edge . source . chunk_id , edge . source . block_id ) dest_chunk = self . program . get_chunk ( edge . destination . chunk_id , edge . destination . block_id ) graph . add_edge ( source_chunk . index_to_address [ edge . source . block_id ], dest_chunk . index_to_address [ edge . destination . block_id ], condition = EdgeType . from_proto ( edge . edge_type ), ) return graph @cached_property def end ( self ) -> int : \"\"\"Get the last address of the function\"\"\" max_chunk = max ( self . keys ()) return self [ max_chunk ] . end @property def calls ( self ) -> List [ Chunk ]: \"\"\"Retrieve the function calls (the ones called by the function)\"\"\" targets = [] for chunk in self . values (): targets . extend ( chunk . calls ) return targets @property def callers ( self ) -> List [ Chunk ]: \"\"\"Retrieve the function callers (the ones calling this function)\"\"\" sources = [] for chunk in self . values (): sources . extend ( chunk . callers ) return sources @property def instructions ( self ): \"\"\"Yields the function instruction\"\"\" return itertools . chain . from_iterable ( chunk . instructions for chunk in self . values () ) def in_func ( self , address : AddressT ) -> bool : \"\"\"Check if the `address` belongs to this function.\"\"\" for chunk in self . values (): if chunk . in_chunk ( address ): return True return False @cached_property def out_degree ( self ) -> int : \"\"\"Function out degree\"\"\" return len ( set ( self . calls )) @cached_property def in_degree ( self ) -> int : \"\"\"Function in degree\"\"\" return self [ self . start ] . in_degree def __hash__ ( self ) -> int : # type: ignore \"\"\"Hash value\"\"\" return self . start def __str__ ( self ) -> str : \"\"\"Function representation\"\"\" return f \"<Function { self . name } at 0x { self . start : x } >\" def __repr__ ( self ) -> str : \"\"\"Function representation\"\"\" return self . __str__ ()","title":"Function"},{"location":"reference/python/function/#quokka.function.Function.__hash__","text":"Hash value Source code in quokka/function.py 711 712 713 def __hash__ ( self ) -> int : # type: ignore \"\"\"Hash value\"\"\" return self . start","title":"__hash__()"},{"location":"reference/python/function/#quokka.function.Function.__init__","text":"Constructor Source code in quokka/function.py 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 def __init__ ( self , func : \"quokka.pb.Quokka.Function\" , program : quokka . Program ): \"\"\"Constructor\"\"\" super ( dict , self ) . __init__ () self . start : int = program . addresser . absolute ( func . offset ) self . name : str = func . name self . program : quokka . Program = program self . type : \"FunctionType\" = FunctionType . from_proto ( func . function_type ) if self . type == FunctionType . NORMAL : segment = self . program . get_segment ( self . start ) if segment and segment . type == SegmentType . EXTERN : self . type = FunctionType . EXTERN self . index_to_address : Dict [ int , int ] = {} for chunk_index in func . function_chunks_index : chunk = self . program . get_chunk ( chunk_index ) if not isinstance ( chunk , quokka . function . Chunk ): logger . error ( \"Found a super chunk in a function which is not possible\" ) continue if chunk . chunk_type not in { FunctionType . NORMAL , self . type }: logger . error ( \"All the chunks of the function are supposed to have the same \" \"type. It is not the case here.\" ) chunk . chunk_type = self . type self [ chunk . start ] = chunk self . index_to_address [ chunk_index ] = chunk . start self . func = func self . _data_references : List [ quokka . Data ] = None","title":"__init__()"},{"location":"reference/python/function/#quokka.function.Function.__repr__","text":"Function representation Source code in quokka/function.py 719 720 721 def __repr__ ( self ) -> str : \"\"\"Function representation\"\"\" return self . __str__ ()","title":"__repr__()"},{"location":"reference/python/function/#quokka.function.Function.__str__","text":"Function representation Source code in quokka/function.py 715 716 717 def __str__ ( self ) -> str : \"\"\"Function representation\"\"\" return f \"<Function { self . name } at 0x { self . start : x } >\"","title":"__str__()"},{"location":"reference/python/function/#quokka.function.Function.callers","text":"Retrieve the function callers (the ones calling this function) Source code in quokka/function.py 677 678 679 680 681 682 683 684 @property def callers ( self ) -> List [ Chunk ]: \"\"\"Retrieve the function callers (the ones calling this function)\"\"\" sources = [] for chunk in self . values (): sources . extend ( chunk . callers ) return sources","title":"callers()"},{"location":"reference/python/function/#quokka.function.Function.calls","text":"Retrieve the function calls (the ones called by the function) Source code in quokka/function.py 668 669 670 671 672 673 674 675 @property def calls ( self ) -> List [ Chunk ]: \"\"\"Retrieve the function calls (the ones called by the function)\"\"\" targets = [] for chunk in self . values (): targets . extend ( chunk . calls ) return targets","title":"calls()"},{"location":"reference/python/function/#quokka.function.Function.constants","text":"Lists constants used in the function Source code in quokka/function.py 630 631 632 633 634 635 636 637 @cached_property def constants ( self ) -> List [ int ]: \"\"\"Lists constants used in the function\"\"\" constants : List [ int ] = [] for chunk in self . values (): constants . extend ( chunk . constants ) return constants","title":"constants()"},{"location":"reference/python/function/#quokka.function.Function.data_references","text":"Lists data references used in the function Source code in quokka/function.py 621 622 623 624 625 626 627 628 @property def data_references ( self ): \"\"\"Lists data references used in the function\"\"\" data_references : List [ quokka . Data ] = [] for instruction in self . values (): data_references . extend ( instruction . data_references ) return data_references","title":"data_references()"},{"location":"reference/python/function/#quokka.function.Function.end","text":"Get the last address of the function Source code in quokka/function.py 662 663 664 665 666 @cached_property def end ( self ) -> int : \"\"\"Get the last address of the function\"\"\" max_chunk = max ( self . keys ()) return self [ max_chunk ] . end","title":"end()"},{"location":"reference/python/function/#quokka.function.Function.get_block","text":"Get the block at address Source code in quokka/function.py 594 595 596 597 598 599 600 601 602 def get_block ( self , address : AddressT ) -> quokka . Block : \"\"\"Get the block at `address`\"\"\" for chunk in self . values (): try : return chunk [ address ] except KeyError : pass raise KeyError ( f \"Unable to find the block at address 0x { address : x } \" )","title":"get_block()"},{"location":"reference/python/function/#quokka.function.Function.get_instruction","text":"Get the instruction at address Source code in quokka/function.py 604 605 606 607 608 609 610 def get_instruction ( self , address : AddressT ) -> quokka . Instruction : \"\"\"Get the instruction at `address`\"\"\" for chunk in self . values (): if chunk . in_chunk ( address ): return chunk . get_instruction ( address ) raise IndexError ( f \"Unable to find the instruction at 0x { address : x } \" )","title":"get_instruction()"},{"location":"reference/python/function/#quokka.function.Function.graph","text":"Compute the Control Flow Graph for the function Source code in quokka/function.py 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 @cached_property def graph ( self ) -> \"networkx.DiGraph\" : \"\"\"Compute the Control Flow Graph for the function\"\"\" graph = networkx . DiGraph () for chunk in self . values (): graph = networkx . algorithms . operators . compose ( graph , chunk . graph ) for edge in self . func . chunk_edges : source_chunk = self . program . get_chunk ( edge . source . chunk_id , edge . source . block_id ) dest_chunk = self . program . get_chunk ( edge . destination . chunk_id , edge . destination . block_id ) graph . add_edge ( source_chunk . index_to_address [ edge . source . block_id ], dest_chunk . index_to_address [ edge . destination . block_id ], condition = EdgeType . from_proto ( edge . edge_type ), ) return graph","title":"graph()"},{"location":"reference/python/function/#quokka.function.Function.in_degree","text":"Function in degree Source code in quokka/function.py 706 707 708 709 @cached_property def in_degree ( self ) -> int : \"\"\"Function in degree\"\"\" return self [ self . start ] . in_degree","title":"in_degree()"},{"location":"reference/python/function/#quokka.function.Function.in_func","text":"Check if the address belongs to this function. Source code in quokka/function.py 693 694 695 696 697 698 699 def in_func ( self , address : AddressT ) -> bool : \"\"\"Check if the `address` belongs to this function.\"\"\" for chunk in self . values (): if chunk . in_chunk ( address ): return True return False","title":"in_func()"},{"location":"reference/python/function/#quokka.function.Function.instructions","text":"Yields the function instruction Source code in quokka/function.py 686 687 688 689 690 691 @property def instructions ( self ): \"\"\"Yields the function instruction\"\"\" return itertools . chain . from_iterable ( chunk . instructions for chunk in self . values () )","title":"instructions()"},{"location":"reference/python/function/#quokka.function.Function.out_degree","text":"Function out degree Source code in quokka/function.py 701 702 703 704 @cached_property def out_degree ( self ) -> int : \"\"\"Function out degree\"\"\" return len ( set ( self . calls ))","title":"out_degree()"},{"location":"reference/python/function/#quokka.function.Function.strings","text":"Return the list of strings used in the function Source code in quokka/function.py 612 613 614 615 616 617 618 619 @cached_property def strings ( self ) -> List [ str ]: \"\"\"Return the list of strings used in the function\"\"\" strings = set () for chunk in self . values (): strings . update ( chunk . strings ) return list ( strings )","title":"strings()"},{"location":"reference/python/function/#quokka.function.SuperChunk","text":"Bases: MutableMapping SuperChunk: fake functions A SuperChunk is an abstract construction that has no other meaning that serve as a candidate (or fake) function. Indeed, super chunks are created when a chunk (or a fake chunk) have multiple non-connected components. A superchunk keeps a mapping of chunk index to chunk instance and implements most of a function interface. Parameters: Name Type Description Default initial_chunk Chunk The chunk to split required components Generator The various non-connected components required Attributes: Name Type Description proto_idx Index Initial chunk proto index addresses All addresses belonging to the chunk with the instruction index chunks Dict [ Index , Chunk ] Mapping of chunks within the SuperChunk starts Dict [ AddressT , Chunk ] Mapping of chunk starts to chunks Source code in quokka/function.py 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 class SuperChunk ( MutableMapping ): \"\"\"SuperChunk: fake functions A SuperChunk is an abstract construction that has no other meaning that serve as a candidate (or fake) function. Indeed, super chunks are created when a chunk (or a fake chunk) have multiple non-connected components. A superchunk keeps a mapping of chunk index to chunk instance and implements most of a function interface. Arguments: initial_chunk: The chunk to split components: The various non-connected components Attributes: proto_idx: Initial chunk proto index addresses: All addresses belonging to the chunk with the instruction index chunks: Mapping of chunks within the SuperChunk starts: Mapping of chunk starts to chunks \"\"\" def __init__ ( self , initial_chunk : Chunk , components : Generator ): \"\"\"Init method Arguments: initial_chunk: Original chunk to split components: A generator of sets for each component of the graph \"\"\" self . proto_idx : Index = initial_chunk . proto_index self . addresses : Dict [ AddressT , int ] = {} self . chunks : Dict [ Index , Chunk ] = {} self . starts : Dict [ AddressT , Chunk ] = {} for index , component in enumerate ( components ): self . addresses . update ({ block_addr : index for block_addr in component }) chunk = Chunk ( initial_chunk . proto_index , initial_chunk . program , component ) self . chunks [ index ] = chunk self . starts [ min ( component )] = chunk # We need to keep this mapping sorted to improve efficiency self . addresses = { k : self . addresses [ k ] for k in sorted ( self . addresses )} def __setitem__ ( self , k : Index , v : Chunk ) -> None : \"\"\"Set a chunk\"\"\" self . chunks . __setitem__ ( k , v ) def __delitem__ ( self , v : Index ) -> None : \"\"\"Delete a chunk\"\"\" self . chunks . __delitem__ ( v ) def __getitem__ ( self , k : Index ) -> Chunk : \"\"\"Get a chunk\"\"\" return self . chunks . __getitem__ ( k ) def __len__ ( self ) -> int : \"\"\"Number of chunk\"\"\" return self . chunks . __len__ () def __iter__ ( self ) -> Iterator [ Index ]: \"\"\"Iterator over chunk\"\"\" return self . chunks . __iter__ () def __str__ ( self ) -> str : \"\"\"SuperChunk representation\"\"\" return f \"<SuperChunk with { len ( self . starts ) } chunks(s)>\" def get_chunk ( self , address : AddressT ) -> Chunk : \"\"\"Return a chunk by an address. To resolve an address and retrieve the appropriate chunk, we enumerate the chunks and look within the blocks. Arguments: address: Address to query Raises: IndexError: When no chunk is found \"\"\" if address in self . addresses : return self . chunks [ self . addresses [ address ]] if address < min ( self . addresses ): raise IndexError ( \"Address is before the chunk\" ) # TODO(dm) CHECK OR FIXME chunk_index = self . addresses [ min ( self . addresses )] for blocks_head , chunk_index in self . addresses . items (): if blocks_head > address : break candidate_chunk = self . chunks [ chunk_index ] if candidate_chunk . in_chunk ( address ): return candidate_chunk raise IndexError ( \"Address does not belong in this SuperChunk\" ) def get_chunk_by_index ( self , chunk_index : Index , block_index : Index ) -> Chunk : \"\"\"Return a chunk by its index This must be reimplemented because the chunk_index is unique for the proto but there are multiple chunks existing with the same index because of a SuperChunk. Arguments: chunk_index: Chunk index block_index: Block index Raises: ChunkMissingError: if the chunk is not found \"\"\" if chunk_index != self . proto_idx : raise quokka . exc . ChunkMissingError ( \"Wrong chunk index\" ) for chunk in self . chunks . values (): if chunk . index_to_address . get ( block_index , None ) is not None : return chunk raise quokka . exc . ChunkMissingError ( \"Unable to find the correct chunk for this block\" ) def in_chunk ( self , address : AddressT ) -> bool : \"\"\"Check if address belongs to this SuperChunk\"\"\" if address < min ( self . starts ): return False for chunk in self . chunks . values (): if chunk . in_chunk ( address ): return True return False def get_instruction ( self , address : AddressT ) -> quokka . Instruction : \"\"\"Get the instruction at `address`\"\"\" for chunk in self . chunks . values (): if chunk . in_chunk ( address ): return chunk . get_instruction ( address ) raise IndexError ( f \"Unable to find the instruction at 0x { address : x } \" )","title":"SuperChunk"},{"location":"reference/python/function/#quokka.function.SuperChunk.__delitem__","text":"Delete a chunk Source code in quokka/function.py 443 444 445 def __delitem__ ( self , v : Index ) -> None : \"\"\"Delete a chunk\"\"\" self . chunks . __delitem__ ( v )","title":"__delitem__()"},{"location":"reference/python/function/#quokka.function.SuperChunk.__getitem__","text":"Get a chunk Source code in quokka/function.py 447 448 449 def __getitem__ ( self , k : Index ) -> Chunk : \"\"\"Get a chunk\"\"\" return self . chunks . __getitem__ ( k )","title":"__getitem__()"},{"location":"reference/python/function/#quokka.function.SuperChunk.__init__","text":"Init method Parameters: Name Type Description Default initial_chunk Chunk Original chunk to split required components Generator A generator of sets for each component of the graph required Source code in quokka/function.py 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 def __init__ ( self , initial_chunk : Chunk , components : Generator ): \"\"\"Init method Arguments: initial_chunk: Original chunk to split components: A generator of sets for each component of the graph \"\"\" self . proto_idx : Index = initial_chunk . proto_index self . addresses : Dict [ AddressT , int ] = {} self . chunks : Dict [ Index , Chunk ] = {} self . starts : Dict [ AddressT , Chunk ] = {} for index , component in enumerate ( components ): self . addresses . update ({ block_addr : index for block_addr in component }) chunk = Chunk ( initial_chunk . proto_index , initial_chunk . program , component ) self . chunks [ index ] = chunk self . starts [ min ( component )] = chunk # We need to keep this mapping sorted to improve efficiency self . addresses = { k : self . addresses [ k ] for k in sorted ( self . addresses )}","title":"__init__()"},{"location":"reference/python/function/#quokka.function.SuperChunk.__iter__","text":"Iterator over chunk Source code in quokka/function.py 455 456 457 def __iter__ ( self ) -> Iterator [ Index ]: \"\"\"Iterator over chunk\"\"\" return self . chunks . __iter__ ()","title":"__iter__()"},{"location":"reference/python/function/#quokka.function.SuperChunk.__len__","text":"Number of chunk Source code in quokka/function.py 451 452 453 def __len__ ( self ) -> int : \"\"\"Number of chunk\"\"\" return self . chunks . __len__ ()","title":"__len__()"},{"location":"reference/python/function/#quokka.function.SuperChunk.__setitem__","text":"Set a chunk Source code in quokka/function.py 439 440 441 def __setitem__ ( self , k : Index , v : Chunk ) -> None : \"\"\"Set a chunk\"\"\" self . chunks . __setitem__ ( k , v )","title":"__setitem__()"},{"location":"reference/python/function/#quokka.function.SuperChunk.__str__","text":"SuperChunk representation Source code in quokka/function.py 459 460 461 def __str__ ( self ) -> str : \"\"\"SuperChunk representation\"\"\" return f \"<SuperChunk with { len ( self . starts ) } chunks(s)>\"","title":"__str__()"},{"location":"reference/python/function/#quokka.function.SuperChunk.get_chunk","text":"Return a chunk by an address. To resolve an address and retrieve the appropriate chunk, we enumerate the chunks and look within the blocks. Parameters: Name Type Description Default address AddressT Address to query required Raises: Type Description IndexError When no chunk is found Source code in quokka/function.py 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 def get_chunk ( self , address : AddressT ) -> Chunk : \"\"\"Return a chunk by an address. To resolve an address and retrieve the appropriate chunk, we enumerate the chunks and look within the blocks. Arguments: address: Address to query Raises: IndexError: When no chunk is found \"\"\" if address in self . addresses : return self . chunks [ self . addresses [ address ]] if address < min ( self . addresses ): raise IndexError ( \"Address is before the chunk\" ) # TODO(dm) CHECK OR FIXME chunk_index = self . addresses [ min ( self . addresses )] for blocks_head , chunk_index in self . addresses . items (): if blocks_head > address : break candidate_chunk = self . chunks [ chunk_index ] if candidate_chunk . in_chunk ( address ): return candidate_chunk raise IndexError ( \"Address does not belong in this SuperChunk\" )","title":"get_chunk()"},{"location":"reference/python/function/#quokka.function.SuperChunk.get_chunk_by_index","text":"Return a chunk by its index This must be reimplemented because the chunk_index is unique for the proto but there are multiple chunks existing with the same index because of a SuperChunk. Parameters: Name Type Description Default chunk_index Index Chunk index required block_index Index Block index required Raises: Type Description ChunkMissingError if the chunk is not found Source code in quokka/function.py 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 def get_chunk_by_index ( self , chunk_index : Index , block_index : Index ) -> Chunk : \"\"\"Return a chunk by its index This must be reimplemented because the chunk_index is unique for the proto but there are multiple chunks existing with the same index because of a SuperChunk. Arguments: chunk_index: Chunk index block_index: Block index Raises: ChunkMissingError: if the chunk is not found \"\"\" if chunk_index != self . proto_idx : raise quokka . exc . ChunkMissingError ( \"Wrong chunk index\" ) for chunk in self . chunks . values (): if chunk . index_to_address . get ( block_index , None ) is not None : return chunk raise quokka . exc . ChunkMissingError ( \"Unable to find the correct chunk for this block\" )","title":"get_chunk_by_index()"},{"location":"reference/python/function/#quokka.function.SuperChunk.get_instruction","text":"Get the instruction at address Source code in quokka/function.py 530 531 532 533 534 535 536 def get_instruction ( self , address : AddressT ) -> quokka . Instruction : \"\"\"Get the instruction at `address`\"\"\" for chunk in self . chunks . values (): if chunk . in_chunk ( address ): return chunk . get_instruction ( address ) raise IndexError ( f \"Unable to find the instruction at 0x { address : x } \" )","title":"get_instruction()"},{"location":"reference/python/function/#quokka.function.SuperChunk.in_chunk","text":"Check if address belongs to this SuperChunk Source code in quokka/function.py 519 520 521 522 523 524 525 526 527 528 def in_chunk ( self , address : AddressT ) -> bool : \"\"\"Check if address belongs to this SuperChunk\"\"\" if address < min ( self . starts ): return False for chunk in self . chunks . values (): if chunk . in_chunk ( address ): return True return False","title":"in_chunk()"},{"location":"reference/python/function/#quokka.function.dereference_thunk","text":"Dereference a thunk This method is used to resolve a thunk calls / callers. As thunk function only have 1 relation : FUNC (call x) -> THUNK X -> X , it disrupts the call graph and heuristics based on graph degrees. Parameters: Name Type Description Default item Union [ Function , Chunk ] Either a function or a chunk required caller bool True if we want to find the callers (e.g. the functions that call item) False if we want to find the callee (e.g. function that are called by item) False Raises: Type Description ThunkMissingError When no thunk has been found FunctionMissingError When no function has been found Source code in quokka/function.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def dereference_thunk ( item : Union [ Function , Chunk ], caller : bool = False ) -> Function : \"\"\"Dereference a thunk This method is used to resolve a thunk calls / callers. As thunk function only have 1 relation : FUNC (call x) -> THUNK X -> X , it disrupts the call graph and heuristics based on graph degrees. Arguments: item: Either a function or a chunk caller: True if we want to find the callers (e.g. the functions that call item) False if we want to find the callee (e.g. function that are called by item) Raises: ThunkMissingError: When no thunk has been found FunctionMissingError: When no function has been found \"\"\" if isinstance ( item , quokka . function . Chunk ): function = item . program . get_first_function_by_chunk ( item ) else : function = item # Do not try to (de)reference if we do not meet the prerequisites if caller is False and function . type != FunctionType . THUNK : # Only dereference THUNK function return function if caller is True and function . in_degree != 1 : # Only try to reference function with in_degree == 1 return function target = \"calls\" if caller is False else \"callers\" reference = getattr ( function , target ) try : candidate = function . program . get_first_function_by_chunk ( reference [ 0 ]) except ( IndexError , quokka . exc . FunctionMissingError ) as exc : if caller is True and reference [ 0 ] . in_degree == 0 : raise quokka . exc . ThunkMissingError ( \"Error while finding thunk\" ) from exc # This will appear when the referenced target is a chunk coming from a # fake chunk for instance # logger.debug(\"Unable to find the (de)reference of the thunk function\") raise quokka . exc . FunctionMissingError ( \"Missing func referenced by thunk\" ) from exc if candidate . type == FunctionType . THUNK and caller is not True : # Recursive call for multi layered THUNK return dereference_thunk ( candidate , caller ) if caller and candidate . type != FunctionType . THUNK : return function return candidate","title":"dereference_thunk()"},{"location":"reference/python/function/#quokka.function.get_degrees","text":"Compute the {in, out} degrees of an item (Function/Chunk) Source code in quokka/function.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def get_degrees ( item : Union [ Chunk , Function ]) -> Tuple [ int , int ]: \"\"\"Compute the {in, out} degrees of an item (Function/Chunk)\"\"\" in_degree = item . in_degree try : in_func = quokka . function . dereference_thunk ( item , True ) in_degree = in_func . in_degree except quokka . exc . ThunkMissingError : in_degree = 0 except quokka . exc . FunctionMissingError : pass try : out_func : Union [ Function , Chunk ] = quokka . function . dereference_thunk ( item , False ) except quokka . exc . FunctionMissingError : out_func = item return in_degree , out_func . out_degree","title":"get_degrees()"},{"location":"reference/python/instruction/","text":"Methods to deal with instructions and operands within a binary Instruction Instruction class An instruction is the binary bread-and-butter. This class abstract some elements and offer various backends integration if needed. Parameters: Name Type Description Default proto_index Index Protobuf index of the instruction required inst_index int Instruction index in the parent block required address AddressT Instruction address required block quokka . Block Parent block reference required Attributes: Name Type Description program quokka . Program Reference to the program parent quokka . Block Parent block proto_index Index Protobuf index of the instruction inst_tuple A tuple composed of the (chunk_index, block_index, inst_index). This uniquely identify an instruction within the program. thumb is the instruction thumb? index int Instruction index in the parent block Source code in quokka/instruction.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 class Instruction : \"\"\"Instruction class An instruction is the binary bread-and-butter. This class abstract some elements and offer various backends integration if needed. Arguments: proto_index: Protobuf index of the instruction inst_index: Instruction index in the parent block address: Instruction address block: Parent block reference Attributes: program: Reference to the program parent: Parent block proto_index: Protobuf index of the instruction inst_tuple: A tuple composed of the (chunk_index, block_index, inst_index). This uniquely identify an instruction within the program. thumb: is the instruction thumb? index: Instruction index in the parent block \"\"\" def __init__ ( self , proto_index : Index , inst_index : int , address : AddressT , block : quokka . Block , ): self . program : quokka . Program = block . program self . parent : quokka . Block = block self . proto_index : Index = proto_index self . inst_tuple = ( block . parent . proto_index , block . proto_index , inst_index ) instruction = self . program . proto . instructions [ proto_index ] self . size = instruction . size self . thumb = instruction . is_thumb self . index : int = inst_index # TODO(dm) Sometimes, IDA merge two instruction in one # (e.g. 0x1ab16 of d53a), deal with that self . address : AddressT = address @cached_property def mnemonic ( self ) -> str : \"\"\"Return the mnemonic for the instruction. First, try to use capstone because it's prettier Otherwise, fallback to the IDA mnemonic which is better than nothing. Returns: A string representation of the mnemonic \"\"\" if self . cs_inst is not None : return self . cs_inst . mnemonic instruction = self . program . proto . instructions [ self . proto_index ] return self . program . proto . mnemonics [ instruction . mnemonic_index ] @cached_property def cs_inst ( self ) -> Optional [ capstone . CsInsn ]: \"\"\"Load an instruction from Capstone backend If the decoding fails, the result won't be cached, and it will be attempted again. Returns: A Capstone instruction \"\"\" return quokka . backends . capstone_decode_instruction ( self ) @cached_property def pcode_insts ( self ) -> Sequence [ pypcode . PcodeOp ]: \"\"\"Retrieve the PcodeOps associated to the instruction Returns: A sequence of PCode instructions \"\"\" return quokka . backends . pypcode_decode_instruction ( self ) @cached_property def string ( self ) -> Optional [ str ]: \"\"\"String used by the instruction (if any)\"\"\" for data in self . data_references : if isinstance ( data , quokka . data . Data ) and data . type == DataType . ASCII : return data . value return None @property def references ( self ) -> Dict [ ReferenceType , List [ ReferenceTarget ]]: \"\"\"Returns all the references towards the instruction\"\"\" ref = defaultdict ( list ) for reference in self . program . references . resolve_inst_instance ( self . inst_tuple , towards = True ): ref [ reference . type ] . append ( reference . source ) return ref @property def data_references ( self ) -> List [ ReferenceTarget ]: \"\"\"Returns all data reference to this instruction\"\"\" return self . references [ ReferenceType . DATA ] @property def struct_references ( self ) -> List [ ReferenceTarget ]: \"\"\"Returns all struct reference to this instruction\"\"\" return self . references [ ReferenceType . STRUC ] @property def enum_references ( self ) -> List [ ReferenceTarget ]: \"\"\"Returns all enum reference to this instruction\"\"\" return self . references [ ReferenceType . ENUM ] @property def call_references ( self ) -> List [ ReferenceTarget ]: \"\"\"Returns all call reference to this instruction\"\"\" return self . references [ ReferenceType . CALL ] @property def operands ( self ) -> List [ Operand ]: \"\"\"Retrieve the instruction operands and initialize them with Capstone\"\"\" operands : List [ Operand ] = [] inst = self . program . proto . instructions [ self . proto_index ] try : capstone_operands = len ( self . cs_inst . operands ) except AttributeError : capstone_operands = 0 operand_count = max ( capstone_operands , len ( inst . operand_index )) for idx in range ( operand_count ): try : operand_index = inst . operand_index [ idx ] except IndexError : # logger.debug('Less IDA operands than capstone') continue details = None try : details = self . cs_inst . operands [ idx ] except ( IndexError , quokka . exc . InstructionError ): # logger.debug('Missing an IDA operand for capstone') pass # TODO(dm): Allow partial operands with only half of the data if operand_index != - 1 : operands . append ( Operand ( self . program . proto . operands [ operand_index ], capstone_operand = details , program = self . program , ) ) return operands @cached_property def call_target ( self ) -> quokka . Chunk : \"\"\"Find the call target of an instruction if any exists\"\"\" call_target = False candidates = set () for reference in self . program . references . resolve_inst_instance ( self . inst_tuple , ReferenceType . CALL , towards = False ): # FIX: in Quokka a bug existed where the call target could be data if isinstance ( reference . destination , tuple ): candidates . add ( reference . destination [ 0 ]) # A chunk elif isinstance ( reference . destination , quokka . Chunk ): candidates . add ( reference . destination ) try : call_target = candidates . pop () except KeyError : pass if candidates : logger . warning ( f \"We found multiple candidate targets for 0x { self . address : x } \" ) return call_target @property def has_call ( self ) -> bool : \"\"\"Check if the instruction has a call target\"\"\" return self . call_target is not False @cached_property def constants ( self ) -> List [ int ]: \"\"\"Fast accessor for instructions constant not using Capstone.\"\"\" constants = [] for op_index in self . program . proto . instructions [ self . proto_index ] . operand_index : operand : quokka . pb . Quokka . Operand = self . program . proto . operands [ op_index ] if operand . type == 5 : # FIX: This bug is due to IDA mislabelling operands for some # operations like ADRP on ARM where the operand points to a # memory area (2) but the type is CONSTANT (5). # The behavior is inconsistent with LEA on Intel arch where # the operand is properly labelled (either 2 or 5). if not self . data_references : constants . append ( operand . value ) return constants def __str__ ( self ) -> str : \"\"\"String representation of the instruction First, try by capstone because it's prettier Otherwise, fallback to the mnemonic which is better than nothing. Returns: A string representation of the mnemonic \"\"\" # First, try with the operand strings (case MODE FULL) inst = self . program . proto . instructions [ self . proto_index ] if self . program . mode == ExporterMode . FULL : operands = \", \" . join ( self . program . proto . operand_table [ x ] for x in inst . operand_strings ) return f \"<Inst { self . mnemonic } { operands } >\" # Second tentative, use capstone if self . cs_inst is not None : return f \"< { self . cs_inst . mnemonic } { self . cs_inst . op_str } >\" # Finally, just use the mnemonic return f \"<Inst { self . mnemonic } >\" @cached_property def bytes ( self ) -> bytes : \"\"\"Read the program binary to find the bytes associated to the instruction. This is not cached as it is already in memory. Returns: Bytes associated to the instruction \"\"\" try : file_offset = self . program . addresser . file ( self . address ) except quokka . exc . NotInFileError : return b \"\" return self . program . executable . read_byte ( offset = file_offset , size = self . size , ) __str__ () String representation of the instruction First, try by capstone because it's prettier Otherwise, fallback to the mnemonic which is better than nothing. Returns: Type Description str A string representation of the mnemonic Source code in quokka/instruction.py 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def __str__ ( self ) -> str : \"\"\"String representation of the instruction First, try by capstone because it's prettier Otherwise, fallback to the mnemonic which is better than nothing. Returns: A string representation of the mnemonic \"\"\" # First, try with the operand strings (case MODE FULL) inst = self . program . proto . instructions [ self . proto_index ] if self . program . mode == ExporterMode . FULL : operands = \", \" . join ( self . program . proto . operand_table [ x ] for x in inst . operand_strings ) return f \"<Inst { self . mnemonic } { operands } >\" # Second tentative, use capstone if self . cs_inst is not None : return f \"< { self . cs_inst . mnemonic } { self . cs_inst . op_str } >\" # Finally, just use the mnemonic return f \"<Inst { self . mnemonic } >\" bytes () cached property Read the program binary to find the bytes associated to the instruction. This is not cached as it is already in memory. Returns: Type Description bytes Bytes associated to the instruction Source code in quokka/instruction.py 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 @cached_property def bytes ( self ) -> bytes : \"\"\"Read the program binary to find the bytes associated to the instruction. This is not cached as it is already in memory. Returns: Bytes associated to the instruction \"\"\" try : file_offset = self . program . addresser . file ( self . address ) except quokka . exc . NotInFileError : return b \"\" return self . program . executable . read_byte ( offset = file_offset , size = self . size , ) call_references () property Returns all call reference to this instruction Source code in quokka/instruction.py 228 229 230 231 @property def call_references ( self ) -> List [ ReferenceTarget ]: \"\"\"Returns all call reference to this instruction\"\"\" return self . references [ ReferenceType . CALL ] call_target () cached property Find the call target of an instruction if any exists Source code in quokka/instruction.py 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 @cached_property def call_target ( self ) -> quokka . Chunk : \"\"\"Find the call target of an instruction if any exists\"\"\" call_target = False candidates = set () for reference in self . program . references . resolve_inst_instance ( self . inst_tuple , ReferenceType . CALL , towards = False ): # FIX: in Quokka a bug existed where the call target could be data if isinstance ( reference . destination , tuple ): candidates . add ( reference . destination [ 0 ]) # A chunk elif isinstance ( reference . destination , quokka . Chunk ): candidates . add ( reference . destination ) try : call_target = candidates . pop () except KeyError : pass if candidates : logger . warning ( f \"We found multiple candidate targets for 0x { self . address : x } \" ) return call_target constants () cached property Fast accessor for instructions constant not using Capstone. Source code in quokka/instruction.py 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 @cached_property def constants ( self ) -> List [ int ]: \"\"\"Fast accessor for instructions constant not using Capstone.\"\"\" constants = [] for op_index in self . program . proto . instructions [ self . proto_index ] . operand_index : operand : quokka . pb . Quokka . Operand = self . program . proto . operands [ op_index ] if operand . type == 5 : # FIX: This bug is due to IDA mislabelling operands for some # operations like ADRP on ARM where the operand points to a # memory area (2) but the type is CONSTANT (5). # The behavior is inconsistent with LEA on Intel arch where # the operand is properly labelled (either 2 or 5). if not self . data_references : constants . append ( operand . value ) return constants cs_inst () cached property Load an instruction from Capstone backend If the decoding fails, the result won't be cached, and it will be attempted again. Returns: Type Description Optional [ capstone . CsInsn ] A Capstone instruction Source code in quokka/instruction.py 171 172 173 174 175 176 177 178 179 180 181 182 @cached_property def cs_inst ( self ) -> Optional [ capstone . CsInsn ]: \"\"\"Load an instruction from Capstone backend If the decoding fails, the result won't be cached, and it will be attempted again. Returns: A Capstone instruction \"\"\" return quokka . backends . capstone_decode_instruction ( self ) data_references () property Returns all data reference to this instruction Source code in quokka/instruction.py 213 214 215 216 @property def data_references ( self ) -> List [ ReferenceTarget ]: \"\"\"Returns all data reference to this instruction\"\"\" return self . references [ ReferenceType . DATA ] enum_references () property Returns all enum reference to this instruction Source code in quokka/instruction.py 223 224 225 226 @property def enum_references ( self ) -> List [ ReferenceTarget ]: \"\"\"Returns all enum reference to this instruction\"\"\" return self . references [ ReferenceType . ENUM ] has_call () property Check if the instruction has a call target Source code in quokka/instruction.py 300 301 302 303 @property def has_call ( self ) -> bool : \"\"\"Check if the instruction has a call target\"\"\" return self . call_target is not False mnemonic () cached property Return the mnemonic for the instruction. First, try to use capstone because it's prettier Otherwise, fallback to the IDA mnemonic which is better than nothing. Returns: Type Description str A string representation of the mnemonic Source code in quokka/instruction.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 @cached_property def mnemonic ( self ) -> str : \"\"\"Return the mnemonic for the instruction. First, try to use capstone because it's prettier Otherwise, fallback to the IDA mnemonic which is better than nothing. Returns: A string representation of the mnemonic \"\"\" if self . cs_inst is not None : return self . cs_inst . mnemonic instruction = self . program . proto . instructions [ self . proto_index ] return self . program . proto . mnemonics [ instruction . mnemonic_index ] operands () property Retrieve the instruction operands and initialize them with Capstone Source code in quokka/instruction.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 @property def operands ( self ) -> List [ Operand ]: \"\"\"Retrieve the instruction operands and initialize them with Capstone\"\"\" operands : List [ Operand ] = [] inst = self . program . proto . instructions [ self . proto_index ] try : capstone_operands = len ( self . cs_inst . operands ) except AttributeError : capstone_operands = 0 operand_count = max ( capstone_operands , len ( inst . operand_index )) for idx in range ( operand_count ): try : operand_index = inst . operand_index [ idx ] except IndexError : # logger.debug('Less IDA operands than capstone') continue details = None try : details = self . cs_inst . operands [ idx ] except ( IndexError , quokka . exc . InstructionError ): # logger.debug('Missing an IDA operand for capstone') pass # TODO(dm): Allow partial operands with only half of the data if operand_index != - 1 : operands . append ( Operand ( self . program . proto . operands [ operand_index ], capstone_operand = details , program = self . program , ) ) return operands pcode_insts () cached property Retrieve the PcodeOps associated to the instruction Returns: Type Description Sequence [ pypcode . PcodeOp ] A sequence of PCode instructions Source code in quokka/instruction.py 184 185 186 187 188 189 190 191 @cached_property def pcode_insts ( self ) -> Sequence [ pypcode . PcodeOp ]: \"\"\"Retrieve the PcodeOps associated to the instruction Returns: A sequence of PCode instructions \"\"\" return quokka . backends . pypcode_decode_instruction ( self ) references () property Returns all the references towards the instruction Source code in quokka/instruction.py 202 203 204 205 206 207 208 209 210 211 @property def references ( self ) -> Dict [ ReferenceType , List [ ReferenceTarget ]]: \"\"\"Returns all the references towards the instruction\"\"\" ref = defaultdict ( list ) for reference in self . program . references . resolve_inst_instance ( self . inst_tuple , towards = True ): ref [ reference . type ] . append ( reference . source ) return ref string () cached property String used by the instruction (if any) Source code in quokka/instruction.py 193 194 195 196 197 198 199 200 @cached_property def string ( self ) -> Optional [ str ]: \"\"\"String used by the instruction (if any)\"\"\" for data in self . data_references : if isinstance ( data , quokka . data . Data ) and data . type == DataType . ASCII : return data . value return None struct_references () property Returns all struct reference to this instruction Source code in quokka/instruction.py 218 219 220 221 @property def struct_references ( self ) -> List [ ReferenceTarget ]: \"\"\"Returns all struct reference to this instruction\"\"\" return self . references [ ReferenceType . STRUC ] Operand Operand object An operand is an \"argument\" for an instruction. This class represent them but is rather lackluster at the moment. Parameters: Name Type Description Default proto_operand Operand Protobuf data required capstone_operand Capstone data (if any) None program Union [None, quokka . Program ] Program reference None Attributes: Name Type Description program quokka . Program Program reference type int Operand type flags int Operand flags address Optional [ int ] Operand address value_type IDA value type reg_id IDA register ID (if applicable) details Capstone details Source code in quokka/instruction.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class Operand : \"\"\"Operand object An operand is an \"argument\" for an instruction. This class represent them but is rather lackluster at the moment. Arguments: proto_operand: Protobuf data capstone_operand: Capstone data (if any) program: Program reference Attributes: program: Program reference type: Operand type flags: Operand flags address: Operand address value_type: IDA value type reg_id: IDA register ID (if applicable) details: Capstone details \"\"\" # Operand rewrite to integrate capstone information as well def __init__ ( self , proto_operand : \"quokka.pb.Quokka.Operand\" , capstone_operand = None , program : Union [ None , quokka . Program ] = None , ): \"\"\"Constructor\"\"\" self . program : quokka . Program = program self . type : int = proto_operand . type self . flags : int = proto_operand . flags # TODO(dm) self . address : Optional [ int ] = ( proto_operand . address if proto_operand . address != 0 else None ) self . value_type = proto_operand . value_type self . reg_id = proto_operand . register_id self . _value = proto_operand . value self . details = capstone_operand @property def value ( self ) -> Any : \"\"\"Returns the operand value Warning: this is only implemented for constant operand (in IDA). Returns: The operand value \"\"\" if self . type == 5 : # Type: IDA constant return self . _value raise NotImplementedError def is_constant ( self ) -> bool : \"\"\"Check if the operand is a constant\"\"\" return self . type == 5 __init__ ( proto_operand , capstone_operand = None , program = None ) Constructor Source code in quokka/instruction.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def __init__ ( self , proto_operand : \"quokka.pb.Quokka.Operand\" , capstone_operand = None , program : Union [ None , quokka . Program ] = None , ): \"\"\"Constructor\"\"\" self . program : quokka . Program = program self . type : int = proto_operand . type self . flags : int = proto_operand . flags # TODO(dm) self . address : Optional [ int ] = ( proto_operand . address if proto_operand . address != 0 else None ) self . value_type = proto_operand . value_type self . reg_id = proto_operand . register_id self . _value = proto_operand . value self . details = capstone_operand is_constant () Check if the operand is a constant Source code in quokka/instruction.py 104 105 106 def is_constant ( self ) -> bool : \"\"\"Check if the operand is a constant\"\"\" return self . type == 5 value () property Returns the operand value Warning: this is only implemented for constant operand (in IDA). Returns: Type Description Any The operand value Source code in quokka/instruction.py 90 91 92 93 94 95 96 97 98 99 100 101 102 @property def value ( self ) -> Any : \"\"\"Returns the operand value Warning: this is only implemented for constant operand (in IDA). Returns: The operand value \"\"\" if self . type == 5 : # Type: IDA constant return self . _value raise NotImplementedError","title":"instruction"},{"location":"reference/python/instruction/#quokka.instruction.Instruction","text":"Instruction class An instruction is the binary bread-and-butter. This class abstract some elements and offer various backends integration if needed. Parameters: Name Type Description Default proto_index Index Protobuf index of the instruction required inst_index int Instruction index in the parent block required address AddressT Instruction address required block quokka . Block Parent block reference required Attributes: Name Type Description program quokka . Program Reference to the program parent quokka . Block Parent block proto_index Index Protobuf index of the instruction inst_tuple A tuple composed of the (chunk_index, block_index, inst_index). This uniquely identify an instruction within the program. thumb is the instruction thumb? index int Instruction index in the parent block Source code in quokka/instruction.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 class Instruction : \"\"\"Instruction class An instruction is the binary bread-and-butter. This class abstract some elements and offer various backends integration if needed. Arguments: proto_index: Protobuf index of the instruction inst_index: Instruction index in the parent block address: Instruction address block: Parent block reference Attributes: program: Reference to the program parent: Parent block proto_index: Protobuf index of the instruction inst_tuple: A tuple composed of the (chunk_index, block_index, inst_index). This uniquely identify an instruction within the program. thumb: is the instruction thumb? index: Instruction index in the parent block \"\"\" def __init__ ( self , proto_index : Index , inst_index : int , address : AddressT , block : quokka . Block , ): self . program : quokka . Program = block . program self . parent : quokka . Block = block self . proto_index : Index = proto_index self . inst_tuple = ( block . parent . proto_index , block . proto_index , inst_index ) instruction = self . program . proto . instructions [ proto_index ] self . size = instruction . size self . thumb = instruction . is_thumb self . index : int = inst_index # TODO(dm) Sometimes, IDA merge two instruction in one # (e.g. 0x1ab16 of d53a), deal with that self . address : AddressT = address @cached_property def mnemonic ( self ) -> str : \"\"\"Return the mnemonic for the instruction. First, try to use capstone because it's prettier Otherwise, fallback to the IDA mnemonic which is better than nothing. Returns: A string representation of the mnemonic \"\"\" if self . cs_inst is not None : return self . cs_inst . mnemonic instruction = self . program . proto . instructions [ self . proto_index ] return self . program . proto . mnemonics [ instruction . mnemonic_index ] @cached_property def cs_inst ( self ) -> Optional [ capstone . CsInsn ]: \"\"\"Load an instruction from Capstone backend If the decoding fails, the result won't be cached, and it will be attempted again. Returns: A Capstone instruction \"\"\" return quokka . backends . capstone_decode_instruction ( self ) @cached_property def pcode_insts ( self ) -> Sequence [ pypcode . PcodeOp ]: \"\"\"Retrieve the PcodeOps associated to the instruction Returns: A sequence of PCode instructions \"\"\" return quokka . backends . pypcode_decode_instruction ( self ) @cached_property def string ( self ) -> Optional [ str ]: \"\"\"String used by the instruction (if any)\"\"\" for data in self . data_references : if isinstance ( data , quokka . data . Data ) and data . type == DataType . ASCII : return data . value return None @property def references ( self ) -> Dict [ ReferenceType , List [ ReferenceTarget ]]: \"\"\"Returns all the references towards the instruction\"\"\" ref = defaultdict ( list ) for reference in self . program . references . resolve_inst_instance ( self . inst_tuple , towards = True ): ref [ reference . type ] . append ( reference . source ) return ref @property def data_references ( self ) -> List [ ReferenceTarget ]: \"\"\"Returns all data reference to this instruction\"\"\" return self . references [ ReferenceType . DATA ] @property def struct_references ( self ) -> List [ ReferenceTarget ]: \"\"\"Returns all struct reference to this instruction\"\"\" return self . references [ ReferenceType . STRUC ] @property def enum_references ( self ) -> List [ ReferenceTarget ]: \"\"\"Returns all enum reference to this instruction\"\"\" return self . references [ ReferenceType . ENUM ] @property def call_references ( self ) -> List [ ReferenceTarget ]: \"\"\"Returns all call reference to this instruction\"\"\" return self . references [ ReferenceType . CALL ] @property def operands ( self ) -> List [ Operand ]: \"\"\"Retrieve the instruction operands and initialize them with Capstone\"\"\" operands : List [ Operand ] = [] inst = self . program . proto . instructions [ self . proto_index ] try : capstone_operands = len ( self . cs_inst . operands ) except AttributeError : capstone_operands = 0 operand_count = max ( capstone_operands , len ( inst . operand_index )) for idx in range ( operand_count ): try : operand_index = inst . operand_index [ idx ] except IndexError : # logger.debug('Less IDA operands than capstone') continue details = None try : details = self . cs_inst . operands [ idx ] except ( IndexError , quokka . exc . InstructionError ): # logger.debug('Missing an IDA operand for capstone') pass # TODO(dm): Allow partial operands with only half of the data if operand_index != - 1 : operands . append ( Operand ( self . program . proto . operands [ operand_index ], capstone_operand = details , program = self . program , ) ) return operands @cached_property def call_target ( self ) -> quokka . Chunk : \"\"\"Find the call target of an instruction if any exists\"\"\" call_target = False candidates = set () for reference in self . program . references . resolve_inst_instance ( self . inst_tuple , ReferenceType . CALL , towards = False ): # FIX: in Quokka a bug existed where the call target could be data if isinstance ( reference . destination , tuple ): candidates . add ( reference . destination [ 0 ]) # A chunk elif isinstance ( reference . destination , quokka . Chunk ): candidates . add ( reference . destination ) try : call_target = candidates . pop () except KeyError : pass if candidates : logger . warning ( f \"We found multiple candidate targets for 0x { self . address : x } \" ) return call_target @property def has_call ( self ) -> bool : \"\"\"Check if the instruction has a call target\"\"\" return self . call_target is not False @cached_property def constants ( self ) -> List [ int ]: \"\"\"Fast accessor for instructions constant not using Capstone.\"\"\" constants = [] for op_index in self . program . proto . instructions [ self . proto_index ] . operand_index : operand : quokka . pb . Quokka . Operand = self . program . proto . operands [ op_index ] if operand . type == 5 : # FIX: This bug is due to IDA mislabelling operands for some # operations like ADRP on ARM where the operand points to a # memory area (2) but the type is CONSTANT (5). # The behavior is inconsistent with LEA on Intel arch where # the operand is properly labelled (either 2 or 5). if not self . data_references : constants . append ( operand . value ) return constants def __str__ ( self ) -> str : \"\"\"String representation of the instruction First, try by capstone because it's prettier Otherwise, fallback to the mnemonic which is better than nothing. Returns: A string representation of the mnemonic \"\"\" # First, try with the operand strings (case MODE FULL) inst = self . program . proto . instructions [ self . proto_index ] if self . program . mode == ExporterMode . FULL : operands = \", \" . join ( self . program . proto . operand_table [ x ] for x in inst . operand_strings ) return f \"<Inst { self . mnemonic } { operands } >\" # Second tentative, use capstone if self . cs_inst is not None : return f \"< { self . cs_inst . mnemonic } { self . cs_inst . op_str } >\" # Finally, just use the mnemonic return f \"<Inst { self . mnemonic } >\" @cached_property def bytes ( self ) -> bytes : \"\"\"Read the program binary to find the bytes associated to the instruction. This is not cached as it is already in memory. Returns: Bytes associated to the instruction \"\"\" try : file_offset = self . program . addresser . file ( self . address ) except quokka . exc . NotInFileError : return b \"\" return self . program . executable . read_byte ( offset = file_offset , size = self . size , )","title":"Instruction"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.__str__","text":"String representation of the instruction First, try by capstone because it's prettier Otherwise, fallback to the mnemonic which is better than nothing. Returns: Type Description str A string representation of the mnemonic Source code in quokka/instruction.py 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def __str__ ( self ) -> str : \"\"\"String representation of the instruction First, try by capstone because it's prettier Otherwise, fallback to the mnemonic which is better than nothing. Returns: A string representation of the mnemonic \"\"\" # First, try with the operand strings (case MODE FULL) inst = self . program . proto . instructions [ self . proto_index ] if self . program . mode == ExporterMode . FULL : operands = \", \" . join ( self . program . proto . operand_table [ x ] for x in inst . operand_strings ) return f \"<Inst { self . mnemonic } { operands } >\" # Second tentative, use capstone if self . cs_inst is not None : return f \"< { self . cs_inst . mnemonic } { self . cs_inst . op_str } >\" # Finally, just use the mnemonic return f \"<Inst { self . mnemonic } >\"","title":"__str__()"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.bytes","text":"Read the program binary to find the bytes associated to the instruction. This is not cached as it is already in memory. Returns: Type Description bytes Bytes associated to the instruction Source code in quokka/instruction.py 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 @cached_property def bytes ( self ) -> bytes : \"\"\"Read the program binary to find the bytes associated to the instruction. This is not cached as it is already in memory. Returns: Bytes associated to the instruction \"\"\" try : file_offset = self . program . addresser . file ( self . address ) except quokka . exc . NotInFileError : return b \"\" return self . program . executable . read_byte ( offset = file_offset , size = self . size , )","title":"bytes()"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.call_references","text":"Returns all call reference to this instruction Source code in quokka/instruction.py 228 229 230 231 @property def call_references ( self ) -> List [ ReferenceTarget ]: \"\"\"Returns all call reference to this instruction\"\"\" return self . references [ ReferenceType . CALL ]","title":"call_references()"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.call_target","text":"Find the call target of an instruction if any exists Source code in quokka/instruction.py 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 @cached_property def call_target ( self ) -> quokka . Chunk : \"\"\"Find the call target of an instruction if any exists\"\"\" call_target = False candidates = set () for reference in self . program . references . resolve_inst_instance ( self . inst_tuple , ReferenceType . CALL , towards = False ): # FIX: in Quokka a bug existed where the call target could be data if isinstance ( reference . destination , tuple ): candidates . add ( reference . destination [ 0 ]) # A chunk elif isinstance ( reference . destination , quokka . Chunk ): candidates . add ( reference . destination ) try : call_target = candidates . pop () except KeyError : pass if candidates : logger . warning ( f \"We found multiple candidate targets for 0x { self . address : x } \" ) return call_target","title":"call_target()"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.constants","text":"Fast accessor for instructions constant not using Capstone. Source code in quokka/instruction.py 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 @cached_property def constants ( self ) -> List [ int ]: \"\"\"Fast accessor for instructions constant not using Capstone.\"\"\" constants = [] for op_index in self . program . proto . instructions [ self . proto_index ] . operand_index : operand : quokka . pb . Quokka . Operand = self . program . proto . operands [ op_index ] if operand . type == 5 : # FIX: This bug is due to IDA mislabelling operands for some # operations like ADRP on ARM where the operand points to a # memory area (2) but the type is CONSTANT (5). # The behavior is inconsistent with LEA on Intel arch where # the operand is properly labelled (either 2 or 5). if not self . data_references : constants . append ( operand . value ) return constants","title":"constants()"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.cs_inst","text":"Load an instruction from Capstone backend If the decoding fails, the result won't be cached, and it will be attempted again. Returns: Type Description Optional [ capstone . CsInsn ] A Capstone instruction Source code in quokka/instruction.py 171 172 173 174 175 176 177 178 179 180 181 182 @cached_property def cs_inst ( self ) -> Optional [ capstone . CsInsn ]: \"\"\"Load an instruction from Capstone backend If the decoding fails, the result won't be cached, and it will be attempted again. Returns: A Capstone instruction \"\"\" return quokka . backends . capstone_decode_instruction ( self )","title":"cs_inst()"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.data_references","text":"Returns all data reference to this instruction Source code in quokka/instruction.py 213 214 215 216 @property def data_references ( self ) -> List [ ReferenceTarget ]: \"\"\"Returns all data reference to this instruction\"\"\" return self . references [ ReferenceType . DATA ]","title":"data_references()"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.enum_references","text":"Returns all enum reference to this instruction Source code in quokka/instruction.py 223 224 225 226 @property def enum_references ( self ) -> List [ ReferenceTarget ]: \"\"\"Returns all enum reference to this instruction\"\"\" return self . references [ ReferenceType . ENUM ]","title":"enum_references()"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.has_call","text":"Check if the instruction has a call target Source code in quokka/instruction.py 300 301 302 303 @property def has_call ( self ) -> bool : \"\"\"Check if the instruction has a call target\"\"\" return self . call_target is not False","title":"has_call()"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.mnemonic","text":"Return the mnemonic for the instruction. First, try to use capstone because it's prettier Otherwise, fallback to the IDA mnemonic which is better than nothing. Returns: Type Description str A string representation of the mnemonic Source code in quokka/instruction.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 @cached_property def mnemonic ( self ) -> str : \"\"\"Return the mnemonic for the instruction. First, try to use capstone because it's prettier Otherwise, fallback to the IDA mnemonic which is better than nothing. Returns: A string representation of the mnemonic \"\"\" if self . cs_inst is not None : return self . cs_inst . mnemonic instruction = self . program . proto . instructions [ self . proto_index ] return self . program . proto . mnemonics [ instruction . mnemonic_index ]","title":"mnemonic()"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.operands","text":"Retrieve the instruction operands and initialize them with Capstone Source code in quokka/instruction.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 @property def operands ( self ) -> List [ Operand ]: \"\"\"Retrieve the instruction operands and initialize them with Capstone\"\"\" operands : List [ Operand ] = [] inst = self . program . proto . instructions [ self . proto_index ] try : capstone_operands = len ( self . cs_inst . operands ) except AttributeError : capstone_operands = 0 operand_count = max ( capstone_operands , len ( inst . operand_index )) for idx in range ( operand_count ): try : operand_index = inst . operand_index [ idx ] except IndexError : # logger.debug('Less IDA operands than capstone') continue details = None try : details = self . cs_inst . operands [ idx ] except ( IndexError , quokka . exc . InstructionError ): # logger.debug('Missing an IDA operand for capstone') pass # TODO(dm): Allow partial operands with only half of the data if operand_index != - 1 : operands . append ( Operand ( self . program . proto . operands [ operand_index ], capstone_operand = details , program = self . program , ) ) return operands","title":"operands()"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.pcode_insts","text":"Retrieve the PcodeOps associated to the instruction Returns: Type Description Sequence [ pypcode . PcodeOp ] A sequence of PCode instructions Source code in quokka/instruction.py 184 185 186 187 188 189 190 191 @cached_property def pcode_insts ( self ) -> Sequence [ pypcode . PcodeOp ]: \"\"\"Retrieve the PcodeOps associated to the instruction Returns: A sequence of PCode instructions \"\"\" return quokka . backends . pypcode_decode_instruction ( self )","title":"pcode_insts()"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.references","text":"Returns all the references towards the instruction Source code in quokka/instruction.py 202 203 204 205 206 207 208 209 210 211 @property def references ( self ) -> Dict [ ReferenceType , List [ ReferenceTarget ]]: \"\"\"Returns all the references towards the instruction\"\"\" ref = defaultdict ( list ) for reference in self . program . references . resolve_inst_instance ( self . inst_tuple , towards = True ): ref [ reference . type ] . append ( reference . source ) return ref","title":"references()"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.string","text":"String used by the instruction (if any) Source code in quokka/instruction.py 193 194 195 196 197 198 199 200 @cached_property def string ( self ) -> Optional [ str ]: \"\"\"String used by the instruction (if any)\"\"\" for data in self . data_references : if isinstance ( data , quokka . data . Data ) and data . type == DataType . ASCII : return data . value return None","title":"string()"},{"location":"reference/python/instruction/#quokka.instruction.Instruction.struct_references","text":"Returns all struct reference to this instruction Source code in quokka/instruction.py 218 219 220 221 @property def struct_references ( self ) -> List [ ReferenceTarget ]: \"\"\"Returns all struct reference to this instruction\"\"\" return self . references [ ReferenceType . STRUC ]","title":"struct_references()"},{"location":"reference/python/instruction/#quokka.instruction.Operand","text":"Operand object An operand is an \"argument\" for an instruction. This class represent them but is rather lackluster at the moment. Parameters: Name Type Description Default proto_operand Operand Protobuf data required capstone_operand Capstone data (if any) None program Union [None, quokka . Program ] Program reference None Attributes: Name Type Description program quokka . Program Program reference type int Operand type flags int Operand flags address Optional [ int ] Operand address value_type IDA value type reg_id IDA register ID (if applicable) details Capstone details Source code in quokka/instruction.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class Operand : \"\"\"Operand object An operand is an \"argument\" for an instruction. This class represent them but is rather lackluster at the moment. Arguments: proto_operand: Protobuf data capstone_operand: Capstone data (if any) program: Program reference Attributes: program: Program reference type: Operand type flags: Operand flags address: Operand address value_type: IDA value type reg_id: IDA register ID (if applicable) details: Capstone details \"\"\" # Operand rewrite to integrate capstone information as well def __init__ ( self , proto_operand : \"quokka.pb.Quokka.Operand\" , capstone_operand = None , program : Union [ None , quokka . Program ] = None , ): \"\"\"Constructor\"\"\" self . program : quokka . Program = program self . type : int = proto_operand . type self . flags : int = proto_operand . flags # TODO(dm) self . address : Optional [ int ] = ( proto_operand . address if proto_operand . address != 0 else None ) self . value_type = proto_operand . value_type self . reg_id = proto_operand . register_id self . _value = proto_operand . value self . details = capstone_operand @property def value ( self ) -> Any : \"\"\"Returns the operand value Warning: this is only implemented for constant operand (in IDA). Returns: The operand value \"\"\" if self . type == 5 : # Type: IDA constant return self . _value raise NotImplementedError def is_constant ( self ) -> bool : \"\"\"Check if the operand is a constant\"\"\" return self . type == 5","title":"Operand"},{"location":"reference/python/instruction/#quokka.instruction.Operand.__init__","text":"Constructor Source code in quokka/instruction.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def __init__ ( self , proto_operand : \"quokka.pb.Quokka.Operand\" , capstone_operand = None , program : Union [ None , quokka . Program ] = None , ): \"\"\"Constructor\"\"\" self . program : quokka . Program = program self . type : int = proto_operand . type self . flags : int = proto_operand . flags # TODO(dm) self . address : Optional [ int ] = ( proto_operand . address if proto_operand . address != 0 else None ) self . value_type = proto_operand . value_type self . reg_id = proto_operand . register_id self . _value = proto_operand . value self . details = capstone_operand","title":"__init__()"},{"location":"reference/python/instruction/#quokka.instruction.Operand.is_constant","text":"Check if the operand is a constant Source code in quokka/instruction.py 104 105 106 def is_constant ( self ) -> bool : \"\"\"Check if the operand is a constant\"\"\" return self . type == 5","title":"is_constant()"},{"location":"reference/python/instruction/#quokka.instruction.Operand.value","text":"Returns the operand value Warning: this is only implemented for constant operand (in IDA). Returns: Type Description Any The operand value Source code in quokka/instruction.py 90 91 92 93 94 95 96 97 98 99 100 101 102 @property def value ( self ) -> Any : \"\"\"Returns the operand value Warning: this is only implemented for constant operand (in IDA). Returns: The operand value \"\"\" if self . type == 5 : # Type: IDA constant return self . _value raise NotImplementedError","title":"value()"},{"location":"reference/python/program/","text":"Program This is the main class of Quokka. It deals with the most common abstraction, the Program. Program Bases: dict Program The program is quokka main abstraction. It represents the full binary and is in itself a mapping of functions. Parameters: Name Type Description Default export_file Union [ pathlib . Path , str ] Path towards the export file (e.g. .quokka) required exec_path Union [ pathlib . Path , str ] Path towards the binary file required Attributes: Name Type Description proto quokka . pb . Quokka Contains the protobuf data. This should not be used directly. However, if you don't find another way of accessing some information, feel free to open an issue. export_file pathlib . Path The path to the export file (e.g. the .quokka) mode ExporterMode Export mode (LIGHT, NORMAL or FULL) base_address AddressT Program base address addresser Utility to convert the program offsets into file-offsets isa quokka . analysis . ArchEnum Instruction set address_size int Default pointer size arch Type [ quokka . analysis . QuokkaArch ] Program architecture endianness Endianness Program endianness chunks Dict [ int , Union [ quokka . Chunk , quokka . SuperChunk ]] A mapping of chunks executable An object to manage the binary file references The reference manager data_holder The data manager fun_names Dict [ str , quokka . Function ] A mapping of function names to functions Raises: Type Description QuokkaError If the loading is not successful. Source code in quokka/program.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 class Program ( dict ): \"\"\"Program The program is `quokka` main abstraction. It represents the full binary and is in itself a mapping of functions. Arguments: export_file: Path towards the export file (e.g. .quokka) exec_path: Path towards the binary file Attributes: proto: Contains the protobuf data. This should not be used directly. However, if you don't find another way of accessing some information, feel free to open an issue. export_file: The path to the export file (e.g. the .quokka) mode: Export mode (LIGHT, NORMAL or FULL) base_address: Program base address addresser: Utility to convert the program offsets into file-offsets isa: Instruction set address_size: Default pointer size arch: Program architecture endianness: Program endianness chunks: A mapping of chunks executable: An object to manage the binary file references: The reference manager data_holder: The data manager fun_names: A mapping of function names to functions Raises: QuokkaError: If the loading is not successful. \"\"\" logger : logging . Logger = logging . getLogger ( __name__ ) def __init__ ( self , export_file : Union [ pathlib . Path , str ], exec_path : Union [ pathlib . Path , str ] ): \"\"\"Constructor\"\"\" super ( dict , self ) . __init__ () self . proto : quokka . pb . Quokka = quokka . pb . Quokka () self . export_file : pathlib . Path = pathlib . Path ( export_file ) with open ( self . export_file , \"rb\" ) as fd : self . proto . ParseFromString ( fd . read ()) # Export mode self . mode : ExporterMode = ExporterMode . from_proto ( self . proto . exporter_meta . mode ) # Check if it matches the version if self . proto . exporter_meta . version != quokka . __quokka_version__ : self . logger . warning ( \"The exported file has been generated by a different version of Quokka.\" f \" The file has been generated by Quokka { self . proto . exporter_meta . version } \" f \" while python-quokka uses { quokka . __quokka_version__ } \" ) # Check if the hashes matches between the export file and the exec if not quokka . check_hash ( self . proto . meta . hash , pathlib . Path ( exec_path )): self . logger . error ( \"Hash does not match with file.\" ) raise quokka . QuokkaError ( \"Hash mismatch\" ) self . base_address : AddressT = self . proto . meta . base_addr self . addresser = quokka . Addresser ( self , self . base_address ) self . isa : quokka . analysis . ArchEnum = quokka . get_isa ( self . proto . meta . isa ) self . address_size : int = quokka . convert_address_size ( self . proto . meta . address_size ) self . arch : Type [ quokka . analysis . QuokkaArch ] = quokka . get_arch ( self . isa , self . address_size ) self . endianness : Endianness = Endianness . from_proto ( self . proto . meta . endianess ) self . chunks : Dict [ int , Union [ quokka . Chunk , quokka . SuperChunk ]] = {} self . executable = quokka . Executable ( exec_path , self . endianness ) self . references = quokka . References ( self ) self . data_holder = quokka . DataHolder ( self . proto , self ) # Chunks for chunk_index , _ in enumerate ( self . proto . function_chunks ): chunk = quokka . Chunk ( chunk_index , program = self ) if chunk . fake : chunk = quokka . analysis . split_chunk ( chunk ) self . chunks [ chunk_index ] = chunk # Functions self . fun_names : Dict [ str , quokka . Function ] = {} for func in self . proto . functions : function = quokka . Function ( func , self ) self [ function . start ] = function if function . name not in self . fun_names : self . fun_names [ function . name ] = function else : if function . type == self . fun_names [ function . name ]: self . logger . warning ( \"Found two functions with the same name.\" ) else : if function . type == FunctionType . NORMAL : self . fun_names [ function . name ] = function def __hash__ ( self ) -> int : \"\"\"Hash of the Program (use the hash from the exported file)\"\"\" return int ( self . proto . meta . hash . hash_value , 16 ) @property def name ( self ) -> str : \"\"\"Returns the underlying binary name\"\"\" return self . proto . meta . executable_name @property def hash ( self ) -> str : \"\"\"Returns the hash value of the binary (either sha256 or MD5).\"\"\" return self . proto . meta . hash . hash_value @cached_property def capstone ( self ) -> capstone . Cs : \"\"\"Compute a capstone context\"\"\" return quokka . backends . get_capstone_context ( self . arch ) @cached_property def call_graph ( self ) -> networkx . DiGraph : \"\"\"Compute the Call Graph of the binary Every node in the call graph is a chunk (and not a function). :return: A Call Graph (a networkx DiGraph) \"\"\" call_graph : \"networkx.DiGraph\" = networkx . DiGraph () chunk : Union [ quokka . Chunk , quokka . SuperChunk ] for chunk in self . chunks . values (): if isinstance ( chunk , quokka . Chunk ): call_graph . add_node ( chunk . start ) call_graph . add_edges_from ( product (( chunk . start ,), chunk . calls )) else : # Super Chunks for small_chunk in chunk . starts . values (): call_graph . add_edges_from ( product (( small_chunk ,), small_chunk . calls ) ) return call_graph @cached_property def pypcode ( self ) -> pypcode . Context : \"\"\"Generate the Pypcode context.\"\"\" return quokka . backends . get_pypcode_context ( self . arch ) @cached_property def structures ( self ) -> List [ quokka . Structure ]: \"\"\"Structures accessor Allows to retrieve the different structures of a program (as defined by the disassembler). Returns: A list of structures \"\"\" structures = [ quokka . Structure ( structure , self ) for structure in self . proto . structs ] return structures @property def strings ( self ) -> Iterable [ str ]: \"\"\"Program strings Retrieves all the strings used in the program. Returns: A list of strings. \"\"\" # Do not use the empty string (the first one) return self . proto . string_table [ 1 :] @cached_property def segments ( self ) -> List [ quokka . Segment ]: \"\"\"Returns the list of segments defined in the program.\"\"\" return [ quokka . Segment ( segment , self ) for segment in self . proto . segments ] def get_instruction ( self , address : AddressT ) -> quokka . Instruction : \"\"\"Get an instruction by its address Note: the address must be the head of the instruction. TODO(dm): Improve the algorithm because the chunks are sorted (use bisect) Arguments: address: AddressT: Address to query Returns: A `quokka.Instruction` Raises: IndexError: When no instruction is found at this address \"\"\" for chunk in self . chunks . values (): if chunk . in_chunk ( address ): try : return chunk . get_instruction ( address ) except IndexError : pass raise IndexError ( f \"No instruction at address 0x { address : x } \" ) def get_function ( self , name : str , approximative : bool = True , normal : bool = False ) -> quokka . Function : \"\"\"Find a function in a program by its name Arguments: name: Function name approximative: Should the name exactly match or allow partial matches? normal: Return only FunctionType.NORMAL functions Returns: A function matching the research criteria Raises: ValueError: When no function is found \"\"\" if approximative is False : try : return self . fun_names [ name ] except KeyError as exc : raise ValueError ( \"Missing function\" ) from exc for function_name , function in self . fun_names . items (): # TODO(dm) Improve this if name in function . name and ( not normal or function . type == FunctionType . NORMAL ): return self . fun_names [ function_name ] raise ValueError ( \"Unable to find an appropriate function\" ) def get_segment ( self , address : AddressT ) -> quokka . Segment : \"\"\"Get a `Segment` by an address The address must be in [segment.start, segment.end) to be found. Arguments: address: Segment's address Returns: The corresponding Segment Raises: KeyError: When the segment is not found \"\"\" for segment in self . segments : if segment . in_segment ( address ): return segment raise KeyError ( f \"No segment has been found for address 0x { address } \" ) @cached_property def func_chunk_index ( self ) -> Dict [ Index , List [ quokka . Function ]]: \"\"\"Returns the list of functions attached to a chunk. This method allows to find all the functions using a specific chunk. However, it is mostly an internal method and should not be directly used by a user. Instead, use `get_function_by_chunk`. Returns: A mapping of ChunkIndex to a list of Function. \"\"\" func_chunk_index = collections . defaultdict ( list ) for function in self . values (): for chunk_proto_index in function . index_to_address : func_chunk_index [ chunk_proto_index ] . append ( function ) return func_chunk_index def get_function_by_chunk ( self , chunk : quokka . Chunk ) -> List [ quokka . Function ]: \"\"\"Retrieves all the functions where `chunk` belongs. Arguments: chunk: Chunk to search for Returns: A list of corresponding functions Raises: IndexError: When no function is found for the chunk. \"\"\" functions = self . func_chunk_index [ chunk . proto_index ] if not functions : raise IndexError ( \"No function has been found for the chunk. \" \"This is probably a Quokka bug and should be reported.\" ) return functions def get_first_function_by_chunk ( self , chunk : quokka . Chunk ) -> Optional [ quokka . Function ]: \"\"\"Return the first function found when searching for a chunk. Arguments: chunk: Chunk belonging to the function Returns: A function in which `chunk` belongs Raises: FunctionMissingError: No function has been found for the chunk \"\"\" try : return self . get_function_by_chunk ( chunk )[ 0 ] except IndexError : raise quokka . FunctionMissingError ( \"Missing function from chunk\" ) def get_chunk ( self , chunk_index : Index , block_index : Optional [ Index ] = None ) -> quokka . Chunk : \"\"\"Get a `Chunk` If the candidate Chunk is a SuperChunk, this method will resolve it to find the appropriate chunk (given a block index). Arguments: chunk_index: Chunk index block_index: Used to resolve SuperChunks Returns: A Chunk matching the criteria Raises: ChunkMissingError: When no chunk has been found \"\"\" chunk = self . chunks . get ( chunk_index , None ) if isinstance ( chunk , quokka . Chunk ): return chunk if isinstance ( chunk , quokka . SuperChunk ): if block_index is None : raise quokka . ChunkMissingError ( \"Unable to find the chunk requested because its a super chunk\" ) return chunk . get_chunk_by_index ( chunk_index , block_index ) raise quokka . ChunkMissingError ( \"Unable to find the chunk, index unknown\" ) def iter_chunk ( self , chunk_types : Optional [ List [ FunctionType ]] = None ) -> Iterator [ quokka . Chunk ]: \"\"\"Iterate over all the chunks in the program. If a `SuperChunk` is found, it will split it and return individual chunks. By default, it iterates over all the chunks, even extern functions. Arguments: chunk_types: Allow list of chunk types. By default, it retrieves every chunk. Yields: All the chunks in the program. \"\"\" if chunk_types is None : chunk_types = list ( FunctionType ) chunk : quokka . Chunk for chunk in self . chunks . values (): if isinstance ( chunk , quokka . SuperChunk ): inner_chunk : quokka . Chunk for inner_chunk in chunk . values (): if inner_chunk . chunk_type in chunk_types : yield inner_chunk else : if chunk . chunk_type in chunk_types : yield chunk def get_data ( self , address : AddressT ) -> quokka . Data : \"\"\"Get data by address Arguments: address: Address to query Returns: A data at the address \"\"\" return self . data_holder . get_data ( address ) def __repr__ ( self ) -> str : \"\"\"Program representation\"\"\" return self . __str__ () def __str__ ( self ) -> str : \"\"\"Program representation\"\"\" return f \"<Program { self . executable . exec_file . name } ( { self . arch . __name__ } )>\" @staticmethod def from_binary ( exec_path : Union [ pathlib . Path , str ], output_file : Optional [ Union [ pathlib . Path , str ]] = None , database_file : Optional [ Union [ pathlib . Path , str ]] = None , debug : bool = False , timeout : Optional [ int ] = 600 , ) -> Optional [ Program ]: \"\"\"Generate an export file directly from the binary. This methods will export `exec_path` directly using Quokka IDA's plugin if installed. Arguments: exec_path: Binary to export. output_file: Where to store the result (by default: near the executable) database_file: Where to store IDA database (by default: near the executable) timeout: How long should we wait for the export to finish (default: 10 min) debug: Activate the debug output Returns: A |`Program` instance or None if Raises: FileNotFoundError: If the executable is not found \"\"\" exec_path = pathlib . Path ( exec_path ) if not exec_path . is_file (): raise FileNotFoundError ( \"Missing exec file\" ) if output_file is None : output_file = exec_path . parent / f \" { exec_path . name } .Quokka\" else : output_file = pathlib . Path ( output_file ) if output_file . is_file (): return Program ( output_file , exec_path ) exec_file = exec_path if database_file is None : database_file = exec_file . parent / f \" { exec_file . name } .i64\" else : database_file = pathlib . Path ( database_file ) additional_options = [] if not database_file . is_file (): additional_options . append ( f '-o { database_file . with_suffix ( \"\" ) } ' ) else : exec_file = database_file ida_path = os . environ . get ( \"IDA_PATH\" , \"idat64\" ) try : cmd = ( [ ida_path , \"-OQuokkaAuto:true\" , f \"-OQuokkaFile: { output_file } \" , ] + additional_options + [ \"-A\" , f \" { exec_file !s} \" ] ) Program . logger . info ( \" %s \" , \" \" . join ( cmd )) result = subprocess . run ( cmd , stderr = subprocess . PIPE , stdout = subprocess . PIPE , env = { \"TVHEADLESS\" : \"1\" , \"HOME\" : os . environ [ \"HOME\" ], \"PATH\" : os . environ . get ( \"PATH\" , \"\" ), \"TERM\" : \"xterm\" , # problem with libcurses }, timeout = timeout , check = True , ) if debug or result . returncode != 0 : Program . logger . debug ( result . stderr ) except subprocess . CalledProcessError : return None if not output_file . is_file (): return None return Program ( output_file , exec_path ) __hash__ () Hash of the Program (use the hash from the exported file) Source code in quokka/program.py 158 159 160 def __hash__ ( self ) -> int : \"\"\"Hash of the Program (use the hash from the exported file)\"\"\" return int ( self . proto . meta . hash . hash_value , 16 ) __init__ ( export_file , exec_path ) Constructor Source code in quokka/program.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def __init__ ( self , export_file : Union [ pathlib . Path , str ], exec_path : Union [ pathlib . Path , str ] ): \"\"\"Constructor\"\"\" super ( dict , self ) . __init__ () self . proto : quokka . pb . Quokka = quokka . pb . Quokka () self . export_file : pathlib . Path = pathlib . Path ( export_file ) with open ( self . export_file , \"rb\" ) as fd : self . proto . ParseFromString ( fd . read ()) # Export mode self . mode : ExporterMode = ExporterMode . from_proto ( self . proto . exporter_meta . mode ) # Check if it matches the version if self . proto . exporter_meta . version != quokka . __quokka_version__ : self . logger . warning ( \"The exported file has been generated by a different version of Quokka.\" f \" The file has been generated by Quokka { self . proto . exporter_meta . version } \" f \" while python-quokka uses { quokka . __quokka_version__ } \" ) # Check if the hashes matches between the export file and the exec if not quokka . check_hash ( self . proto . meta . hash , pathlib . Path ( exec_path )): self . logger . error ( \"Hash does not match with file.\" ) raise quokka . QuokkaError ( \"Hash mismatch\" ) self . base_address : AddressT = self . proto . meta . base_addr self . addresser = quokka . Addresser ( self , self . base_address ) self . isa : quokka . analysis . ArchEnum = quokka . get_isa ( self . proto . meta . isa ) self . address_size : int = quokka . convert_address_size ( self . proto . meta . address_size ) self . arch : Type [ quokka . analysis . QuokkaArch ] = quokka . get_arch ( self . isa , self . address_size ) self . endianness : Endianness = Endianness . from_proto ( self . proto . meta . endianess ) self . chunks : Dict [ int , Union [ quokka . Chunk , quokka . SuperChunk ]] = {} self . executable = quokka . Executable ( exec_path , self . endianness ) self . references = quokka . References ( self ) self . data_holder = quokka . DataHolder ( self . proto , self ) # Chunks for chunk_index , _ in enumerate ( self . proto . function_chunks ): chunk = quokka . Chunk ( chunk_index , program = self ) if chunk . fake : chunk = quokka . analysis . split_chunk ( chunk ) self . chunks [ chunk_index ] = chunk # Functions self . fun_names : Dict [ str , quokka . Function ] = {} for func in self . proto . functions : function = quokka . Function ( func , self ) self [ function . start ] = function if function . name not in self . fun_names : self . fun_names [ function . name ] = function else : if function . type == self . fun_names [ function . name ]: self . logger . warning ( \"Found two functions with the same name.\" ) else : if function . type == FunctionType . NORMAL : self . fun_names [ function . name ] = function __repr__ () Program representation Source code in quokka/program.py 445 446 447 def __repr__ ( self ) -> str : \"\"\"Program representation\"\"\" return self . __str__ () __str__ () Program representation Source code in quokka/program.py 449 450 451 def __str__ ( self ) -> str : \"\"\"Program representation\"\"\" return f \"<Program { self . executable . exec_file . name } ( { self . arch . __name__ } )>\" call_graph () cached property Compute the Call Graph of the binary Every node in the call graph is a chunk (and not a function). :return: A Call Graph (a networkx DiGraph) Source code in quokka/program.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 @cached_property def call_graph ( self ) -> networkx . DiGraph : \"\"\"Compute the Call Graph of the binary Every node in the call graph is a chunk (and not a function). :return: A Call Graph (a networkx DiGraph) \"\"\" call_graph : \"networkx.DiGraph\" = networkx . DiGraph () chunk : Union [ quokka . Chunk , quokka . SuperChunk ] for chunk in self . chunks . values (): if isinstance ( chunk , quokka . Chunk ): call_graph . add_node ( chunk . start ) call_graph . add_edges_from ( product (( chunk . start ,), chunk . calls )) else : # Super Chunks for small_chunk in chunk . starts . values (): call_graph . add_edges_from ( product (( small_chunk ,), small_chunk . calls ) ) return call_graph capstone () cached property Compute a capstone context Source code in quokka/program.py 172 173 174 175 @cached_property def capstone ( self ) -> capstone . Cs : \"\"\"Compute a capstone context\"\"\" return quokka . backends . get_capstone_context ( self . arch ) from_binary ( exec_path , output_file = None , database_file = None , debug = False , timeout = 600 ) staticmethod Generate an export file directly from the binary. This methods will export exec_path directly using Quokka IDA's plugin if installed. Parameters: Name Type Description Default exec_path Union [ pathlib . Path , str ] Binary to export. required output_file Optional [ Union [ pathlib . Path , str ]] Where to store the result (by default: near the executable) None database_file Optional [ Union [ pathlib . Path , str ]] Where to store IDA database (by default: near the executable) None timeout Optional [ int ] How long should we wait for the export to finish (default: 10 min) 600 debug bool Activate the debug output False Returns: Type Description Optional [ Program ] A | Program instance or None if Raises: Type Description FileNotFoundError If the executable is not found Source code in quokka/program.py 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 @staticmethod def from_binary ( exec_path : Union [ pathlib . Path , str ], output_file : Optional [ Union [ pathlib . Path , str ]] = None , database_file : Optional [ Union [ pathlib . Path , str ]] = None , debug : bool = False , timeout : Optional [ int ] = 600 , ) -> Optional [ Program ]: \"\"\"Generate an export file directly from the binary. This methods will export `exec_path` directly using Quokka IDA's plugin if installed. Arguments: exec_path: Binary to export. output_file: Where to store the result (by default: near the executable) database_file: Where to store IDA database (by default: near the executable) timeout: How long should we wait for the export to finish (default: 10 min) debug: Activate the debug output Returns: A |`Program` instance or None if Raises: FileNotFoundError: If the executable is not found \"\"\" exec_path = pathlib . Path ( exec_path ) if not exec_path . is_file (): raise FileNotFoundError ( \"Missing exec file\" ) if output_file is None : output_file = exec_path . parent / f \" { exec_path . name } .Quokka\" else : output_file = pathlib . Path ( output_file ) if output_file . is_file (): return Program ( output_file , exec_path ) exec_file = exec_path if database_file is None : database_file = exec_file . parent / f \" { exec_file . name } .i64\" else : database_file = pathlib . Path ( database_file ) additional_options = [] if not database_file . is_file (): additional_options . append ( f '-o { database_file . with_suffix ( \"\" ) } ' ) else : exec_file = database_file ida_path = os . environ . get ( \"IDA_PATH\" , \"idat64\" ) try : cmd = ( [ ida_path , \"-OQuokkaAuto:true\" , f \"-OQuokkaFile: { output_file } \" , ] + additional_options + [ \"-A\" , f \" { exec_file !s} \" ] ) Program . logger . info ( \" %s \" , \" \" . join ( cmd )) result = subprocess . run ( cmd , stderr = subprocess . PIPE , stdout = subprocess . PIPE , env = { \"TVHEADLESS\" : \"1\" , \"HOME\" : os . environ [ \"HOME\" ], \"PATH\" : os . environ . get ( \"PATH\" , \"\" ), \"TERM\" : \"xterm\" , # problem with libcurses }, timeout = timeout , check = True , ) if debug or result . returncode != 0 : Program . logger . debug ( result . stderr ) except subprocess . CalledProcessError : return None if not output_file . is_file (): return None return Program ( output_file , exec_path ) func_chunk_index () cached property Returns the list of functions attached to a chunk. This method allows to find all the functions using a specific chunk. However, it is mostly an internal method and should not be directly used by a user. Instead, use get_function_by_chunk . Returns: Type Description Dict [ Index , List [ quokka . Function ]] A mapping of ChunkIndex to a list of Function. Source code in quokka/program.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 @cached_property def func_chunk_index ( self ) -> Dict [ Index , List [ quokka . Function ]]: \"\"\"Returns the list of functions attached to a chunk. This method allows to find all the functions using a specific chunk. However, it is mostly an internal method and should not be directly used by a user. Instead, use `get_function_by_chunk`. Returns: A mapping of ChunkIndex to a list of Function. \"\"\" func_chunk_index = collections . defaultdict ( list ) for function in self . values (): for chunk_proto_index in function . index_to_address : func_chunk_index [ chunk_proto_index ] . append ( function ) return func_chunk_index get_chunk ( chunk_index , block_index = None ) Get a Chunk If the candidate Chunk is a SuperChunk, this method will resolve it to find the appropriate chunk (given a block index). Parameters: Name Type Description Default chunk_index Index Chunk index required block_index Optional [ Index ] Used to resolve SuperChunks None Returns: Type Description quokka . Chunk A Chunk matching the criteria Raises: Type Description ChunkMissingError When no chunk has been found Source code in quokka/program.py 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 def get_chunk ( self , chunk_index : Index , block_index : Optional [ Index ] = None ) -> quokka . Chunk : \"\"\"Get a `Chunk` If the candidate Chunk is a SuperChunk, this method will resolve it to find the appropriate chunk (given a block index). Arguments: chunk_index: Chunk index block_index: Used to resolve SuperChunks Returns: A Chunk matching the criteria Raises: ChunkMissingError: When no chunk has been found \"\"\" chunk = self . chunks . get ( chunk_index , None ) if isinstance ( chunk , quokka . Chunk ): return chunk if isinstance ( chunk , quokka . SuperChunk ): if block_index is None : raise quokka . ChunkMissingError ( \"Unable to find the chunk requested because its a super chunk\" ) return chunk . get_chunk_by_index ( chunk_index , block_index ) raise quokka . ChunkMissingError ( \"Unable to find the chunk, index unknown\" ) get_data ( address ) Get data by address Parameters: Name Type Description Default address AddressT Address to query required Returns: Type Description quokka . Data A data at the address Source code in quokka/program.py 434 435 436 437 438 439 440 441 442 443 def get_data ( self , address : AddressT ) -> quokka . Data : \"\"\"Get data by address Arguments: address: Address to query Returns: A data at the address \"\"\" return self . data_holder . get_data ( address ) get_first_function_by_chunk ( chunk ) Return the first function found when searching for a chunk. Parameters: Name Type Description Default chunk quokka . Chunk Chunk belonging to the function required Returns: Type Description Optional [ quokka . Function ] A function in which chunk belongs Raises: Type Description FunctionMissingError No function has been found for the chunk Source code in quokka/program.py 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 def get_first_function_by_chunk ( self , chunk : quokka . Chunk ) -> Optional [ quokka . Function ]: \"\"\"Return the first function found when searching for a chunk. Arguments: chunk: Chunk belonging to the function Returns: A function in which `chunk` belongs Raises: FunctionMissingError: No function has been found for the chunk \"\"\" try : return self . get_function_by_chunk ( chunk )[ 0 ] except IndexError : raise quokka . FunctionMissingError ( \"Missing function from chunk\" ) get_function ( name , approximative = True , normal = False ) Find a function in a program by its name Parameters: Name Type Description Default name str Function name required approximative bool Should the name exactly match or allow partial matches? True normal bool Return only FunctionType.NORMAL functions False Returns: Type Description quokka . Function A function matching the research criteria Raises: Type Description ValueError When no function is found Source code in quokka/program.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 def get_function ( self , name : str , approximative : bool = True , normal : bool = False ) -> quokka . Function : \"\"\"Find a function in a program by its name Arguments: name: Function name approximative: Should the name exactly match or allow partial matches? normal: Return only FunctionType.NORMAL functions Returns: A function matching the research criteria Raises: ValueError: When no function is found \"\"\" if approximative is False : try : return self . fun_names [ name ] except KeyError as exc : raise ValueError ( \"Missing function\" ) from exc for function_name , function in self . fun_names . items (): # TODO(dm) Improve this if name in function . name and ( not normal or function . type == FunctionType . NORMAL ): return self . fun_names [ function_name ] raise ValueError ( \"Unable to find an appropriate function\" ) get_function_by_chunk ( chunk ) Retrieves all the functions where chunk belongs. Parameters: Name Type Description Default chunk quokka . Chunk Chunk to search for required Returns: Type Description List [ quokka . Function ] A list of corresponding functions Raises: Type Description IndexError When no function is found for the chunk. Source code in quokka/program.py 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 def get_function_by_chunk ( self , chunk : quokka . Chunk ) -> List [ quokka . Function ]: \"\"\"Retrieves all the functions where `chunk` belongs. Arguments: chunk: Chunk to search for Returns: A list of corresponding functions Raises: IndexError: When no function is found for the chunk. \"\"\" functions = self . func_chunk_index [ chunk . proto_index ] if not functions : raise IndexError ( \"No function has been found for the chunk. \" \"This is probably a Quokka bug and should be reported.\" ) return functions get_instruction ( address ) Get an instruction by its address Note: the address must be the head of the instruction. TODO(dm): Improve the algorithm because the chunks are sorted (use bisect) Parameters: Name Type Description Default address AddressT AddressT: Address to query required Returns: Type Description quokka . Instruction A quokka.Instruction Raises: Type Description IndexError When no instruction is found at this address Source code in quokka/program.py 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 def get_instruction ( self , address : AddressT ) -> quokka . Instruction : \"\"\"Get an instruction by its address Note: the address must be the head of the instruction. TODO(dm): Improve the algorithm because the chunks are sorted (use bisect) Arguments: address: AddressT: Address to query Returns: A `quokka.Instruction` Raises: IndexError: When no instruction is found at this address \"\"\" for chunk in self . chunks . values (): if chunk . in_chunk ( address ): try : return chunk . get_instruction ( address ) except IndexError : pass raise IndexError ( f \"No instruction at address 0x { address : x } \" ) get_segment ( address ) Get a Segment by an address The address must be in [segment.start, segment.end) to be found. Parameters: Name Type Description Default address AddressT Segment's address required Returns: Type Description quokka . Segment The corresponding Segment Raises: Type Description KeyError When the segment is not found Source code in quokka/program.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 def get_segment ( self , address : AddressT ) -> quokka . Segment : \"\"\"Get a `Segment` by an address The address must be in [segment.start, segment.end) to be found. Arguments: address: Segment's address Returns: The corresponding Segment Raises: KeyError: When the segment is not found \"\"\" for segment in self . segments : if segment . in_segment ( address ): return segment raise KeyError ( f \"No segment has been found for address 0x { address } \" ) hash () property Returns the hash value of the binary (either sha256 or MD5). Source code in quokka/program.py 167 168 169 170 @property def hash ( self ) -> str : \"\"\"Returns the hash value of the binary (either sha256 or MD5).\"\"\" return self . proto . meta . hash . hash_value iter_chunk ( chunk_types = None ) Iterate over all the chunks in the program. If a SuperChunk is found, it will split it and return individual chunks. By default, it iterates over all the chunks, even extern functions. Parameters: Name Type Description Default chunk_types Optional [ List [ FunctionType ]] Allow list of chunk types. By default, it retrieves every chunk. None Yields: Type Description Iterator [ quokka . Chunk ] All the chunks in the program. Source code in quokka/program.py 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 def iter_chunk ( self , chunk_types : Optional [ List [ FunctionType ]] = None ) -> Iterator [ quokka . Chunk ]: \"\"\"Iterate over all the chunks in the program. If a `SuperChunk` is found, it will split it and return individual chunks. By default, it iterates over all the chunks, even extern functions. Arguments: chunk_types: Allow list of chunk types. By default, it retrieves every chunk. Yields: All the chunks in the program. \"\"\" if chunk_types is None : chunk_types = list ( FunctionType ) chunk : quokka . Chunk for chunk in self . chunks . values (): if isinstance ( chunk , quokka . SuperChunk ): inner_chunk : quokka . Chunk for inner_chunk in chunk . values (): if inner_chunk . chunk_type in chunk_types : yield inner_chunk else : if chunk . chunk_type in chunk_types : yield chunk name () property Returns the underlying binary name Source code in quokka/program.py 162 163 164 165 @property def name ( self ) -> str : \"\"\"Returns the underlying binary name\"\"\" return self . proto . meta . executable_name pypcode () cached property Generate the Pypcode context. Source code in quokka/program.py 200 201 202 203 @cached_property def pypcode ( self ) -> pypcode . Context : \"\"\"Generate the Pypcode context.\"\"\" return quokka . backends . get_pypcode_context ( self . arch ) segments () cached property Returns the list of segments defined in the program. Source code in quokka/program.py 232 233 234 235 @cached_property def segments ( self ) -> List [ quokka . Segment ]: \"\"\"Returns the list of segments defined in the program.\"\"\" return [ quokka . Segment ( segment , self ) for segment in self . proto . segments ] strings () property Program strings Retrieves all the strings used in the program. Returns: Type Description Iterable [ str ] A list of strings. Source code in quokka/program.py 220 221 222 223 224 225 226 227 228 229 230 @property def strings ( self ) -> Iterable [ str ]: \"\"\"Program strings Retrieves all the strings used in the program. Returns: A list of strings. \"\"\" # Do not use the empty string (the first one) return self . proto . string_table [ 1 :] structures () cached property Structures accessor Allows to retrieve the different structures of a program (as defined by the disassembler). Returns: Type Description List [ quokka . Structure ] A list of structures Source code in quokka/program.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 @cached_property def structures ( self ) -> List [ quokka . Structure ]: \"\"\"Structures accessor Allows to retrieve the different structures of a program (as defined by the disassembler). Returns: A list of structures \"\"\" structures = [ quokka . Structure ( structure , self ) for structure in self . proto . structs ] return structures","title":"program"},{"location":"reference/python/program/#quokka.program.Program","text":"Bases: dict Program The program is quokka main abstraction. It represents the full binary and is in itself a mapping of functions. Parameters: Name Type Description Default export_file Union [ pathlib . Path , str ] Path towards the export file (e.g. .quokka) required exec_path Union [ pathlib . Path , str ] Path towards the binary file required Attributes: Name Type Description proto quokka . pb . Quokka Contains the protobuf data. This should not be used directly. However, if you don't find another way of accessing some information, feel free to open an issue. export_file pathlib . Path The path to the export file (e.g. the .quokka) mode ExporterMode Export mode (LIGHT, NORMAL or FULL) base_address AddressT Program base address addresser Utility to convert the program offsets into file-offsets isa quokka . analysis . ArchEnum Instruction set address_size int Default pointer size arch Type [ quokka . analysis . QuokkaArch ] Program architecture endianness Endianness Program endianness chunks Dict [ int , Union [ quokka . Chunk , quokka . SuperChunk ]] A mapping of chunks executable An object to manage the binary file references The reference manager data_holder The data manager fun_names Dict [ str , quokka . Function ] A mapping of function names to functions Raises: Type Description QuokkaError If the loading is not successful. Source code in quokka/program.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 class Program ( dict ): \"\"\"Program The program is `quokka` main abstraction. It represents the full binary and is in itself a mapping of functions. Arguments: export_file: Path towards the export file (e.g. .quokka) exec_path: Path towards the binary file Attributes: proto: Contains the protobuf data. This should not be used directly. However, if you don't find another way of accessing some information, feel free to open an issue. export_file: The path to the export file (e.g. the .quokka) mode: Export mode (LIGHT, NORMAL or FULL) base_address: Program base address addresser: Utility to convert the program offsets into file-offsets isa: Instruction set address_size: Default pointer size arch: Program architecture endianness: Program endianness chunks: A mapping of chunks executable: An object to manage the binary file references: The reference manager data_holder: The data manager fun_names: A mapping of function names to functions Raises: QuokkaError: If the loading is not successful. \"\"\" logger : logging . Logger = logging . getLogger ( __name__ ) def __init__ ( self , export_file : Union [ pathlib . Path , str ], exec_path : Union [ pathlib . Path , str ] ): \"\"\"Constructor\"\"\" super ( dict , self ) . __init__ () self . proto : quokka . pb . Quokka = quokka . pb . Quokka () self . export_file : pathlib . Path = pathlib . Path ( export_file ) with open ( self . export_file , \"rb\" ) as fd : self . proto . ParseFromString ( fd . read ()) # Export mode self . mode : ExporterMode = ExporterMode . from_proto ( self . proto . exporter_meta . mode ) # Check if it matches the version if self . proto . exporter_meta . version != quokka . __quokka_version__ : self . logger . warning ( \"The exported file has been generated by a different version of Quokka.\" f \" The file has been generated by Quokka { self . proto . exporter_meta . version } \" f \" while python-quokka uses { quokka . __quokka_version__ } \" ) # Check if the hashes matches between the export file and the exec if not quokka . check_hash ( self . proto . meta . hash , pathlib . Path ( exec_path )): self . logger . error ( \"Hash does not match with file.\" ) raise quokka . QuokkaError ( \"Hash mismatch\" ) self . base_address : AddressT = self . proto . meta . base_addr self . addresser = quokka . Addresser ( self , self . base_address ) self . isa : quokka . analysis . ArchEnum = quokka . get_isa ( self . proto . meta . isa ) self . address_size : int = quokka . convert_address_size ( self . proto . meta . address_size ) self . arch : Type [ quokka . analysis . QuokkaArch ] = quokka . get_arch ( self . isa , self . address_size ) self . endianness : Endianness = Endianness . from_proto ( self . proto . meta . endianess ) self . chunks : Dict [ int , Union [ quokka . Chunk , quokka . SuperChunk ]] = {} self . executable = quokka . Executable ( exec_path , self . endianness ) self . references = quokka . References ( self ) self . data_holder = quokka . DataHolder ( self . proto , self ) # Chunks for chunk_index , _ in enumerate ( self . proto . function_chunks ): chunk = quokka . Chunk ( chunk_index , program = self ) if chunk . fake : chunk = quokka . analysis . split_chunk ( chunk ) self . chunks [ chunk_index ] = chunk # Functions self . fun_names : Dict [ str , quokka . Function ] = {} for func in self . proto . functions : function = quokka . Function ( func , self ) self [ function . start ] = function if function . name not in self . fun_names : self . fun_names [ function . name ] = function else : if function . type == self . fun_names [ function . name ]: self . logger . warning ( \"Found two functions with the same name.\" ) else : if function . type == FunctionType . NORMAL : self . fun_names [ function . name ] = function def __hash__ ( self ) -> int : \"\"\"Hash of the Program (use the hash from the exported file)\"\"\" return int ( self . proto . meta . hash . hash_value , 16 ) @property def name ( self ) -> str : \"\"\"Returns the underlying binary name\"\"\" return self . proto . meta . executable_name @property def hash ( self ) -> str : \"\"\"Returns the hash value of the binary (either sha256 or MD5).\"\"\" return self . proto . meta . hash . hash_value @cached_property def capstone ( self ) -> capstone . Cs : \"\"\"Compute a capstone context\"\"\" return quokka . backends . get_capstone_context ( self . arch ) @cached_property def call_graph ( self ) -> networkx . DiGraph : \"\"\"Compute the Call Graph of the binary Every node in the call graph is a chunk (and not a function). :return: A Call Graph (a networkx DiGraph) \"\"\" call_graph : \"networkx.DiGraph\" = networkx . DiGraph () chunk : Union [ quokka . Chunk , quokka . SuperChunk ] for chunk in self . chunks . values (): if isinstance ( chunk , quokka . Chunk ): call_graph . add_node ( chunk . start ) call_graph . add_edges_from ( product (( chunk . start ,), chunk . calls )) else : # Super Chunks for small_chunk in chunk . starts . values (): call_graph . add_edges_from ( product (( small_chunk ,), small_chunk . calls ) ) return call_graph @cached_property def pypcode ( self ) -> pypcode . Context : \"\"\"Generate the Pypcode context.\"\"\" return quokka . backends . get_pypcode_context ( self . arch ) @cached_property def structures ( self ) -> List [ quokka . Structure ]: \"\"\"Structures accessor Allows to retrieve the different structures of a program (as defined by the disassembler). Returns: A list of structures \"\"\" structures = [ quokka . Structure ( structure , self ) for structure in self . proto . structs ] return structures @property def strings ( self ) -> Iterable [ str ]: \"\"\"Program strings Retrieves all the strings used in the program. Returns: A list of strings. \"\"\" # Do not use the empty string (the first one) return self . proto . string_table [ 1 :] @cached_property def segments ( self ) -> List [ quokka . Segment ]: \"\"\"Returns the list of segments defined in the program.\"\"\" return [ quokka . Segment ( segment , self ) for segment in self . proto . segments ] def get_instruction ( self , address : AddressT ) -> quokka . Instruction : \"\"\"Get an instruction by its address Note: the address must be the head of the instruction. TODO(dm): Improve the algorithm because the chunks are sorted (use bisect) Arguments: address: AddressT: Address to query Returns: A `quokka.Instruction` Raises: IndexError: When no instruction is found at this address \"\"\" for chunk in self . chunks . values (): if chunk . in_chunk ( address ): try : return chunk . get_instruction ( address ) except IndexError : pass raise IndexError ( f \"No instruction at address 0x { address : x } \" ) def get_function ( self , name : str , approximative : bool = True , normal : bool = False ) -> quokka . Function : \"\"\"Find a function in a program by its name Arguments: name: Function name approximative: Should the name exactly match or allow partial matches? normal: Return only FunctionType.NORMAL functions Returns: A function matching the research criteria Raises: ValueError: When no function is found \"\"\" if approximative is False : try : return self . fun_names [ name ] except KeyError as exc : raise ValueError ( \"Missing function\" ) from exc for function_name , function in self . fun_names . items (): # TODO(dm) Improve this if name in function . name and ( not normal or function . type == FunctionType . NORMAL ): return self . fun_names [ function_name ] raise ValueError ( \"Unable to find an appropriate function\" ) def get_segment ( self , address : AddressT ) -> quokka . Segment : \"\"\"Get a `Segment` by an address The address must be in [segment.start, segment.end) to be found. Arguments: address: Segment's address Returns: The corresponding Segment Raises: KeyError: When the segment is not found \"\"\" for segment in self . segments : if segment . in_segment ( address ): return segment raise KeyError ( f \"No segment has been found for address 0x { address } \" ) @cached_property def func_chunk_index ( self ) -> Dict [ Index , List [ quokka . Function ]]: \"\"\"Returns the list of functions attached to a chunk. This method allows to find all the functions using a specific chunk. However, it is mostly an internal method and should not be directly used by a user. Instead, use `get_function_by_chunk`. Returns: A mapping of ChunkIndex to a list of Function. \"\"\" func_chunk_index = collections . defaultdict ( list ) for function in self . values (): for chunk_proto_index in function . index_to_address : func_chunk_index [ chunk_proto_index ] . append ( function ) return func_chunk_index def get_function_by_chunk ( self , chunk : quokka . Chunk ) -> List [ quokka . Function ]: \"\"\"Retrieves all the functions where `chunk` belongs. Arguments: chunk: Chunk to search for Returns: A list of corresponding functions Raises: IndexError: When no function is found for the chunk. \"\"\" functions = self . func_chunk_index [ chunk . proto_index ] if not functions : raise IndexError ( \"No function has been found for the chunk. \" \"This is probably a Quokka bug and should be reported.\" ) return functions def get_first_function_by_chunk ( self , chunk : quokka . Chunk ) -> Optional [ quokka . Function ]: \"\"\"Return the first function found when searching for a chunk. Arguments: chunk: Chunk belonging to the function Returns: A function in which `chunk` belongs Raises: FunctionMissingError: No function has been found for the chunk \"\"\" try : return self . get_function_by_chunk ( chunk )[ 0 ] except IndexError : raise quokka . FunctionMissingError ( \"Missing function from chunk\" ) def get_chunk ( self , chunk_index : Index , block_index : Optional [ Index ] = None ) -> quokka . Chunk : \"\"\"Get a `Chunk` If the candidate Chunk is a SuperChunk, this method will resolve it to find the appropriate chunk (given a block index). Arguments: chunk_index: Chunk index block_index: Used to resolve SuperChunks Returns: A Chunk matching the criteria Raises: ChunkMissingError: When no chunk has been found \"\"\" chunk = self . chunks . get ( chunk_index , None ) if isinstance ( chunk , quokka . Chunk ): return chunk if isinstance ( chunk , quokka . SuperChunk ): if block_index is None : raise quokka . ChunkMissingError ( \"Unable to find the chunk requested because its a super chunk\" ) return chunk . get_chunk_by_index ( chunk_index , block_index ) raise quokka . ChunkMissingError ( \"Unable to find the chunk, index unknown\" ) def iter_chunk ( self , chunk_types : Optional [ List [ FunctionType ]] = None ) -> Iterator [ quokka . Chunk ]: \"\"\"Iterate over all the chunks in the program. If a `SuperChunk` is found, it will split it and return individual chunks. By default, it iterates over all the chunks, even extern functions. Arguments: chunk_types: Allow list of chunk types. By default, it retrieves every chunk. Yields: All the chunks in the program. \"\"\" if chunk_types is None : chunk_types = list ( FunctionType ) chunk : quokka . Chunk for chunk in self . chunks . values (): if isinstance ( chunk , quokka . SuperChunk ): inner_chunk : quokka . Chunk for inner_chunk in chunk . values (): if inner_chunk . chunk_type in chunk_types : yield inner_chunk else : if chunk . chunk_type in chunk_types : yield chunk def get_data ( self , address : AddressT ) -> quokka . Data : \"\"\"Get data by address Arguments: address: Address to query Returns: A data at the address \"\"\" return self . data_holder . get_data ( address ) def __repr__ ( self ) -> str : \"\"\"Program representation\"\"\" return self . __str__ () def __str__ ( self ) -> str : \"\"\"Program representation\"\"\" return f \"<Program { self . executable . exec_file . name } ( { self . arch . __name__ } )>\" @staticmethod def from_binary ( exec_path : Union [ pathlib . Path , str ], output_file : Optional [ Union [ pathlib . Path , str ]] = None , database_file : Optional [ Union [ pathlib . Path , str ]] = None , debug : bool = False , timeout : Optional [ int ] = 600 , ) -> Optional [ Program ]: \"\"\"Generate an export file directly from the binary. This methods will export `exec_path` directly using Quokka IDA's plugin if installed. Arguments: exec_path: Binary to export. output_file: Where to store the result (by default: near the executable) database_file: Where to store IDA database (by default: near the executable) timeout: How long should we wait for the export to finish (default: 10 min) debug: Activate the debug output Returns: A |`Program` instance or None if Raises: FileNotFoundError: If the executable is not found \"\"\" exec_path = pathlib . Path ( exec_path ) if not exec_path . is_file (): raise FileNotFoundError ( \"Missing exec file\" ) if output_file is None : output_file = exec_path . parent / f \" { exec_path . name } .Quokka\" else : output_file = pathlib . Path ( output_file ) if output_file . is_file (): return Program ( output_file , exec_path ) exec_file = exec_path if database_file is None : database_file = exec_file . parent / f \" { exec_file . name } .i64\" else : database_file = pathlib . Path ( database_file ) additional_options = [] if not database_file . is_file (): additional_options . append ( f '-o { database_file . with_suffix ( \"\" ) } ' ) else : exec_file = database_file ida_path = os . environ . get ( \"IDA_PATH\" , \"idat64\" ) try : cmd = ( [ ida_path , \"-OQuokkaAuto:true\" , f \"-OQuokkaFile: { output_file } \" , ] + additional_options + [ \"-A\" , f \" { exec_file !s} \" ] ) Program . logger . info ( \" %s \" , \" \" . join ( cmd )) result = subprocess . run ( cmd , stderr = subprocess . PIPE , stdout = subprocess . PIPE , env = { \"TVHEADLESS\" : \"1\" , \"HOME\" : os . environ [ \"HOME\" ], \"PATH\" : os . environ . get ( \"PATH\" , \"\" ), \"TERM\" : \"xterm\" , # problem with libcurses }, timeout = timeout , check = True , ) if debug or result . returncode != 0 : Program . logger . debug ( result . stderr ) except subprocess . CalledProcessError : return None if not output_file . is_file (): return None return Program ( output_file , exec_path )","title":"Program"},{"location":"reference/python/program/#quokka.program.Program.__hash__","text":"Hash of the Program (use the hash from the exported file) Source code in quokka/program.py 158 159 160 def __hash__ ( self ) -> int : \"\"\"Hash of the Program (use the hash from the exported file)\"\"\" return int ( self . proto . meta . hash . hash_value , 16 )","title":"__hash__()"},{"location":"reference/python/program/#quokka.program.Program.__init__","text":"Constructor Source code in quokka/program.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def __init__ ( self , export_file : Union [ pathlib . Path , str ], exec_path : Union [ pathlib . Path , str ] ): \"\"\"Constructor\"\"\" super ( dict , self ) . __init__ () self . proto : quokka . pb . Quokka = quokka . pb . Quokka () self . export_file : pathlib . Path = pathlib . Path ( export_file ) with open ( self . export_file , \"rb\" ) as fd : self . proto . ParseFromString ( fd . read ()) # Export mode self . mode : ExporterMode = ExporterMode . from_proto ( self . proto . exporter_meta . mode ) # Check if it matches the version if self . proto . exporter_meta . version != quokka . __quokka_version__ : self . logger . warning ( \"The exported file has been generated by a different version of Quokka.\" f \" The file has been generated by Quokka { self . proto . exporter_meta . version } \" f \" while python-quokka uses { quokka . __quokka_version__ } \" ) # Check if the hashes matches between the export file and the exec if not quokka . check_hash ( self . proto . meta . hash , pathlib . Path ( exec_path )): self . logger . error ( \"Hash does not match with file.\" ) raise quokka . QuokkaError ( \"Hash mismatch\" ) self . base_address : AddressT = self . proto . meta . base_addr self . addresser = quokka . Addresser ( self , self . base_address ) self . isa : quokka . analysis . ArchEnum = quokka . get_isa ( self . proto . meta . isa ) self . address_size : int = quokka . convert_address_size ( self . proto . meta . address_size ) self . arch : Type [ quokka . analysis . QuokkaArch ] = quokka . get_arch ( self . isa , self . address_size ) self . endianness : Endianness = Endianness . from_proto ( self . proto . meta . endianess ) self . chunks : Dict [ int , Union [ quokka . Chunk , quokka . SuperChunk ]] = {} self . executable = quokka . Executable ( exec_path , self . endianness ) self . references = quokka . References ( self ) self . data_holder = quokka . DataHolder ( self . proto , self ) # Chunks for chunk_index , _ in enumerate ( self . proto . function_chunks ): chunk = quokka . Chunk ( chunk_index , program = self ) if chunk . fake : chunk = quokka . analysis . split_chunk ( chunk ) self . chunks [ chunk_index ] = chunk # Functions self . fun_names : Dict [ str , quokka . Function ] = {} for func in self . proto . functions : function = quokka . Function ( func , self ) self [ function . start ] = function if function . name not in self . fun_names : self . fun_names [ function . name ] = function else : if function . type == self . fun_names [ function . name ]: self . logger . warning ( \"Found two functions with the same name.\" ) else : if function . type == FunctionType . NORMAL : self . fun_names [ function . name ] = function","title":"__init__()"},{"location":"reference/python/program/#quokka.program.Program.__repr__","text":"Program representation Source code in quokka/program.py 445 446 447 def __repr__ ( self ) -> str : \"\"\"Program representation\"\"\" return self . __str__ ()","title":"__repr__()"},{"location":"reference/python/program/#quokka.program.Program.__str__","text":"Program representation Source code in quokka/program.py 449 450 451 def __str__ ( self ) -> str : \"\"\"Program representation\"\"\" return f \"<Program { self . executable . exec_file . name } ( { self . arch . __name__ } )>\"","title":"__str__()"},{"location":"reference/python/program/#quokka.program.Program.call_graph","text":"Compute the Call Graph of the binary Every node in the call graph is a chunk (and not a function). :return: A Call Graph (a networkx DiGraph) Source code in quokka/program.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 @cached_property def call_graph ( self ) -> networkx . DiGraph : \"\"\"Compute the Call Graph of the binary Every node in the call graph is a chunk (and not a function). :return: A Call Graph (a networkx DiGraph) \"\"\" call_graph : \"networkx.DiGraph\" = networkx . DiGraph () chunk : Union [ quokka . Chunk , quokka . SuperChunk ] for chunk in self . chunks . values (): if isinstance ( chunk , quokka . Chunk ): call_graph . add_node ( chunk . start ) call_graph . add_edges_from ( product (( chunk . start ,), chunk . calls )) else : # Super Chunks for small_chunk in chunk . starts . values (): call_graph . add_edges_from ( product (( small_chunk ,), small_chunk . calls ) ) return call_graph","title":"call_graph()"},{"location":"reference/python/program/#quokka.program.Program.capstone","text":"Compute a capstone context Source code in quokka/program.py 172 173 174 175 @cached_property def capstone ( self ) -> capstone . Cs : \"\"\"Compute a capstone context\"\"\" return quokka . backends . get_capstone_context ( self . arch )","title":"capstone()"},{"location":"reference/python/program/#quokka.program.Program.from_binary","text":"Generate an export file directly from the binary. This methods will export exec_path directly using Quokka IDA's plugin if installed. Parameters: Name Type Description Default exec_path Union [ pathlib . Path , str ] Binary to export. required output_file Optional [ Union [ pathlib . Path , str ]] Where to store the result (by default: near the executable) None database_file Optional [ Union [ pathlib . Path , str ]] Where to store IDA database (by default: near the executable) None timeout Optional [ int ] How long should we wait for the export to finish (default: 10 min) 600 debug bool Activate the debug output False Returns: Type Description Optional [ Program ] A | Program instance or None if Raises: Type Description FileNotFoundError If the executable is not found Source code in quokka/program.py 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 @staticmethod def from_binary ( exec_path : Union [ pathlib . Path , str ], output_file : Optional [ Union [ pathlib . Path , str ]] = None , database_file : Optional [ Union [ pathlib . Path , str ]] = None , debug : bool = False , timeout : Optional [ int ] = 600 , ) -> Optional [ Program ]: \"\"\"Generate an export file directly from the binary. This methods will export `exec_path` directly using Quokka IDA's plugin if installed. Arguments: exec_path: Binary to export. output_file: Where to store the result (by default: near the executable) database_file: Where to store IDA database (by default: near the executable) timeout: How long should we wait for the export to finish (default: 10 min) debug: Activate the debug output Returns: A |`Program` instance or None if Raises: FileNotFoundError: If the executable is not found \"\"\" exec_path = pathlib . Path ( exec_path ) if not exec_path . is_file (): raise FileNotFoundError ( \"Missing exec file\" ) if output_file is None : output_file = exec_path . parent / f \" { exec_path . name } .Quokka\" else : output_file = pathlib . Path ( output_file ) if output_file . is_file (): return Program ( output_file , exec_path ) exec_file = exec_path if database_file is None : database_file = exec_file . parent / f \" { exec_file . name } .i64\" else : database_file = pathlib . Path ( database_file ) additional_options = [] if not database_file . is_file (): additional_options . append ( f '-o { database_file . with_suffix ( \"\" ) } ' ) else : exec_file = database_file ida_path = os . environ . get ( \"IDA_PATH\" , \"idat64\" ) try : cmd = ( [ ida_path , \"-OQuokkaAuto:true\" , f \"-OQuokkaFile: { output_file } \" , ] + additional_options + [ \"-A\" , f \" { exec_file !s} \" ] ) Program . logger . info ( \" %s \" , \" \" . join ( cmd )) result = subprocess . run ( cmd , stderr = subprocess . PIPE , stdout = subprocess . PIPE , env = { \"TVHEADLESS\" : \"1\" , \"HOME\" : os . environ [ \"HOME\" ], \"PATH\" : os . environ . get ( \"PATH\" , \"\" ), \"TERM\" : \"xterm\" , # problem with libcurses }, timeout = timeout , check = True , ) if debug or result . returncode != 0 : Program . logger . debug ( result . stderr ) except subprocess . CalledProcessError : return None if not output_file . is_file (): return None return Program ( output_file , exec_path )","title":"from_binary()"},{"location":"reference/python/program/#quokka.program.Program.func_chunk_index","text":"Returns the list of functions attached to a chunk. This method allows to find all the functions using a specific chunk. However, it is mostly an internal method and should not be directly used by a user. Instead, use get_function_by_chunk . Returns: Type Description Dict [ Index , List [ quokka . Function ]] A mapping of ChunkIndex to a list of Function. Source code in quokka/program.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 @cached_property def func_chunk_index ( self ) -> Dict [ Index , List [ quokka . Function ]]: \"\"\"Returns the list of functions attached to a chunk. This method allows to find all the functions using a specific chunk. However, it is mostly an internal method and should not be directly used by a user. Instead, use `get_function_by_chunk`. Returns: A mapping of ChunkIndex to a list of Function. \"\"\" func_chunk_index = collections . defaultdict ( list ) for function in self . values (): for chunk_proto_index in function . index_to_address : func_chunk_index [ chunk_proto_index ] . append ( function ) return func_chunk_index","title":"func_chunk_index()"},{"location":"reference/python/program/#quokka.program.Program.get_chunk","text":"Get a Chunk If the candidate Chunk is a SuperChunk, this method will resolve it to find the appropriate chunk (given a block index). Parameters: Name Type Description Default chunk_index Index Chunk index required block_index Optional [ Index ] Used to resolve SuperChunks None Returns: Type Description quokka . Chunk A Chunk matching the criteria Raises: Type Description ChunkMissingError When no chunk has been found Source code in quokka/program.py 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 def get_chunk ( self , chunk_index : Index , block_index : Optional [ Index ] = None ) -> quokka . Chunk : \"\"\"Get a `Chunk` If the candidate Chunk is a SuperChunk, this method will resolve it to find the appropriate chunk (given a block index). Arguments: chunk_index: Chunk index block_index: Used to resolve SuperChunks Returns: A Chunk matching the criteria Raises: ChunkMissingError: When no chunk has been found \"\"\" chunk = self . chunks . get ( chunk_index , None ) if isinstance ( chunk , quokka . Chunk ): return chunk if isinstance ( chunk , quokka . SuperChunk ): if block_index is None : raise quokka . ChunkMissingError ( \"Unable to find the chunk requested because its a super chunk\" ) return chunk . get_chunk_by_index ( chunk_index , block_index ) raise quokka . ChunkMissingError ( \"Unable to find the chunk, index unknown\" )","title":"get_chunk()"},{"location":"reference/python/program/#quokka.program.Program.get_data","text":"Get data by address Parameters: Name Type Description Default address AddressT Address to query required Returns: Type Description quokka . Data A data at the address Source code in quokka/program.py 434 435 436 437 438 439 440 441 442 443 def get_data ( self , address : AddressT ) -> quokka . Data : \"\"\"Get data by address Arguments: address: Address to query Returns: A data at the address \"\"\" return self . data_holder . get_data ( address )","title":"get_data()"},{"location":"reference/python/program/#quokka.program.Program.get_first_function_by_chunk","text":"Return the first function found when searching for a chunk. Parameters: Name Type Description Default chunk quokka . Chunk Chunk belonging to the function required Returns: Type Description Optional [ quokka . Function ] A function in which chunk belongs Raises: Type Description FunctionMissingError No function has been found for the chunk Source code in quokka/program.py 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 def get_first_function_by_chunk ( self , chunk : quokka . Chunk ) -> Optional [ quokka . Function ]: \"\"\"Return the first function found when searching for a chunk. Arguments: chunk: Chunk belonging to the function Returns: A function in which `chunk` belongs Raises: FunctionMissingError: No function has been found for the chunk \"\"\" try : return self . get_function_by_chunk ( chunk )[ 0 ] except IndexError : raise quokka . FunctionMissingError ( \"Missing function from chunk\" )","title":"get_first_function_by_chunk()"},{"location":"reference/python/program/#quokka.program.Program.get_function","text":"Find a function in a program by its name Parameters: Name Type Description Default name str Function name required approximative bool Should the name exactly match or allow partial matches? True normal bool Return only FunctionType.NORMAL functions False Returns: Type Description quokka . Function A function matching the research criteria Raises: Type Description ValueError When no function is found Source code in quokka/program.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 def get_function ( self , name : str , approximative : bool = True , normal : bool = False ) -> quokka . Function : \"\"\"Find a function in a program by its name Arguments: name: Function name approximative: Should the name exactly match or allow partial matches? normal: Return only FunctionType.NORMAL functions Returns: A function matching the research criteria Raises: ValueError: When no function is found \"\"\" if approximative is False : try : return self . fun_names [ name ] except KeyError as exc : raise ValueError ( \"Missing function\" ) from exc for function_name , function in self . fun_names . items (): # TODO(dm) Improve this if name in function . name and ( not normal or function . type == FunctionType . NORMAL ): return self . fun_names [ function_name ] raise ValueError ( \"Unable to find an appropriate function\" )","title":"get_function()"},{"location":"reference/python/program/#quokka.program.Program.get_function_by_chunk","text":"Retrieves all the functions where chunk belongs. Parameters: Name Type Description Default chunk quokka . Chunk Chunk to search for required Returns: Type Description List [ quokka . Function ] A list of corresponding functions Raises: Type Description IndexError When no function is found for the chunk. Source code in quokka/program.py 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 def get_function_by_chunk ( self , chunk : quokka . Chunk ) -> List [ quokka . Function ]: \"\"\"Retrieves all the functions where `chunk` belongs. Arguments: chunk: Chunk to search for Returns: A list of corresponding functions Raises: IndexError: When no function is found for the chunk. \"\"\" functions = self . func_chunk_index [ chunk . proto_index ] if not functions : raise IndexError ( \"No function has been found for the chunk. \" \"This is probably a Quokka bug and should be reported.\" ) return functions","title":"get_function_by_chunk()"},{"location":"reference/python/program/#quokka.program.Program.get_instruction","text":"Get an instruction by its address Note: the address must be the head of the instruction. TODO(dm): Improve the algorithm because the chunks are sorted (use bisect) Parameters: Name Type Description Default address AddressT AddressT: Address to query required Returns: Type Description quokka . Instruction A quokka.Instruction Raises: Type Description IndexError When no instruction is found at this address Source code in quokka/program.py 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 def get_instruction ( self , address : AddressT ) -> quokka . Instruction : \"\"\"Get an instruction by its address Note: the address must be the head of the instruction. TODO(dm): Improve the algorithm because the chunks are sorted (use bisect) Arguments: address: AddressT: Address to query Returns: A `quokka.Instruction` Raises: IndexError: When no instruction is found at this address \"\"\" for chunk in self . chunks . values (): if chunk . in_chunk ( address ): try : return chunk . get_instruction ( address ) except IndexError : pass raise IndexError ( f \"No instruction at address 0x { address : x } \" )","title":"get_instruction()"},{"location":"reference/python/program/#quokka.program.Program.get_segment","text":"Get a Segment by an address The address must be in [segment.start, segment.end) to be found. Parameters: Name Type Description Default address AddressT Segment's address required Returns: Type Description quokka . Segment The corresponding Segment Raises: Type Description KeyError When the segment is not found Source code in quokka/program.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 def get_segment ( self , address : AddressT ) -> quokka . Segment : \"\"\"Get a `Segment` by an address The address must be in [segment.start, segment.end) to be found. Arguments: address: Segment's address Returns: The corresponding Segment Raises: KeyError: When the segment is not found \"\"\" for segment in self . segments : if segment . in_segment ( address ): return segment raise KeyError ( f \"No segment has been found for address 0x { address } \" )","title":"get_segment()"},{"location":"reference/python/program/#quokka.program.Program.hash","text":"Returns the hash value of the binary (either sha256 or MD5). Source code in quokka/program.py 167 168 169 170 @property def hash ( self ) -> str : \"\"\"Returns the hash value of the binary (either sha256 or MD5).\"\"\" return self . proto . meta . hash . hash_value","title":"hash()"},{"location":"reference/python/program/#quokka.program.Program.iter_chunk","text":"Iterate over all the chunks in the program. If a SuperChunk is found, it will split it and return individual chunks. By default, it iterates over all the chunks, even extern functions. Parameters: Name Type Description Default chunk_types Optional [ List [ FunctionType ]] Allow list of chunk types. By default, it retrieves every chunk. None Yields: Type Description Iterator [ quokka . Chunk ] All the chunks in the program. Source code in quokka/program.py 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 def iter_chunk ( self , chunk_types : Optional [ List [ FunctionType ]] = None ) -> Iterator [ quokka . Chunk ]: \"\"\"Iterate over all the chunks in the program. If a `SuperChunk` is found, it will split it and return individual chunks. By default, it iterates over all the chunks, even extern functions. Arguments: chunk_types: Allow list of chunk types. By default, it retrieves every chunk. Yields: All the chunks in the program. \"\"\" if chunk_types is None : chunk_types = list ( FunctionType ) chunk : quokka . Chunk for chunk in self . chunks . values (): if isinstance ( chunk , quokka . SuperChunk ): inner_chunk : quokka . Chunk for inner_chunk in chunk . values (): if inner_chunk . chunk_type in chunk_types : yield inner_chunk else : if chunk . chunk_type in chunk_types : yield chunk","title":"iter_chunk()"},{"location":"reference/python/program/#quokka.program.Program.name","text":"Returns the underlying binary name Source code in quokka/program.py 162 163 164 165 @property def name ( self ) -> str : \"\"\"Returns the underlying binary name\"\"\" return self . proto . meta . executable_name","title":"name()"},{"location":"reference/python/program/#quokka.program.Program.pypcode","text":"Generate the Pypcode context. Source code in quokka/program.py 200 201 202 203 @cached_property def pypcode ( self ) -> pypcode . Context : \"\"\"Generate the Pypcode context.\"\"\" return quokka . backends . get_pypcode_context ( self . arch )","title":"pypcode()"},{"location":"reference/python/program/#quokka.program.Program.segments","text":"Returns the list of segments defined in the program. Source code in quokka/program.py 232 233 234 235 @cached_property def segments ( self ) -> List [ quokka . Segment ]: \"\"\"Returns the list of segments defined in the program.\"\"\" return [ quokka . Segment ( segment , self ) for segment in self . proto . segments ]","title":"segments()"},{"location":"reference/python/program/#quokka.program.Program.strings","text":"Program strings Retrieves all the strings used in the program. Returns: Type Description Iterable [ str ] A list of strings. Source code in quokka/program.py 220 221 222 223 224 225 226 227 228 229 230 @property def strings ( self ) -> Iterable [ str ]: \"\"\"Program strings Retrieves all the strings used in the program. Returns: A list of strings. \"\"\" # Do not use the empty string (the first one) return self . proto . string_table [ 1 :]","title":"strings()"},{"location":"reference/python/program/#quokka.program.Program.structures","text":"Structures accessor Allows to retrieve the different structures of a program (as defined by the disassembler). Returns: Type Description List [ quokka . Structure ] A list of structures Source code in quokka/program.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 @cached_property def structures ( self ) -> List [ quokka . Structure ]: \"\"\"Structures accessor Allows to retrieve the different structures of a program (as defined by the disassembler). Returns: A list of structures \"\"\" structures = [ quokka . Structure ( structure , self ) for structure in self . proto . structs ] return structures","title":"structures()"},{"location":"reference/python/reference/","text":"References Management This module deals with all references between different objects in the code. A reference is an object with the following attributes A Source A Destination A Type As they are stored in a complex manner, this module deals with their resolution, i.e. how to resolve the pointed object. There is room for improvement here. ;) Reference Reference: a link between a source and a destination Parameters: Name Type Description Default source ReferenceTarget Source of the reference required destination ReferenceTarget Destination (target) of the reference required type_ ReferenceType Type of the reference required Attributes: Name Type Description source ReferenceTarget Source of the reference destination ReferenceTarget Destination (target) of the reference type ReferenceType Type of the reference Source code in quokka/reference.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class Reference : \"\"\"Reference: a link between a source and a destination Arguments: source: Source of the reference destination: Destination (target) of the reference type_: Type of the reference Attributes: source: Source of the reference destination: Destination (target) of the reference type: Type of the reference \"\"\" def __init__ ( self , source : ReferenceTarget , destination : ReferenceTarget , type_ : ReferenceType , ) -> None : \"\"\"Constructor\"\"\" self . source : ReferenceTarget = source self . destination : ReferenceTarget = destination self . type : ReferenceType = type_ __init__ ( source , destination , type_ ) Constructor Source code in quokka/reference.py 66 67 68 69 70 71 72 73 74 75 def __init__ ( self , source : ReferenceTarget , destination : ReferenceTarget , type_ : ReferenceType , ) -> None : \"\"\"Constructor\"\"\" self . source : ReferenceTarget = source self . destination : ReferenceTarget = destination self . type : ReferenceType = type_ References Bases: Mapping References bucket : maintain the list of all references inside the program The instantiation of the class will create a mapping for every reference but not resolve them yet. This class is probably the most messy one in Quokka and needs a global refactoring. However, since it's somehow working, let's try to not break it yet. Parameters: Name Type Description Default program quokka . Program Reference to the program required Attributes: Name Type Description program quokka . Program Reference to the program proto_ref Protobuf data references_category Dict [ ReferencesLocation , DefaultDict ] A mapping that contains every reference for each direction. For instance, a ref X from inst a to struct b will be stored in both the structure key and the instruction key Source code in quokka/reference.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 class References ( Mapping ): \"\"\"References bucket : maintain the list of all references inside the program The instantiation of the class will create a mapping for every reference but not resolve them yet. This class is probably the most messy one in Quokka and needs a global refactoring. However, since it's somehow working, let's try to not break it yet. Arguments: program: Reference to the program Attributes: program: Reference to the program proto_ref: Protobuf data references_category: A mapping that contains every reference for each direction. For instance, a ref X from inst a to struct b will be stored in both the structure key and the instruction key \"\"\" SOURCE = \"source\" DESTINATION = \"destination\" def __init__ ( self , program : quokka . Program ) -> None : \"\"\"Init method Arguments: program: A backref to program \"\"\" # Define the update method def update ( mapping : Mapping , # type: ignore key : Union [ Tuple [ int ], LocationValueType ], value : Index , ) -> None : \"\"\"Recursive method to update the `self.references_category` mapping\"\"\" if isinstance ( key , int ): mapping [ key ] . append ( value ) return current_key : int = key [ 0 ] sub_key : Union [ Tuple [()], Tuple [ int ], Tuple [ int , int ]] = key [ 1 :] if sub_key : update ( mapping [ current_key ], sub_key , value ) elif not isinstance ( mapping . get ( current_key ), MutableMapping ): mapping [ current_key ] . append ( value ) self . program : quokka . Program = program self . proto_ref = program . proto . references # Init the references mapping self . references_category : Dict [ ReferencesLocation , DefaultDict ] = { # type: ignore ReferencesLocation . INSTRUCTION : collections . defaultdict ( list ), ReferencesLocation . DATA : collections . defaultdict ( list ), ReferencesLocation . STRUCTURE : collections . defaultdict ( lambda : collections . defaultdict ( list ) ), ReferencesLocation . INST_INSTANCE : collections . defaultdict ( lambda : collections . defaultdict ( lambda : collections . defaultdict ( list )) ), ReferencesLocation . FUNCTION : collections . defaultdict ( list ), ReferencesLocation . CHUNK : collections . defaultdict ( list ), } reference : quokka . pb . Quokka . Reference for index , reference in enumerate ( self . proto_ref ): source_ref = self . references_category [ self . location_type ( reference . source )] update ( source_ref , self . get_location_value ( reference . source ), index ) destination_ref = self . references_category [ self . location_type ( reference . destination ) ] update ( destination_ref , self . get_location_value ( reference . destination ), index ) @staticmethod def location_type ( location : quokka . pb . Quokka . Location , ) -> ReferencesLocation : \"\"\"Convert the proto location type\"\"\" return ReferencesLocation . from_proto ( location . WhichOneof ( \"LocationType\" )) def get_location_value ( self , location : quokka . pb . Quokka . Location ) -> LocationValueType : \"\"\"Resolve a location This method resolves a location for quokka. Arguments: location: Reference location Returns: A LocationTypeValue \"\"\" location_type : ReferencesLocation = self . location_type ( location ) location_value : LocationValueType = getattr ( location , location_type . value ) if location_type in ( ReferencesLocation . INSTRUCTION , ReferencesLocation . DATA , ReferencesLocation . FUNCTION , ReferencesLocation . CHUNK , ): return location_value elif location_type == ReferencesLocation . STRUCTURE : structure_idx : int = getattr ( location_value , \"structure_idx\" ) if getattr ( location_value , \"no_member\" ) is False : return structure_idx , getattr ( location_value , \"member_idx\" ) return structure_idx , - 1 elif location_type == ReferencesLocation . INST_INSTANCE : return ( getattr ( location_value , \"func_chunk_idx\" ), getattr ( location_value , \"block_idx\" ), getattr ( location_value , \"instruction_idx\" ), ) raise ValueError def __getitem__ ( self , k : Index ) -> Reference : \"\"\"Lazy loading for references\"\"\" return self . create_reference ( self . proto_ref [ k ]) def __len__ ( self ) -> int : \"\"\"References count\"\"\" return len ( self . proto_ref ) def __iter__ ( self ) -> Iterator [ Dict [ AddressT , Reference ]]: \"\"\"Iterator over references\"\"\" raise NotImplementedError @property def structures ( self ) -> List [ quokka . Structure ]: \"\"\"Accessor to the program structures\"\"\" return self . program . structures @property def data ( self ): \"\"\"Accessor to the program PROTO data\"\"\" return self . program . proto . data @property def instructions ( self ): \"\"\"Accessor to the program proto instruction\"\"\" return self . program . proto . instructions def create_reference ( self , reference : quokka . pb . Quokka . Reference ) -> \"Reference\" : \"\"\"Create a reference Start with resolving both the source and the destination. Arguments: reference: A protobuf reference object Returns: A python reference with both source and destination resolved \"\"\" source : ReferenceTarget = self . resolve_location ( reference . source ) destination : ReferenceTarget = self . resolve_location ( reference . destination ) return Reference ( source , destination , ReferenceType . from_proto ( reference . reference_type ) ) def find_instruction ( self , instruction_identifier : \"quokka.pb.Quokka.Location.InstructionIdentifier\" , ) -> Tuple [ quokka . Chunk , quokka . Block , Index ]: \"\"\"Search an instruction from an instruction identifier. The parameters are a chunk index, a block index, and an inst index inside the block. Arguments: instruction_identifier: Protobuf instruction identifier Returns: A instruction tuple (Chunk, Block, Instruction Index) \"\"\" chunk = self . program . get_chunk ( instruction_identifier . func_chunk_idx , instruction_identifier . block_idx ) block = chunk [ chunk . index_to_address [ instruction_identifier . block_idx ]] return chunk , block , instruction_identifier . instruction_idx def resolve_location ( self , location : quokka . pb . Quokka . Location ) -> ReferenceTarget : \"\"\"Resolve a location This convert a proto location to the actual instance of the object. Arguments: location: A protobuf Location (sigh) object Returns: A ReferenceTarget Raises: ValueError: When no appropriate location has been found. \"\"\" location_type : ReferencesLocation = self . location_type ( location ) if location_type == ReferencesLocation . INSTRUCTION : raise DeprecationWarning ( \"Not used anymore\" ) elif location_type == ReferencesLocation . DATA : return self . program . data_holder [ location . data_idx ] elif location_type == ReferencesLocation . STRUCTURE : structure : quokka . Structure = self . structures [ location . struct_position . structure_idx ] if location . struct_position . no_member is False : return structure [ structure . index_to_offset [ location . struct_position . member_idx ] ] return structure elif location_type == ReferencesLocation . INST_INSTANCE : return self . find_instruction ( location . instruction_position ) elif location_type == ReferencesLocation . CHUNK : return self . program . chunks [ location . chunk_idx ] raise ValueError ( \"No location found\" ) @staticmethod def get_direction ( towards : bool = True ) -> Tuple [ str , str ]: \"\"\"Helper method to analyze if we take the reference or unwind it\"\"\" target = \"destination\" if towards else \"source\" wanted = \"destination\" if not towards else \"source\" return target , wanted def resolve_block_references ( self , chunk_index : Index , block_index : Index , reference_type : ReferenceType , towards : bool = True , ) -> List [ Reference ]: \"\"\"Return a list of references from/towards a block. Arguments: chunk_index: Index of the chunk block_index: Index of the block reference_type: TYpe of reference wanted (e.g. Data) towards: True if we want the reference *to* this block. False if we want the references *from* the block. Returns: A List of references matching the criteria \"\"\" target , _ = self . get_direction ( towards ) return_list = [] for reference_ids in self . references_category [ ReferencesLocation . INST_INSTANCE ][ chunk_index ][ block_index ] . values (): for reference_id in reference_ids : reference : Reference = self [ reference_id ] if reference . type == reference_type and isinstance ( getattr ( reference , target ), tuple ): target_loc = getattr ( reference , target ) if ( target_loc [ 0 ] . proto_index , target_loc [ 1 ] . proto_index ) == ( chunk_index , block_index , ): return_list . append ( reference ) return return_list def resolve_inst_instance ( self , inst_tuple : Tuple [ int , int , int ], reference_type : Optional [ ReferenceType ] = None , towards : bool = True , ) -> List [ Reference ]: \"\"\"Resolve instruction references Return a list of references from/towards an instruction. If a reference_type is specified the references will be filtered by their type Arguments: inst_tuple: A tuple (Chunk Index, Block Index, Instruction Index) reference_type: Reference type to consider (filter result) towards: In which sense to search the reference? Returns: A list of reference matching the criteria \"\"\" return_list = [] target , _ = self . get_direction ( towards ) for reference_idx in self . references_category [ ReferencesLocation . INST_INSTANCE ][ inst_tuple [ 0 ] ][ inst_tuple [ 1 ]][ inst_tuple [ 2 ]]: reference : \"Reference\" = self [ reference_idx ] if ( not reference_type or reference . type == reference_type ) and isinstance ( getattr ( reference , target ), tuple ): target_loc = getattr ( reference , target ) if ( target_loc [ 0 ] . proto_index , target_loc [ 1 ] . proto_index , target_loc [ 2 ], ) == inst_tuple : return_list . append ( reference ) return return_list def resolve_calls ( self , chunk : quokka . Chunk , towards : bool = True ) -> List [ Union [ Tuple [ quokka . Chunk , quokka . Block , int ], quokka . Chunk ]]: \"\"\"Resolve calls to a chunk This method resolves calls initiated or received from every instruction in a chunk. Of note, a call must be from an Instruction Tuple to another. Arguments: chunk: Target chunk towards: Do we look at calls towards this chunk {X,Y,Z} -> Chunk or at calls from this chunk Chunk -> {X,Y,Z} ? Returns: A list of objects that are either tuple (Chunk, Block, Instruction Index) or Chunk (only for fake chunks that are created from an imported function) \"\"\" return_list = [] target , wanted = self . get_direction ( towards ) for block_index in self . references_category [ ReferencesLocation . INST_INSTANCE ][ chunk . proto_index ]: # For super-chunks, filter out block that do not belong to this chunk # anymore if block_index not in chunk . index_to_address : continue block_references = self . references_category [ ReferencesLocation . INST_INSTANCE ][ chunk . proto_index ][ block_index ] for references in block_references . values (): for reference_idx in references : reference : \"Reference\" = self [ reference_idx ] if reference . type == ReferenceType . CALL and isinstance ( getattr ( reference , target ), tuple ): target_loc = getattr ( reference , target ) if target_loc [ 0 ] . proto_index == chunk . proto_index : location = getattr ( reference , wanted ) # Fix: Only returns valid tuple # TODO(dm): check why sometimes a Data might be returned if isinstance ( location , ( tuple , quokka . Chunk )): return_list . append ( location ) return return_list def resolve_data ( self , data_index : Index , reference_type : Union [ ReferenceType , None ] = None , ) -> List [ Reference ]: \"\"\"Resolve data references Returns a list of reference towards a data If a reference_type is specified the references will be filtered by their type Arguments: data_index: Index of the data in the protobuf reference_type: Type of reference Returns: A list of reference matching the criteria \"\"\" references : List [ Reference ] = [] for reference_idx in self . references_category [ ReferencesLocation . DATA ][ data_index ]: reference = self [ reference_idx ] if reference_type is not None and reference_type != reference . type : continue references . append ( reference ) return references __getitem__ ( k ) Lazy loading for references Source code in quokka/reference.py 243 244 245 def __getitem__ ( self , k : Index ) -> Reference : \"\"\"Lazy loading for references\"\"\" return self . create_reference ( self . proto_ref [ k ]) __init__ ( program ) Init method Parameters: Name Type Description Default program quokka . Program A backref to program required Source code in quokka/reference.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 def __init__ ( self , program : quokka . Program ) -> None : \"\"\"Init method Arguments: program: A backref to program \"\"\" # Define the update method def update ( mapping : Mapping , # type: ignore key : Union [ Tuple [ int ], LocationValueType ], value : Index , ) -> None : \"\"\"Recursive method to update the `self.references_category` mapping\"\"\" if isinstance ( key , int ): mapping [ key ] . append ( value ) return current_key : int = key [ 0 ] sub_key : Union [ Tuple [()], Tuple [ int ], Tuple [ int , int ]] = key [ 1 :] if sub_key : update ( mapping [ current_key ], sub_key , value ) elif not isinstance ( mapping . get ( current_key ), MutableMapping ): mapping [ current_key ] . append ( value ) self . program : quokka . Program = program self . proto_ref = program . proto . references # Init the references mapping self . references_category : Dict [ ReferencesLocation , DefaultDict ] = { # type: ignore ReferencesLocation . INSTRUCTION : collections . defaultdict ( list ), ReferencesLocation . DATA : collections . defaultdict ( list ), ReferencesLocation . STRUCTURE : collections . defaultdict ( lambda : collections . defaultdict ( list ) ), ReferencesLocation . INST_INSTANCE : collections . defaultdict ( lambda : collections . defaultdict ( lambda : collections . defaultdict ( list )) ), ReferencesLocation . FUNCTION : collections . defaultdict ( list ), ReferencesLocation . CHUNK : collections . defaultdict ( list ), } reference : quokka . pb . Quokka . Reference for index , reference in enumerate ( self . proto_ref ): source_ref = self . references_category [ self . location_type ( reference . source )] update ( source_ref , self . get_location_value ( reference . source ), index ) destination_ref = self . references_category [ self . location_type ( reference . destination ) ] update ( destination_ref , self . get_location_value ( reference . destination ), index ) __iter__ () Iterator over references Source code in quokka/reference.py 251 252 253 def __iter__ ( self ) -> Iterator [ Dict [ AddressT , Reference ]]: \"\"\"Iterator over references\"\"\" raise NotImplementedError __len__ () References count Source code in quokka/reference.py 247 248 249 def __len__ ( self ) -> int : \"\"\"References count\"\"\" return len ( self . proto_ref ) create_reference ( reference ) Create a reference Start with resolving both the source and the destination. Parameters: Name Type Description Default reference quokka . pb . Quokka . Reference A protobuf reference object required Returns: Type Description Reference A python reference with both source and destination resolved Source code in quokka/reference.py 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 def create_reference ( self , reference : quokka . pb . Quokka . Reference ) -> \"Reference\" : \"\"\"Create a reference Start with resolving both the source and the destination. Arguments: reference: A protobuf reference object Returns: A python reference with both source and destination resolved \"\"\" source : ReferenceTarget = self . resolve_location ( reference . source ) destination : ReferenceTarget = self . resolve_location ( reference . destination ) return Reference ( source , destination , ReferenceType . from_proto ( reference . reference_type ) ) data () property Accessor to the program PROTO data Source code in quokka/reference.py 260 261 262 263 @property def data ( self ): \"\"\"Accessor to the program PROTO data\"\"\" return self . program . proto . data find_instruction ( instruction_identifier ) Search an instruction from an instruction identifier. The parameters are a chunk index, a block index, and an inst index inside the block. Parameters: Name Type Description Default instruction_identifier InstructionIdentifier Protobuf instruction identifier required Returns: Type Description Tuple [ quokka . Chunk , quokka . Block , Index ] A instruction tuple (Chunk, Block, Instruction Index) Source code in quokka/reference.py 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 def find_instruction ( self , instruction_identifier : \"quokka.pb.Quokka.Location.InstructionIdentifier\" , ) -> Tuple [ quokka . Chunk , quokka . Block , Index ]: \"\"\"Search an instruction from an instruction identifier. The parameters are a chunk index, a block index, and an inst index inside the block. Arguments: instruction_identifier: Protobuf instruction identifier Returns: A instruction tuple (Chunk, Block, Instruction Index) \"\"\" chunk = self . program . get_chunk ( instruction_identifier . func_chunk_idx , instruction_identifier . block_idx ) block = chunk [ chunk . index_to_address [ instruction_identifier . block_idx ]] return chunk , block , instruction_identifier . instruction_idx get_direction ( towards = True ) staticmethod Helper method to analyze if we take the reference or unwind it Source code in quokka/reference.py 348 349 350 351 352 353 354 @staticmethod def get_direction ( towards : bool = True ) -> Tuple [ str , str ]: \"\"\"Helper method to analyze if we take the reference or unwind it\"\"\" target = \"destination\" if towards else \"source\" wanted = \"destination\" if not towards else \"source\" return target , wanted get_location_value ( location ) Resolve a location This method resolves a location for quokka. Parameters: Name Type Description Default location quokka . pb . Quokka . Location Reference location required Returns: Type Description LocationValueType A LocationTypeValue Source code in quokka/reference.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def get_location_value ( self , location : quokka . pb . Quokka . Location ) -> LocationValueType : \"\"\"Resolve a location This method resolves a location for quokka. Arguments: location: Reference location Returns: A LocationTypeValue \"\"\" location_type : ReferencesLocation = self . location_type ( location ) location_value : LocationValueType = getattr ( location , location_type . value ) if location_type in ( ReferencesLocation . INSTRUCTION , ReferencesLocation . DATA , ReferencesLocation . FUNCTION , ReferencesLocation . CHUNK , ): return location_value elif location_type == ReferencesLocation . STRUCTURE : structure_idx : int = getattr ( location_value , \"structure_idx\" ) if getattr ( location_value , \"no_member\" ) is False : return structure_idx , getattr ( location_value , \"member_idx\" ) return structure_idx , - 1 elif location_type == ReferencesLocation . INST_INSTANCE : return ( getattr ( location_value , \"func_chunk_idx\" ), getattr ( location_value , \"block_idx\" ), getattr ( location_value , \"instruction_idx\" ), ) raise ValueError instructions () property Accessor to the program proto instruction Source code in quokka/reference.py 265 266 267 268 @property def instructions ( self ): \"\"\"Accessor to the program proto instruction\"\"\" return self . program . proto . instructions location_type ( location ) staticmethod Convert the proto location type Source code in quokka/reference.py 195 196 197 198 199 200 @staticmethod def location_type ( location : quokka . pb . Quokka . Location , ) -> ReferencesLocation : \"\"\"Convert the proto location type\"\"\" return ReferencesLocation . from_proto ( location . WhichOneof ( \"LocationType\" )) resolve_block_references ( chunk_index , block_index , reference_type , towards = True ) Return a list of references from/towards a block. Parameters: Name Type Description Default chunk_index Index Index of the chunk required block_index Index Index of the block required reference_type ReferenceType TYpe of reference wanted (e.g. Data) required towards bool True if we want the reference to this block. False if we want the references from the block. True Returns: Type Description List [ Reference ] A List of references matching the criteria Source code in quokka/reference.py 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 def resolve_block_references ( self , chunk_index : Index , block_index : Index , reference_type : ReferenceType , towards : bool = True , ) -> List [ Reference ]: \"\"\"Return a list of references from/towards a block. Arguments: chunk_index: Index of the chunk block_index: Index of the block reference_type: TYpe of reference wanted (e.g. Data) towards: True if we want the reference *to* this block. False if we want the references *from* the block. Returns: A List of references matching the criteria \"\"\" target , _ = self . get_direction ( towards ) return_list = [] for reference_ids in self . references_category [ ReferencesLocation . INST_INSTANCE ][ chunk_index ][ block_index ] . values (): for reference_id in reference_ids : reference : Reference = self [ reference_id ] if reference . type == reference_type and isinstance ( getattr ( reference , target ), tuple ): target_loc = getattr ( reference , target ) if ( target_loc [ 0 ] . proto_index , target_loc [ 1 ] . proto_index ) == ( chunk_index , block_index , ): return_list . append ( reference ) return return_list resolve_calls ( chunk , towards = True ) Resolve calls to a chunk This method resolves calls initiated or received from every instruction in a chunk. Of note, a call must be from an Instruction Tuple to another. Parameters: Name Type Description Default chunk quokka . Chunk Target chunk required towards bool Do we look at calls towards this chunk {X,Y,Z} -> Chunk or at calls from this chunk Chunk -> {X,Y,Z} ? True Returns: Type Description List [ Union [ Tuple [ quokka . Chunk , quokka . Block , int ], quokka . Chunk ]] A list of objects that are either tuple (Chunk, Block, Instruction Index) or List [ Union [ Tuple [ quokka . Chunk , quokka . Block , int ], quokka . Chunk ]] Chunk (only for fake chunks that are created from an imported function) Source code in quokka/reference.py 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 def resolve_calls ( self , chunk : quokka . Chunk , towards : bool = True ) -> List [ Union [ Tuple [ quokka . Chunk , quokka . Block , int ], quokka . Chunk ]]: \"\"\"Resolve calls to a chunk This method resolves calls initiated or received from every instruction in a chunk. Of note, a call must be from an Instruction Tuple to another. Arguments: chunk: Target chunk towards: Do we look at calls towards this chunk {X,Y,Z} -> Chunk or at calls from this chunk Chunk -> {X,Y,Z} ? Returns: A list of objects that are either tuple (Chunk, Block, Instruction Index) or Chunk (only for fake chunks that are created from an imported function) \"\"\" return_list = [] target , wanted = self . get_direction ( towards ) for block_index in self . references_category [ ReferencesLocation . INST_INSTANCE ][ chunk . proto_index ]: # For super-chunks, filter out block that do not belong to this chunk # anymore if block_index not in chunk . index_to_address : continue block_references = self . references_category [ ReferencesLocation . INST_INSTANCE ][ chunk . proto_index ][ block_index ] for references in block_references . values (): for reference_idx in references : reference : \"Reference\" = self [ reference_idx ] if reference . type == ReferenceType . CALL and isinstance ( getattr ( reference , target ), tuple ): target_loc = getattr ( reference , target ) if target_loc [ 0 ] . proto_index == chunk . proto_index : location = getattr ( reference , wanted ) # Fix: Only returns valid tuple # TODO(dm): check why sometimes a Data might be returned if isinstance ( location , ( tuple , quokka . Chunk )): return_list . append ( location ) return return_list resolve_data ( data_index , reference_type = None ) Resolve data references Returns a list of reference towards a data If a reference_type is specified the references will be filtered by their type Parameters: Name Type Description Default data_index Index Index of the data in the protobuf required reference_type Union [ ReferenceType , None] Type of reference None Returns: Type Description List [ Reference ] A list of reference matching the criteria Source code in quokka/reference.py 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 def resolve_data ( self , data_index : Index , reference_type : Union [ ReferenceType , None ] = None , ) -> List [ Reference ]: \"\"\"Resolve data references Returns a list of reference towards a data If a reference_type is specified the references will be filtered by their type Arguments: data_index: Index of the data in the protobuf reference_type: Type of reference Returns: A list of reference matching the criteria \"\"\" references : List [ Reference ] = [] for reference_idx in self . references_category [ ReferencesLocation . DATA ][ data_index ]: reference = self [ reference_idx ] if reference_type is not None and reference_type != reference . type : continue references . append ( reference ) return references resolve_inst_instance ( inst_tuple , reference_type = None , towards = True ) Resolve instruction references Return a list of references from/towards an instruction. If a reference_type is specified the references will be filtered by their type Parameters: Name Type Description Default inst_tuple Tuple [ int , int , int ] A tuple (Chunk Index, Block Index, Instruction Index) required reference_type Optional [ ReferenceType ] Reference type to consider (filter result) None towards bool In which sense to search the reference? True Returns: Type Description List [ Reference ] A list of reference matching the criteria Source code in quokka/reference.py 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 def resolve_inst_instance ( self , inst_tuple : Tuple [ int , int , int ], reference_type : Optional [ ReferenceType ] = None , towards : bool = True , ) -> List [ Reference ]: \"\"\"Resolve instruction references Return a list of references from/towards an instruction. If a reference_type is specified the references will be filtered by their type Arguments: inst_tuple: A tuple (Chunk Index, Block Index, Instruction Index) reference_type: Reference type to consider (filter result) towards: In which sense to search the reference? Returns: A list of reference matching the criteria \"\"\" return_list = [] target , _ = self . get_direction ( towards ) for reference_idx in self . references_category [ ReferencesLocation . INST_INSTANCE ][ inst_tuple [ 0 ] ][ inst_tuple [ 1 ]][ inst_tuple [ 2 ]]: reference : \"Reference\" = self [ reference_idx ] if ( not reference_type or reference . type == reference_type ) and isinstance ( getattr ( reference , target ), tuple ): target_loc = getattr ( reference , target ) if ( target_loc [ 0 ] . proto_index , target_loc [ 1 ] . proto_index , target_loc [ 2 ], ) == inst_tuple : return_list . append ( reference ) return return_list resolve_location ( location ) Resolve a location This convert a proto location to the actual instance of the object. Parameters: Name Type Description Default location quokka . pb . Quokka . Location A protobuf Location (sigh) object required Returns: Type Description ReferenceTarget A ReferenceTarget Raises: Type Description ValueError When no appropriate location has been found. Source code in quokka/reference.py 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def resolve_location ( self , location : quokka . pb . Quokka . Location ) -> ReferenceTarget : \"\"\"Resolve a location This convert a proto location to the actual instance of the object. Arguments: location: A protobuf Location (sigh) object Returns: A ReferenceTarget Raises: ValueError: When no appropriate location has been found. \"\"\" location_type : ReferencesLocation = self . location_type ( location ) if location_type == ReferencesLocation . INSTRUCTION : raise DeprecationWarning ( \"Not used anymore\" ) elif location_type == ReferencesLocation . DATA : return self . program . data_holder [ location . data_idx ] elif location_type == ReferencesLocation . STRUCTURE : structure : quokka . Structure = self . structures [ location . struct_position . structure_idx ] if location . struct_position . no_member is False : return structure [ structure . index_to_offset [ location . struct_position . member_idx ] ] return structure elif location_type == ReferencesLocation . INST_INSTANCE : return self . find_instruction ( location . instruction_position ) elif location_type == ReferencesLocation . CHUNK : return self . program . chunks [ location . chunk_idx ] raise ValueError ( \"No location found\" ) structures () property Accessor to the program structures Source code in quokka/reference.py 255 256 257 258 @property def structures ( self ) -> List [ quokka . Structure ]: \"\"\"Accessor to the program structures\"\"\" return self . program . structures ReferencesLocation Bases: enum . Enum Reference location A reference may be attached to one of the following an instruction index (that means every instance of the instruction) a data index a structure position (e.g. a structure or a member inside a structure) an instruction : a tuple with (chunk, block, inst_index) identifying precisely one instruction a function a chunk Source code in quokka/reference.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 class ReferencesLocation ( enum . Enum ): \"\"\"Reference location A reference may be attached to one of the following : * an instruction index (that means every instance of the instruction) * a data index * a structure position (e.g. a structure or a member inside a structure) * an instruction : a tuple with (chunk, block, inst_index) identifying precisely one instruction * a function * a chunk \"\"\" INSTRUCTION = \"inst_idx\" DATA = \"data_idx\" STRUCTURE = \"struct_position\" INST_INSTANCE = \"instruction_position\" FUNCTION = \"function_idx\" CHUNK = \"chunk_idx\" @staticmethod def from_proto ( location_type : str ) -> ReferencesLocation : \"\"\"Convert reference location from proto\"\"\" # These are the name of the fields in the protobuf mapping = { \"inst_idx\" : ReferencesLocation . INSTRUCTION , \"data_idx\" : ReferencesLocation . DATA , \"struct_position\" : ReferencesLocation . STRUCTURE , \"instruction_position\" : ReferencesLocation . INST_INSTANCE , \"function_idx\" : ReferencesLocation . FUNCTION , \"chunk_idx\" : ReferencesLocation . CHUNK , } try : return mapping [ location_type ] except IndexError as exc : raise ValueError ( \"Unknown location type\" ) from exc from_proto ( location_type ) staticmethod Convert reference location from proto Source code in quokka/reference.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @staticmethod def from_proto ( location_type : str ) -> ReferencesLocation : \"\"\"Convert reference location from proto\"\"\" # These are the name of the fields in the protobuf mapping = { \"inst_idx\" : ReferencesLocation . INSTRUCTION , \"data_idx\" : ReferencesLocation . DATA , \"struct_position\" : ReferencesLocation . STRUCTURE , \"instruction_position\" : ReferencesLocation . INST_INSTANCE , \"function_idx\" : ReferencesLocation . FUNCTION , \"chunk_idx\" : ReferencesLocation . CHUNK , } try : return mapping [ location_type ] except IndexError as exc : raise ValueError ( \"Unknown location type\" ) from exc","title":"reference"},{"location":"reference/python/reference/#quokka.reference.Reference","text":"Reference: a link between a source and a destination Parameters: Name Type Description Default source ReferenceTarget Source of the reference required destination ReferenceTarget Destination (target) of the reference required type_ ReferenceType Type of the reference required Attributes: Name Type Description source ReferenceTarget Source of the reference destination ReferenceTarget Destination (target) of the reference type ReferenceType Type of the reference Source code in quokka/reference.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class Reference : \"\"\"Reference: a link between a source and a destination Arguments: source: Source of the reference destination: Destination (target) of the reference type_: Type of the reference Attributes: source: Source of the reference destination: Destination (target) of the reference type: Type of the reference \"\"\" def __init__ ( self , source : ReferenceTarget , destination : ReferenceTarget , type_ : ReferenceType , ) -> None : \"\"\"Constructor\"\"\" self . source : ReferenceTarget = source self . destination : ReferenceTarget = destination self . type : ReferenceType = type_","title":"Reference"},{"location":"reference/python/reference/#quokka.reference.Reference.__init__","text":"Constructor Source code in quokka/reference.py 66 67 68 69 70 71 72 73 74 75 def __init__ ( self , source : ReferenceTarget , destination : ReferenceTarget , type_ : ReferenceType , ) -> None : \"\"\"Constructor\"\"\" self . source : ReferenceTarget = source self . destination : ReferenceTarget = destination self . type : ReferenceType = type_","title":"__init__()"},{"location":"reference/python/reference/#quokka.reference.References","text":"Bases: Mapping References bucket : maintain the list of all references inside the program The instantiation of the class will create a mapping for every reference but not resolve them yet. This class is probably the most messy one in Quokka and needs a global refactoring. However, since it's somehow working, let's try to not break it yet. Parameters: Name Type Description Default program quokka . Program Reference to the program required Attributes: Name Type Description program quokka . Program Reference to the program proto_ref Protobuf data references_category Dict [ ReferencesLocation , DefaultDict ] A mapping that contains every reference for each direction. For instance, a ref X from inst a to struct b will be stored in both the structure key and the instruction key Source code in quokka/reference.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 class References ( Mapping ): \"\"\"References bucket : maintain the list of all references inside the program The instantiation of the class will create a mapping for every reference but not resolve them yet. This class is probably the most messy one in Quokka and needs a global refactoring. However, since it's somehow working, let's try to not break it yet. Arguments: program: Reference to the program Attributes: program: Reference to the program proto_ref: Protobuf data references_category: A mapping that contains every reference for each direction. For instance, a ref X from inst a to struct b will be stored in both the structure key and the instruction key \"\"\" SOURCE = \"source\" DESTINATION = \"destination\" def __init__ ( self , program : quokka . Program ) -> None : \"\"\"Init method Arguments: program: A backref to program \"\"\" # Define the update method def update ( mapping : Mapping , # type: ignore key : Union [ Tuple [ int ], LocationValueType ], value : Index , ) -> None : \"\"\"Recursive method to update the `self.references_category` mapping\"\"\" if isinstance ( key , int ): mapping [ key ] . append ( value ) return current_key : int = key [ 0 ] sub_key : Union [ Tuple [()], Tuple [ int ], Tuple [ int , int ]] = key [ 1 :] if sub_key : update ( mapping [ current_key ], sub_key , value ) elif not isinstance ( mapping . get ( current_key ), MutableMapping ): mapping [ current_key ] . append ( value ) self . program : quokka . Program = program self . proto_ref = program . proto . references # Init the references mapping self . references_category : Dict [ ReferencesLocation , DefaultDict ] = { # type: ignore ReferencesLocation . INSTRUCTION : collections . defaultdict ( list ), ReferencesLocation . DATA : collections . defaultdict ( list ), ReferencesLocation . STRUCTURE : collections . defaultdict ( lambda : collections . defaultdict ( list ) ), ReferencesLocation . INST_INSTANCE : collections . defaultdict ( lambda : collections . defaultdict ( lambda : collections . defaultdict ( list )) ), ReferencesLocation . FUNCTION : collections . defaultdict ( list ), ReferencesLocation . CHUNK : collections . defaultdict ( list ), } reference : quokka . pb . Quokka . Reference for index , reference in enumerate ( self . proto_ref ): source_ref = self . references_category [ self . location_type ( reference . source )] update ( source_ref , self . get_location_value ( reference . source ), index ) destination_ref = self . references_category [ self . location_type ( reference . destination ) ] update ( destination_ref , self . get_location_value ( reference . destination ), index ) @staticmethod def location_type ( location : quokka . pb . Quokka . Location , ) -> ReferencesLocation : \"\"\"Convert the proto location type\"\"\" return ReferencesLocation . from_proto ( location . WhichOneof ( \"LocationType\" )) def get_location_value ( self , location : quokka . pb . Quokka . Location ) -> LocationValueType : \"\"\"Resolve a location This method resolves a location for quokka. Arguments: location: Reference location Returns: A LocationTypeValue \"\"\" location_type : ReferencesLocation = self . location_type ( location ) location_value : LocationValueType = getattr ( location , location_type . value ) if location_type in ( ReferencesLocation . INSTRUCTION , ReferencesLocation . DATA , ReferencesLocation . FUNCTION , ReferencesLocation . CHUNK , ): return location_value elif location_type == ReferencesLocation . STRUCTURE : structure_idx : int = getattr ( location_value , \"structure_idx\" ) if getattr ( location_value , \"no_member\" ) is False : return structure_idx , getattr ( location_value , \"member_idx\" ) return structure_idx , - 1 elif location_type == ReferencesLocation . INST_INSTANCE : return ( getattr ( location_value , \"func_chunk_idx\" ), getattr ( location_value , \"block_idx\" ), getattr ( location_value , \"instruction_idx\" ), ) raise ValueError def __getitem__ ( self , k : Index ) -> Reference : \"\"\"Lazy loading for references\"\"\" return self . create_reference ( self . proto_ref [ k ]) def __len__ ( self ) -> int : \"\"\"References count\"\"\" return len ( self . proto_ref ) def __iter__ ( self ) -> Iterator [ Dict [ AddressT , Reference ]]: \"\"\"Iterator over references\"\"\" raise NotImplementedError @property def structures ( self ) -> List [ quokka . Structure ]: \"\"\"Accessor to the program structures\"\"\" return self . program . structures @property def data ( self ): \"\"\"Accessor to the program PROTO data\"\"\" return self . program . proto . data @property def instructions ( self ): \"\"\"Accessor to the program proto instruction\"\"\" return self . program . proto . instructions def create_reference ( self , reference : quokka . pb . Quokka . Reference ) -> \"Reference\" : \"\"\"Create a reference Start with resolving both the source and the destination. Arguments: reference: A protobuf reference object Returns: A python reference with both source and destination resolved \"\"\" source : ReferenceTarget = self . resolve_location ( reference . source ) destination : ReferenceTarget = self . resolve_location ( reference . destination ) return Reference ( source , destination , ReferenceType . from_proto ( reference . reference_type ) ) def find_instruction ( self , instruction_identifier : \"quokka.pb.Quokka.Location.InstructionIdentifier\" , ) -> Tuple [ quokka . Chunk , quokka . Block , Index ]: \"\"\"Search an instruction from an instruction identifier. The parameters are a chunk index, a block index, and an inst index inside the block. Arguments: instruction_identifier: Protobuf instruction identifier Returns: A instruction tuple (Chunk, Block, Instruction Index) \"\"\" chunk = self . program . get_chunk ( instruction_identifier . func_chunk_idx , instruction_identifier . block_idx ) block = chunk [ chunk . index_to_address [ instruction_identifier . block_idx ]] return chunk , block , instruction_identifier . instruction_idx def resolve_location ( self , location : quokka . pb . Quokka . Location ) -> ReferenceTarget : \"\"\"Resolve a location This convert a proto location to the actual instance of the object. Arguments: location: A protobuf Location (sigh) object Returns: A ReferenceTarget Raises: ValueError: When no appropriate location has been found. \"\"\" location_type : ReferencesLocation = self . location_type ( location ) if location_type == ReferencesLocation . INSTRUCTION : raise DeprecationWarning ( \"Not used anymore\" ) elif location_type == ReferencesLocation . DATA : return self . program . data_holder [ location . data_idx ] elif location_type == ReferencesLocation . STRUCTURE : structure : quokka . Structure = self . structures [ location . struct_position . structure_idx ] if location . struct_position . no_member is False : return structure [ structure . index_to_offset [ location . struct_position . member_idx ] ] return structure elif location_type == ReferencesLocation . INST_INSTANCE : return self . find_instruction ( location . instruction_position ) elif location_type == ReferencesLocation . CHUNK : return self . program . chunks [ location . chunk_idx ] raise ValueError ( \"No location found\" ) @staticmethod def get_direction ( towards : bool = True ) -> Tuple [ str , str ]: \"\"\"Helper method to analyze if we take the reference or unwind it\"\"\" target = \"destination\" if towards else \"source\" wanted = \"destination\" if not towards else \"source\" return target , wanted def resolve_block_references ( self , chunk_index : Index , block_index : Index , reference_type : ReferenceType , towards : bool = True , ) -> List [ Reference ]: \"\"\"Return a list of references from/towards a block. Arguments: chunk_index: Index of the chunk block_index: Index of the block reference_type: TYpe of reference wanted (e.g. Data) towards: True if we want the reference *to* this block. False if we want the references *from* the block. Returns: A List of references matching the criteria \"\"\" target , _ = self . get_direction ( towards ) return_list = [] for reference_ids in self . references_category [ ReferencesLocation . INST_INSTANCE ][ chunk_index ][ block_index ] . values (): for reference_id in reference_ids : reference : Reference = self [ reference_id ] if reference . type == reference_type and isinstance ( getattr ( reference , target ), tuple ): target_loc = getattr ( reference , target ) if ( target_loc [ 0 ] . proto_index , target_loc [ 1 ] . proto_index ) == ( chunk_index , block_index , ): return_list . append ( reference ) return return_list def resolve_inst_instance ( self , inst_tuple : Tuple [ int , int , int ], reference_type : Optional [ ReferenceType ] = None , towards : bool = True , ) -> List [ Reference ]: \"\"\"Resolve instruction references Return a list of references from/towards an instruction. If a reference_type is specified the references will be filtered by their type Arguments: inst_tuple: A tuple (Chunk Index, Block Index, Instruction Index) reference_type: Reference type to consider (filter result) towards: In which sense to search the reference? Returns: A list of reference matching the criteria \"\"\" return_list = [] target , _ = self . get_direction ( towards ) for reference_idx in self . references_category [ ReferencesLocation . INST_INSTANCE ][ inst_tuple [ 0 ] ][ inst_tuple [ 1 ]][ inst_tuple [ 2 ]]: reference : \"Reference\" = self [ reference_idx ] if ( not reference_type or reference . type == reference_type ) and isinstance ( getattr ( reference , target ), tuple ): target_loc = getattr ( reference , target ) if ( target_loc [ 0 ] . proto_index , target_loc [ 1 ] . proto_index , target_loc [ 2 ], ) == inst_tuple : return_list . append ( reference ) return return_list def resolve_calls ( self , chunk : quokka . Chunk , towards : bool = True ) -> List [ Union [ Tuple [ quokka . Chunk , quokka . Block , int ], quokka . Chunk ]]: \"\"\"Resolve calls to a chunk This method resolves calls initiated or received from every instruction in a chunk. Of note, a call must be from an Instruction Tuple to another. Arguments: chunk: Target chunk towards: Do we look at calls towards this chunk {X,Y,Z} -> Chunk or at calls from this chunk Chunk -> {X,Y,Z} ? Returns: A list of objects that are either tuple (Chunk, Block, Instruction Index) or Chunk (only for fake chunks that are created from an imported function) \"\"\" return_list = [] target , wanted = self . get_direction ( towards ) for block_index in self . references_category [ ReferencesLocation . INST_INSTANCE ][ chunk . proto_index ]: # For super-chunks, filter out block that do not belong to this chunk # anymore if block_index not in chunk . index_to_address : continue block_references = self . references_category [ ReferencesLocation . INST_INSTANCE ][ chunk . proto_index ][ block_index ] for references in block_references . values (): for reference_idx in references : reference : \"Reference\" = self [ reference_idx ] if reference . type == ReferenceType . CALL and isinstance ( getattr ( reference , target ), tuple ): target_loc = getattr ( reference , target ) if target_loc [ 0 ] . proto_index == chunk . proto_index : location = getattr ( reference , wanted ) # Fix: Only returns valid tuple # TODO(dm): check why sometimes a Data might be returned if isinstance ( location , ( tuple , quokka . Chunk )): return_list . append ( location ) return return_list def resolve_data ( self , data_index : Index , reference_type : Union [ ReferenceType , None ] = None , ) -> List [ Reference ]: \"\"\"Resolve data references Returns a list of reference towards a data If a reference_type is specified the references will be filtered by their type Arguments: data_index: Index of the data in the protobuf reference_type: Type of reference Returns: A list of reference matching the criteria \"\"\" references : List [ Reference ] = [] for reference_idx in self . references_category [ ReferencesLocation . DATA ][ data_index ]: reference = self [ reference_idx ] if reference_type is not None and reference_type != reference . type : continue references . append ( reference ) return references","title":"References"},{"location":"reference/python/reference/#quokka.reference.References.__getitem__","text":"Lazy loading for references Source code in quokka/reference.py 243 244 245 def __getitem__ ( self , k : Index ) -> Reference : \"\"\"Lazy loading for references\"\"\" return self . create_reference ( self . proto_ref [ k ])","title":"__getitem__()"},{"location":"reference/python/reference/#quokka.reference.References.__init__","text":"Init method Parameters: Name Type Description Default program quokka . Program A backref to program required Source code in quokka/reference.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 def __init__ ( self , program : quokka . Program ) -> None : \"\"\"Init method Arguments: program: A backref to program \"\"\" # Define the update method def update ( mapping : Mapping , # type: ignore key : Union [ Tuple [ int ], LocationValueType ], value : Index , ) -> None : \"\"\"Recursive method to update the `self.references_category` mapping\"\"\" if isinstance ( key , int ): mapping [ key ] . append ( value ) return current_key : int = key [ 0 ] sub_key : Union [ Tuple [()], Tuple [ int ], Tuple [ int , int ]] = key [ 1 :] if sub_key : update ( mapping [ current_key ], sub_key , value ) elif not isinstance ( mapping . get ( current_key ), MutableMapping ): mapping [ current_key ] . append ( value ) self . program : quokka . Program = program self . proto_ref = program . proto . references # Init the references mapping self . references_category : Dict [ ReferencesLocation , DefaultDict ] = { # type: ignore ReferencesLocation . INSTRUCTION : collections . defaultdict ( list ), ReferencesLocation . DATA : collections . defaultdict ( list ), ReferencesLocation . STRUCTURE : collections . defaultdict ( lambda : collections . defaultdict ( list ) ), ReferencesLocation . INST_INSTANCE : collections . defaultdict ( lambda : collections . defaultdict ( lambda : collections . defaultdict ( list )) ), ReferencesLocation . FUNCTION : collections . defaultdict ( list ), ReferencesLocation . CHUNK : collections . defaultdict ( list ), } reference : quokka . pb . Quokka . Reference for index , reference in enumerate ( self . proto_ref ): source_ref = self . references_category [ self . location_type ( reference . source )] update ( source_ref , self . get_location_value ( reference . source ), index ) destination_ref = self . references_category [ self . location_type ( reference . destination ) ] update ( destination_ref , self . get_location_value ( reference . destination ), index )","title":"__init__()"},{"location":"reference/python/reference/#quokka.reference.References.__iter__","text":"Iterator over references Source code in quokka/reference.py 251 252 253 def __iter__ ( self ) -> Iterator [ Dict [ AddressT , Reference ]]: \"\"\"Iterator over references\"\"\" raise NotImplementedError","title":"__iter__()"},{"location":"reference/python/reference/#quokka.reference.References.__len__","text":"References count Source code in quokka/reference.py 247 248 249 def __len__ ( self ) -> int : \"\"\"References count\"\"\" return len ( self . proto_ref )","title":"__len__()"},{"location":"reference/python/reference/#quokka.reference.References.create_reference","text":"Create a reference Start with resolving both the source and the destination. Parameters: Name Type Description Default reference quokka . pb . Quokka . Reference A protobuf reference object required Returns: Type Description Reference A python reference with both source and destination resolved Source code in quokka/reference.py 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 def create_reference ( self , reference : quokka . pb . Quokka . Reference ) -> \"Reference\" : \"\"\"Create a reference Start with resolving both the source and the destination. Arguments: reference: A protobuf reference object Returns: A python reference with both source and destination resolved \"\"\" source : ReferenceTarget = self . resolve_location ( reference . source ) destination : ReferenceTarget = self . resolve_location ( reference . destination ) return Reference ( source , destination , ReferenceType . from_proto ( reference . reference_type ) )","title":"create_reference()"},{"location":"reference/python/reference/#quokka.reference.References.data","text":"Accessor to the program PROTO data Source code in quokka/reference.py 260 261 262 263 @property def data ( self ): \"\"\"Accessor to the program PROTO data\"\"\" return self . program . proto . data","title":"data()"},{"location":"reference/python/reference/#quokka.reference.References.find_instruction","text":"Search an instruction from an instruction identifier. The parameters are a chunk index, a block index, and an inst index inside the block. Parameters: Name Type Description Default instruction_identifier InstructionIdentifier Protobuf instruction identifier required Returns: Type Description Tuple [ quokka . Chunk , quokka . Block , Index ] A instruction tuple (Chunk, Block, Instruction Index) Source code in quokka/reference.py 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 def find_instruction ( self , instruction_identifier : \"quokka.pb.Quokka.Location.InstructionIdentifier\" , ) -> Tuple [ quokka . Chunk , quokka . Block , Index ]: \"\"\"Search an instruction from an instruction identifier. The parameters are a chunk index, a block index, and an inst index inside the block. Arguments: instruction_identifier: Protobuf instruction identifier Returns: A instruction tuple (Chunk, Block, Instruction Index) \"\"\" chunk = self . program . get_chunk ( instruction_identifier . func_chunk_idx , instruction_identifier . block_idx ) block = chunk [ chunk . index_to_address [ instruction_identifier . block_idx ]] return chunk , block , instruction_identifier . instruction_idx","title":"find_instruction()"},{"location":"reference/python/reference/#quokka.reference.References.get_direction","text":"Helper method to analyze if we take the reference or unwind it Source code in quokka/reference.py 348 349 350 351 352 353 354 @staticmethod def get_direction ( towards : bool = True ) -> Tuple [ str , str ]: \"\"\"Helper method to analyze if we take the reference or unwind it\"\"\" target = \"destination\" if towards else \"source\" wanted = \"destination\" if not towards else \"source\" return target , wanted","title":"get_direction()"},{"location":"reference/python/reference/#quokka.reference.References.get_location_value","text":"Resolve a location This method resolves a location for quokka. Parameters: Name Type Description Default location quokka . pb . Quokka . Location Reference location required Returns: Type Description LocationValueType A LocationTypeValue Source code in quokka/reference.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def get_location_value ( self , location : quokka . pb . Quokka . Location ) -> LocationValueType : \"\"\"Resolve a location This method resolves a location for quokka. Arguments: location: Reference location Returns: A LocationTypeValue \"\"\" location_type : ReferencesLocation = self . location_type ( location ) location_value : LocationValueType = getattr ( location , location_type . value ) if location_type in ( ReferencesLocation . INSTRUCTION , ReferencesLocation . DATA , ReferencesLocation . FUNCTION , ReferencesLocation . CHUNK , ): return location_value elif location_type == ReferencesLocation . STRUCTURE : structure_idx : int = getattr ( location_value , \"structure_idx\" ) if getattr ( location_value , \"no_member\" ) is False : return structure_idx , getattr ( location_value , \"member_idx\" ) return structure_idx , - 1 elif location_type == ReferencesLocation . INST_INSTANCE : return ( getattr ( location_value , \"func_chunk_idx\" ), getattr ( location_value , \"block_idx\" ), getattr ( location_value , \"instruction_idx\" ), ) raise ValueError","title":"get_location_value()"},{"location":"reference/python/reference/#quokka.reference.References.instructions","text":"Accessor to the program proto instruction Source code in quokka/reference.py 265 266 267 268 @property def instructions ( self ): \"\"\"Accessor to the program proto instruction\"\"\" return self . program . proto . instructions","title":"instructions()"},{"location":"reference/python/reference/#quokka.reference.References.location_type","text":"Convert the proto location type Source code in quokka/reference.py 195 196 197 198 199 200 @staticmethod def location_type ( location : quokka . pb . Quokka . Location , ) -> ReferencesLocation : \"\"\"Convert the proto location type\"\"\" return ReferencesLocation . from_proto ( location . WhichOneof ( \"LocationType\" ))","title":"location_type()"},{"location":"reference/python/reference/#quokka.reference.References.resolve_block_references","text":"Return a list of references from/towards a block. Parameters: Name Type Description Default chunk_index Index Index of the chunk required block_index Index Index of the block required reference_type ReferenceType TYpe of reference wanted (e.g. Data) required towards bool True if we want the reference to this block. False if we want the references from the block. True Returns: Type Description List [ Reference ] A List of references matching the criteria Source code in quokka/reference.py 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 def resolve_block_references ( self , chunk_index : Index , block_index : Index , reference_type : ReferenceType , towards : bool = True , ) -> List [ Reference ]: \"\"\"Return a list of references from/towards a block. Arguments: chunk_index: Index of the chunk block_index: Index of the block reference_type: TYpe of reference wanted (e.g. Data) towards: True if we want the reference *to* this block. False if we want the references *from* the block. Returns: A List of references matching the criteria \"\"\" target , _ = self . get_direction ( towards ) return_list = [] for reference_ids in self . references_category [ ReferencesLocation . INST_INSTANCE ][ chunk_index ][ block_index ] . values (): for reference_id in reference_ids : reference : Reference = self [ reference_id ] if reference . type == reference_type and isinstance ( getattr ( reference , target ), tuple ): target_loc = getattr ( reference , target ) if ( target_loc [ 0 ] . proto_index , target_loc [ 1 ] . proto_index ) == ( chunk_index , block_index , ): return_list . append ( reference ) return return_list","title":"resolve_block_references()"},{"location":"reference/python/reference/#quokka.reference.References.resolve_calls","text":"Resolve calls to a chunk This method resolves calls initiated or received from every instruction in a chunk. Of note, a call must be from an Instruction Tuple to another. Parameters: Name Type Description Default chunk quokka . Chunk Target chunk required towards bool Do we look at calls towards this chunk {X,Y,Z} -> Chunk or at calls from this chunk Chunk -> {X,Y,Z} ? True Returns: Type Description List [ Union [ Tuple [ quokka . Chunk , quokka . Block , int ], quokka . Chunk ]] A list of objects that are either tuple (Chunk, Block, Instruction Index) or List [ Union [ Tuple [ quokka . Chunk , quokka . Block , int ], quokka . Chunk ]] Chunk (only for fake chunks that are created from an imported function) Source code in quokka/reference.py 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 def resolve_calls ( self , chunk : quokka . Chunk , towards : bool = True ) -> List [ Union [ Tuple [ quokka . Chunk , quokka . Block , int ], quokka . Chunk ]]: \"\"\"Resolve calls to a chunk This method resolves calls initiated or received from every instruction in a chunk. Of note, a call must be from an Instruction Tuple to another. Arguments: chunk: Target chunk towards: Do we look at calls towards this chunk {X,Y,Z} -> Chunk or at calls from this chunk Chunk -> {X,Y,Z} ? Returns: A list of objects that are either tuple (Chunk, Block, Instruction Index) or Chunk (only for fake chunks that are created from an imported function) \"\"\" return_list = [] target , wanted = self . get_direction ( towards ) for block_index in self . references_category [ ReferencesLocation . INST_INSTANCE ][ chunk . proto_index ]: # For super-chunks, filter out block that do not belong to this chunk # anymore if block_index not in chunk . index_to_address : continue block_references = self . references_category [ ReferencesLocation . INST_INSTANCE ][ chunk . proto_index ][ block_index ] for references in block_references . values (): for reference_idx in references : reference : \"Reference\" = self [ reference_idx ] if reference . type == ReferenceType . CALL and isinstance ( getattr ( reference , target ), tuple ): target_loc = getattr ( reference , target ) if target_loc [ 0 ] . proto_index == chunk . proto_index : location = getattr ( reference , wanted ) # Fix: Only returns valid tuple # TODO(dm): check why sometimes a Data might be returned if isinstance ( location , ( tuple , quokka . Chunk )): return_list . append ( location ) return return_list","title":"resolve_calls()"},{"location":"reference/python/reference/#quokka.reference.References.resolve_data","text":"Resolve data references Returns a list of reference towards a data If a reference_type is specified the references will be filtered by their type Parameters: Name Type Description Default data_index Index Index of the data in the protobuf required reference_type Union [ ReferenceType , None] Type of reference None Returns: Type Description List [ Reference ] A list of reference matching the criteria Source code in quokka/reference.py 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 def resolve_data ( self , data_index : Index , reference_type : Union [ ReferenceType , None ] = None , ) -> List [ Reference ]: \"\"\"Resolve data references Returns a list of reference towards a data If a reference_type is specified the references will be filtered by their type Arguments: data_index: Index of the data in the protobuf reference_type: Type of reference Returns: A list of reference matching the criteria \"\"\" references : List [ Reference ] = [] for reference_idx in self . references_category [ ReferencesLocation . DATA ][ data_index ]: reference = self [ reference_idx ] if reference_type is not None and reference_type != reference . type : continue references . append ( reference ) return references","title":"resolve_data()"},{"location":"reference/python/reference/#quokka.reference.References.resolve_inst_instance","text":"Resolve instruction references Return a list of references from/towards an instruction. If a reference_type is specified the references will be filtered by their type Parameters: Name Type Description Default inst_tuple Tuple [ int , int , int ] A tuple (Chunk Index, Block Index, Instruction Index) required reference_type Optional [ ReferenceType ] Reference type to consider (filter result) None towards bool In which sense to search the reference? True Returns: Type Description List [ Reference ] A list of reference matching the criteria Source code in quokka/reference.py 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 def resolve_inst_instance ( self , inst_tuple : Tuple [ int , int , int ], reference_type : Optional [ ReferenceType ] = None , towards : bool = True , ) -> List [ Reference ]: \"\"\"Resolve instruction references Return a list of references from/towards an instruction. If a reference_type is specified the references will be filtered by their type Arguments: inst_tuple: A tuple (Chunk Index, Block Index, Instruction Index) reference_type: Reference type to consider (filter result) towards: In which sense to search the reference? Returns: A list of reference matching the criteria \"\"\" return_list = [] target , _ = self . get_direction ( towards ) for reference_idx in self . references_category [ ReferencesLocation . INST_INSTANCE ][ inst_tuple [ 0 ] ][ inst_tuple [ 1 ]][ inst_tuple [ 2 ]]: reference : \"Reference\" = self [ reference_idx ] if ( not reference_type or reference . type == reference_type ) and isinstance ( getattr ( reference , target ), tuple ): target_loc = getattr ( reference , target ) if ( target_loc [ 0 ] . proto_index , target_loc [ 1 ] . proto_index , target_loc [ 2 ], ) == inst_tuple : return_list . append ( reference ) return return_list","title":"resolve_inst_instance()"},{"location":"reference/python/reference/#quokka.reference.References.resolve_location","text":"Resolve a location This convert a proto location to the actual instance of the object. Parameters: Name Type Description Default location quokka . pb . Quokka . Location A protobuf Location (sigh) object required Returns: Type Description ReferenceTarget A ReferenceTarget Raises: Type Description ValueError When no appropriate location has been found. Source code in quokka/reference.py 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def resolve_location ( self , location : quokka . pb . Quokka . Location ) -> ReferenceTarget : \"\"\"Resolve a location This convert a proto location to the actual instance of the object. Arguments: location: A protobuf Location (sigh) object Returns: A ReferenceTarget Raises: ValueError: When no appropriate location has been found. \"\"\" location_type : ReferencesLocation = self . location_type ( location ) if location_type == ReferencesLocation . INSTRUCTION : raise DeprecationWarning ( \"Not used anymore\" ) elif location_type == ReferencesLocation . DATA : return self . program . data_holder [ location . data_idx ] elif location_type == ReferencesLocation . STRUCTURE : structure : quokka . Structure = self . structures [ location . struct_position . structure_idx ] if location . struct_position . no_member is False : return structure [ structure . index_to_offset [ location . struct_position . member_idx ] ] return structure elif location_type == ReferencesLocation . INST_INSTANCE : return self . find_instruction ( location . instruction_position ) elif location_type == ReferencesLocation . CHUNK : return self . program . chunks [ location . chunk_idx ] raise ValueError ( \"No location found\" )","title":"resolve_location()"},{"location":"reference/python/reference/#quokka.reference.References.structures","text":"Accessor to the program structures Source code in quokka/reference.py 255 256 257 258 @property def structures ( self ) -> List [ quokka . Structure ]: \"\"\"Accessor to the program structures\"\"\" return self . program . structures","title":"structures()"},{"location":"reference/python/reference/#quokka.reference.ReferencesLocation","text":"Bases: enum . Enum Reference location A reference may be attached to one of the following an instruction index (that means every instance of the instruction) a data index a structure position (e.g. a structure or a member inside a structure) an instruction : a tuple with (chunk, block, inst_index) identifying precisely one instruction a function a chunk Source code in quokka/reference.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 class ReferencesLocation ( enum . Enum ): \"\"\"Reference location A reference may be attached to one of the following : * an instruction index (that means every instance of the instruction) * a data index * a structure position (e.g. a structure or a member inside a structure) * an instruction : a tuple with (chunk, block, inst_index) identifying precisely one instruction * a function * a chunk \"\"\" INSTRUCTION = \"inst_idx\" DATA = \"data_idx\" STRUCTURE = \"struct_position\" INST_INSTANCE = \"instruction_position\" FUNCTION = \"function_idx\" CHUNK = \"chunk_idx\" @staticmethod def from_proto ( location_type : str ) -> ReferencesLocation : \"\"\"Convert reference location from proto\"\"\" # These are the name of the fields in the protobuf mapping = { \"inst_idx\" : ReferencesLocation . INSTRUCTION , \"data_idx\" : ReferencesLocation . DATA , \"struct_position\" : ReferencesLocation . STRUCTURE , \"instruction_position\" : ReferencesLocation . INST_INSTANCE , \"function_idx\" : ReferencesLocation . FUNCTION , \"chunk_idx\" : ReferencesLocation . CHUNK , } try : return mapping [ location_type ] except IndexError as exc : raise ValueError ( \"Unknown location type\" ) from exc","title":"ReferencesLocation"},{"location":"reference/python/reference/#quokka.reference.ReferencesLocation.from_proto","text":"Convert reference location from proto Source code in quokka/reference.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @staticmethod def from_proto ( location_type : str ) -> ReferencesLocation : \"\"\"Convert reference location from proto\"\"\" # These are the name of the fields in the protobuf mapping = { \"inst_idx\" : ReferencesLocation . INSTRUCTION , \"data_idx\" : ReferencesLocation . DATA , \"struct_position\" : ReferencesLocation . STRUCTURE , \"instruction_position\" : ReferencesLocation . INST_INSTANCE , \"function_idx\" : ReferencesLocation . FUNCTION , \"chunk_idx\" : ReferencesLocation . CHUNK , } try : return mapping [ location_type ] except IndexError as exc : raise ValueError ( \"Unknown location type\" ) from exc","title":"from_proto()"},{"location":"reference/python/segment/","text":"Segment management Segment Segment This class represents IDA segments. Parameters: Name Type Description Default segment Segment Segment protobuf information required program quokka . Program Program back reference required Attributes: Name Type Description name str Segment name start AddressT Segment starting address permissions int Segment permissions size int Segment size type SegmentType Segment type program quokka . Program Program reference file_offset int Segment offset in the file (if appropriate) Source code in quokka/segment.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class Segment : \"\"\"Segment This class represents IDA segments. Arguments: segment: Segment protobuf information program: Program back reference Attributes: name: Segment name start: Segment starting address permissions: Segment permissions size: Segment size type: Segment type program: Program reference file_offset: Segment offset in the file (if appropriate) \"\"\" def __init__ ( self , segment : \"quokka.pb.Quokka.Segment\" , program : quokka . Program , ): \"\"\"Constructor\"\"\" self . name : str = segment . name self . start : AddressT = segment . start_addr self . permissions : int = segment . permissions self . size : int = segment . size self . type : \"SegmentType\" = SegmentType . from_proto ( segment . type ) self . program : quokka . Program = program self . file_offset : int = - 1 if segment . no_offset is False : self . file_offset = segment . file_offset - self . start @property def end ( self ) -> AddressT : \"\"\"End address of the segment\"\"\" return self . start + self . size def writable ( self ) -> bool : \"\"\"Is the segment writable?\"\"\" return self . permissions & 0x2 > 0 def executable ( self ) -> bool : \"\"\"Is the segment executable?\"\"\" return self . permissions & 0x1 > 0 def readable ( self ) -> bool : \"\"\"Is the segment readable?\"\"\" return self . permissions & 0x4 > 0 def in_segment ( self , addr : int ) -> bool : \"\"\"Does `addr` belong to this segment ?\"\"\" return self . start <= addr < self . start + self . size __init__ ( segment , program ) Constructor Source code in quokka/segment.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def __init__ ( self , segment : \"quokka.pb.Quokka.Segment\" , program : quokka . Program , ): \"\"\"Constructor\"\"\" self . name : str = segment . name self . start : AddressT = segment . start_addr self . permissions : int = segment . permissions self . size : int = segment . size self . type : \"SegmentType\" = SegmentType . from_proto ( segment . type ) self . program : quokka . Program = program self . file_offset : int = - 1 if segment . no_offset is False : self . file_offset = segment . file_offset - self . start end () property End address of the segment Source code in quokka/segment.py 62 63 64 65 @property def end ( self ) -> AddressT : \"\"\"End address of the segment\"\"\" return self . start + self . size executable () Is the segment executable? Source code in quokka/segment.py 71 72 73 def executable ( self ) -> bool : \"\"\"Is the segment executable?\"\"\" return self . permissions & 0x1 > 0 in_segment ( addr ) Does addr belong to this segment ? Source code in quokka/segment.py 79 80 81 def in_segment ( self , addr : int ) -> bool : \"\"\"Does `addr` belong to this segment ?\"\"\" return self . start <= addr < self . start + self . size readable () Is the segment readable? Source code in quokka/segment.py 75 76 77 def readable ( self ) -> bool : \"\"\"Is the segment readable?\"\"\" return self . permissions & 0x4 > 0 writable () Is the segment writable? Source code in quokka/segment.py 67 68 69 def writable ( self ) -> bool : \"\"\"Is the segment writable?\"\"\" return self . permissions & 0x2 > 0","title":"segment"},{"location":"reference/python/segment/#quokka.segment.Segment","text":"Segment This class represents IDA segments. Parameters: Name Type Description Default segment Segment Segment protobuf information required program quokka . Program Program back reference required Attributes: Name Type Description name str Segment name start AddressT Segment starting address permissions int Segment permissions size int Segment size type SegmentType Segment type program quokka . Program Program reference file_offset int Segment offset in the file (if appropriate) Source code in quokka/segment.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class Segment : \"\"\"Segment This class represents IDA segments. Arguments: segment: Segment protobuf information program: Program back reference Attributes: name: Segment name start: Segment starting address permissions: Segment permissions size: Segment size type: Segment type program: Program reference file_offset: Segment offset in the file (if appropriate) \"\"\" def __init__ ( self , segment : \"quokka.pb.Quokka.Segment\" , program : quokka . Program , ): \"\"\"Constructor\"\"\" self . name : str = segment . name self . start : AddressT = segment . start_addr self . permissions : int = segment . permissions self . size : int = segment . size self . type : \"SegmentType\" = SegmentType . from_proto ( segment . type ) self . program : quokka . Program = program self . file_offset : int = - 1 if segment . no_offset is False : self . file_offset = segment . file_offset - self . start @property def end ( self ) -> AddressT : \"\"\"End address of the segment\"\"\" return self . start + self . size def writable ( self ) -> bool : \"\"\"Is the segment writable?\"\"\" return self . permissions & 0x2 > 0 def executable ( self ) -> bool : \"\"\"Is the segment executable?\"\"\" return self . permissions & 0x1 > 0 def readable ( self ) -> bool : \"\"\"Is the segment readable?\"\"\" return self . permissions & 0x4 > 0 def in_segment ( self , addr : int ) -> bool : \"\"\"Does `addr` belong to this segment ?\"\"\" return self . start <= addr < self . start + self . size","title":"Segment"},{"location":"reference/python/segment/#quokka.segment.Segment.__init__","text":"Constructor Source code in quokka/segment.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def __init__ ( self , segment : \"quokka.pb.Quokka.Segment\" , program : quokka . Program , ): \"\"\"Constructor\"\"\" self . name : str = segment . name self . start : AddressT = segment . start_addr self . permissions : int = segment . permissions self . size : int = segment . size self . type : \"SegmentType\" = SegmentType . from_proto ( segment . type ) self . program : quokka . Program = program self . file_offset : int = - 1 if segment . no_offset is False : self . file_offset = segment . file_offset - self . start","title":"__init__()"},{"location":"reference/python/segment/#quokka.segment.Segment.end","text":"End address of the segment Source code in quokka/segment.py 62 63 64 65 @property def end ( self ) -> AddressT : \"\"\"End address of the segment\"\"\" return self . start + self . size","title":"end()"},{"location":"reference/python/segment/#quokka.segment.Segment.executable","text":"Is the segment executable? Source code in quokka/segment.py 71 72 73 def executable ( self ) -> bool : \"\"\"Is the segment executable?\"\"\" return self . permissions & 0x1 > 0","title":"executable()"},{"location":"reference/python/segment/#quokka.segment.Segment.in_segment","text":"Does addr belong to this segment ? Source code in quokka/segment.py 79 80 81 def in_segment ( self , addr : int ) -> bool : \"\"\"Does `addr` belong to this segment ?\"\"\" return self . start <= addr < self . start + self . size","title":"in_segment()"},{"location":"reference/python/segment/#quokka.segment.Segment.readable","text":"Is the segment readable? Source code in quokka/segment.py 75 76 77 def readable ( self ) -> bool : \"\"\"Is the segment readable?\"\"\" return self . permissions & 0x4 > 0","title":"readable()"},{"location":"reference/python/segment/#quokka.segment.Segment.writable","text":"Is the segment writable? Source code in quokka/segment.py 67 68 69 def writable ( self ) -> bool : \"\"\"Is the segment writable?\"\"\" return self . permissions & 0x2 > 0","title":"writable()"},{"location":"reference/python/structure/","text":"Structure management Structure Bases: dict Structure All IDA structure are merged inside this class (Enum, Structure, Union). Parameters: Name Type Description Default structure Structure Structure protobuf data required program quokka . Program Program back reference required Attributes: Name Type Description program quokka . Program Program backreference name str Structure name size Optional [ int ] Structure size (if known) type Structure type index_to_offset Dict [ int , int ] Mapping from offsets to structure members comments List [ str ] Structure comments Source code in quokka/structure.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class Structure ( dict ): \"\"\"Structure All IDA structure are merged inside this class (Enum, Structure, Union). Arguments: structure: Structure protobuf data program: Program back reference Attributes: program: Program backreference name: Structure name size: Structure size (if known) type: Structure type index_to_offset: Mapping from offsets to structure members comments: Structure comments \"\"\" def __init__ ( self , structure : \"quokka.pb.Quokka.Structure\" , program : quokka . Program , ) -> None : \"\"\"Constructor\"\"\" super ( dict , self ) . __init__ () self . program : quokka . Program = program self . name : str = structure . name self . size : Optional [ int ] = ( structure . size if structure . variable_size is False else 0 ) self . type = StructureType . from_proto ( structure . type ) self . index_to_offset : Dict [ int , int ] = {} for index , member in enumerate ( structure . members ): self [ member . offset ] = StructureMember ( member , self ) self . index_to_offset [ index ] = member . offset self . comments : List [ str ] = [] __init__ ( structure , program ) Constructor Source code in quokka/structure.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def __init__ ( self , structure : \"quokka.pb.Quokka.Structure\" , program : quokka . Program , ) -> None : \"\"\"Constructor\"\"\" super ( dict , self ) . __init__ () self . program : quokka . Program = program self . name : str = structure . name self . size : Optional [ int ] = ( structure . size if structure . variable_size is False else 0 ) self . type = StructureType . from_proto ( structure . type ) self . index_to_offset : Dict [ int , int ] = {} for index , member in enumerate ( structure . members ): self [ member . offset ] = StructureMember ( member , self ) self . index_to_offset [ index ] = member . offset self . comments : List [ str ] = [] StructureMember StructureMember This class represents structure members (fields). Parameters: Name Type Description Default member Member Protobuf data required structure Structure Reference to the parent structure required Attributes: Name Type Description name str Member name size int Member size (if known) type DataType Member data type value Optional [ int ] Member value comments List [ str ] Member comments Source code in quokka/structure.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class StructureMember : \"\"\"StructureMember This class represents structure members (fields). Arguments: member: Protobuf data structure: Reference to the parent structure Attributes: name: Member name size: Member size (if known) type: Member data type value: Member value comments: Member comments \"\"\" def __init__ ( self , member : \"quokka.pb.Quokka.Structure.Member\" , structure : Structure , ) -> None : \"\"\"Constructor\"\"\" self . name : str = member . name self . type : DataType = DataType . from_proto ( member . type ) self . size : int = member . size self . value : Optional [ int ] = member . value if member . value != 0 else None self . _structure : weakref . ref [ Structure ] = weakref . ref ( structure ) self . comments : List [ str ] = [] @property def structure ( self ) -> Structure : \"\"\"Back reference to the parent structure\"\"\" return self . _structure () __init__ ( member , structure ) Constructor Source code in quokka/structure.py 46 47 48 49 50 51 52 53 54 55 56 57 58 def __init__ ( self , member : \"quokka.pb.Quokka.Structure.Member\" , structure : Structure , ) -> None : \"\"\"Constructor\"\"\" self . name : str = member . name self . type : DataType = DataType . from_proto ( member . type ) self . size : int = member . size self . value : Optional [ int ] = member . value if member . value != 0 else None self . _structure : weakref . ref [ Structure ] = weakref . ref ( structure ) self . comments : List [ str ] = [] structure () property Back reference to the parent structure Source code in quokka/structure.py 60 61 62 63 @property def structure ( self ) -> Structure : \"\"\"Back reference to the parent structure\"\"\" return self . _structure ()","title":"structure"},{"location":"reference/python/structure/#quokka.structure.Structure","text":"Bases: dict Structure All IDA structure are merged inside this class (Enum, Structure, Union). Parameters: Name Type Description Default structure Structure Structure protobuf data required program quokka . Program Program back reference required Attributes: Name Type Description program quokka . Program Program backreference name str Structure name size Optional [ int ] Structure size (if known) type Structure type index_to_offset Dict [ int , int ] Mapping from offsets to structure members comments List [ str ] Structure comments Source code in quokka/structure.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class Structure ( dict ): \"\"\"Structure All IDA structure are merged inside this class (Enum, Structure, Union). Arguments: structure: Structure protobuf data program: Program back reference Attributes: program: Program backreference name: Structure name size: Structure size (if known) type: Structure type index_to_offset: Mapping from offsets to structure members comments: Structure comments \"\"\" def __init__ ( self , structure : \"quokka.pb.Quokka.Structure\" , program : quokka . Program , ) -> None : \"\"\"Constructor\"\"\" super ( dict , self ) . __init__ () self . program : quokka . Program = program self . name : str = structure . name self . size : Optional [ int ] = ( structure . size if structure . variable_size is False else 0 ) self . type = StructureType . from_proto ( structure . type ) self . index_to_offset : Dict [ int , int ] = {} for index , member in enumerate ( structure . members ): self [ member . offset ] = StructureMember ( member , self ) self . index_to_offset [ index ] = member . offset self . comments : List [ str ] = []","title":"Structure"},{"location":"reference/python/structure/#quokka.structure.Structure.__init__","text":"Constructor Source code in quokka/structure.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def __init__ ( self , structure : \"quokka.pb.Quokka.Structure\" , program : quokka . Program , ) -> None : \"\"\"Constructor\"\"\" super ( dict , self ) . __init__ () self . program : quokka . Program = program self . name : str = structure . name self . size : Optional [ int ] = ( structure . size if structure . variable_size is False else 0 ) self . type = StructureType . from_proto ( structure . type ) self . index_to_offset : Dict [ int , int ] = {} for index , member in enumerate ( structure . members ): self [ member . offset ] = StructureMember ( member , self ) self . index_to_offset [ index ] = member . offset self . comments : List [ str ] = []","title":"__init__()"},{"location":"reference/python/structure/#quokka.structure.StructureMember","text":"StructureMember This class represents structure members (fields). Parameters: Name Type Description Default member Member Protobuf data required structure Structure Reference to the parent structure required Attributes: Name Type Description name str Member name size int Member size (if known) type DataType Member data type value Optional [ int ] Member value comments List [ str ] Member comments Source code in quokka/structure.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class StructureMember : \"\"\"StructureMember This class represents structure members (fields). Arguments: member: Protobuf data structure: Reference to the parent structure Attributes: name: Member name size: Member size (if known) type: Member data type value: Member value comments: Member comments \"\"\" def __init__ ( self , member : \"quokka.pb.Quokka.Structure.Member\" , structure : Structure , ) -> None : \"\"\"Constructor\"\"\" self . name : str = member . name self . type : DataType = DataType . from_proto ( member . type ) self . size : int = member . size self . value : Optional [ int ] = member . value if member . value != 0 else None self . _structure : weakref . ref [ Structure ] = weakref . ref ( structure ) self . comments : List [ str ] = [] @property def structure ( self ) -> Structure : \"\"\"Back reference to the parent structure\"\"\" return self . _structure ()","title":"StructureMember"},{"location":"reference/python/structure/#quokka.structure.StructureMember.__init__","text":"Constructor Source code in quokka/structure.py 46 47 48 49 50 51 52 53 54 55 56 57 58 def __init__ ( self , member : \"quokka.pb.Quokka.Structure.Member\" , structure : Structure , ) -> None : \"\"\"Constructor\"\"\" self . name : str = member . name self . type : DataType = DataType . from_proto ( member . type ) self . size : int = member . size self . value : Optional [ int ] = member . value if member . value != 0 else None self . _structure : weakref . ref [ Structure ] = weakref . ref ( structure ) self . comments : List [ str ] = []","title":"__init__()"},{"location":"reference/python/structure/#quokka.structure.StructureMember.structure","text":"Back reference to the parent structure Source code in quokka/structure.py 60 61 62 63 @property def structure ( self ) -> Structure : \"\"\"Back reference to the parent structure\"\"\" return self . _structure ()","title":"structure()"},{"location":"reference/python/types/","text":"Types used in Quokka AddressSize Bases: enum . Enum Address size Source code in quokka/types.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class AddressSize ( enum . Enum ): \"\"\"Address size\"\"\" ADDRESS_64 = enum . auto () ADDRESS_32 = enum . auto () ADDRESS_16 = enum . auto () ADDRESS_UNK = enum . auto () @staticmethod def from_proto ( address_size : \"quokka.pb.Quokka.AddressSizeValue\" , ) -> \"AddressSize\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . ADDR_32 : AddressSize . ADDRESS_32 , quokka . pb . Quokka . ADDR_64 : AddressSize . ADDRESS_64 , } return mapping . get ( address_size , AddressSize . ADDRESS_UNK ) from_proto ( address_size ) staticmethod Convert the protobuf value into this enumeration Source code in quokka/types.py 69 70 71 72 73 74 75 76 77 78 79 @staticmethod def from_proto ( address_size : \"quokka.pb.Quokka.AddressSizeValue\" , ) -> \"AddressSize\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . ADDR_32 : AddressSize . ADDRESS_32 , quokka . pb . Quokka . ADDR_64 : AddressSize . ADDRESS_64 , } return mapping . get ( address_size , AddressSize . ADDRESS_UNK ) BlockType Bases: enum . Enum Block Type Source code in quokka/types.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 class BlockType ( enum . Enum ): \"\"\"Block Type\"\"\" NORMAL = enum . auto () INDJUMP = enum . auto () RET = enum . auto () NORET = enum . auto () CNDRET = enum . auto () ENORET = enum . auto () EXTERN = enum . auto () ERROR = enum . auto () FAKE = enum . auto () @staticmethod def from_proto ( block_type : \"quokka.pb.Quokka.FunctionChunk.Block.BlockTypeValue\" , ) -> BlockType : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_NORMAL : BlockType . NORMAL , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_INDJUMP : BlockType . INDJUMP , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_RET : BlockType . RET , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_NORET : BlockType . NORET , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_CNDRET : BlockType . CNDRET , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_ENORET : BlockType . ENORET , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_EXTERN : BlockType . EXTERN , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_ERROR : BlockType . ERROR , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_FAKE : BlockType . FAKE , } return mapping . get ( block_type , BlockType . FAKE ) from_proto ( block_type ) staticmethod Convert the protobuf value into this enumeration Source code in quokka/types.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 @staticmethod def from_proto ( block_type : \"quokka.pb.Quokka.FunctionChunk.Block.BlockTypeValue\" , ) -> BlockType : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_NORMAL : BlockType . NORMAL , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_INDJUMP : BlockType . INDJUMP , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_RET : BlockType . RET , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_NORET : BlockType . NORET , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_CNDRET : BlockType . CNDRET , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_ENORET : BlockType . ENORET , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_EXTERN : BlockType . EXTERN , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_ERROR : BlockType . ERROR , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_FAKE : BlockType . FAKE , } return mapping . get ( block_type , BlockType . FAKE ) DataType Bases: enum . Enum Data Type Source code in quokka/types.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 class DataType ( enum . Enum ): \"\"\"Data Type\"\"\" UNKNOWN = enum . auto () BYTE = enum . auto () WORD = enum . auto () DOUBLE_WORD = enum . auto () QUAD_WORD = enum . auto () OCTO_WORD = enum . auto () FLOAT = enum . auto () DOUBLE = enum . auto () ASCII = enum . auto () STRUCT = enum . auto () ALIGN = enum . auto () POINTER = enum . auto () @staticmethod def from_proto ( data_type : \"quokka.pb.Quokka.DataTypeValue\" ) -> \"DataType\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . TYPE_B : DataType . BYTE , quokka . pb . Quokka . TYPE_W : DataType . WORD , quokka . pb . Quokka . TYPE_DW : DataType . DOUBLE_WORD , quokka . pb . Quokka . TYPE_QW : DataType . QUAD_WORD , quokka . pb . Quokka . TYPE_OW : DataType . QUAD_WORD , quokka . pb . Quokka . TYPE_FLOAT : DataType . FLOAT , quokka . pb . Quokka . TYPE_DOUBLE : DataType . DOUBLE , quokka . pb . Quokka . TYPE_ASCII : DataType . ASCII , quokka . pb . Quokka . TYPE_STRUCT : DataType . STRUCT , quokka . pb . Quokka . TYPE_ALIGN : DataType . ALIGN , quokka . pb . Quokka . TYPE_POINTER : DataType . POINTER , } return mapping . get ( data_type , DataType . UNKNOWN ) from_proto ( data_type ) staticmethod Convert the protobuf value into this enumeration Source code in quokka/types.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 @staticmethod def from_proto ( data_type : \"quokka.pb.Quokka.DataTypeValue\" ) -> \"DataType\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . TYPE_B : DataType . BYTE , quokka . pb . Quokka . TYPE_W : DataType . WORD , quokka . pb . Quokka . TYPE_DW : DataType . DOUBLE_WORD , quokka . pb . Quokka . TYPE_QW : DataType . QUAD_WORD , quokka . pb . Quokka . TYPE_OW : DataType . QUAD_WORD , quokka . pb . Quokka . TYPE_FLOAT : DataType . FLOAT , quokka . pb . Quokka . TYPE_DOUBLE : DataType . DOUBLE , quokka . pb . Quokka . TYPE_ASCII : DataType . ASCII , quokka . pb . Quokka . TYPE_STRUCT : DataType . STRUCT , quokka . pb . Quokka . TYPE_ALIGN : DataType . ALIGN , quokka . pb . Quokka . TYPE_POINTER : DataType . POINTER , } return mapping . get ( data_type , DataType . UNKNOWN ) EdgeType Bases: enum . Enum Edge Type Source code in quokka/types.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 class EdgeType ( enum . Enum ): \"\"\"Edge Type\"\"\" UNCONDITIONAL = enum . auto () TRUE = enum . auto () FALSE = enum . auto () SWITCH = enum . auto () @staticmethod def from_proto ( edge_type : \"quokka.pb.Quokka.Edge.EdgeTypeValue\" , ) -> \"EdgeType\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . Edge . TYPE_UNCONDITIONAL : EdgeType . UNCONDITIONAL , quokka . pb . Quokka . Edge . TYPE_TRUE : EdgeType . TRUE , quokka . pb . Quokka . Edge . TYPE_FALSE : EdgeType . FALSE , quokka . pb . Quokka . Edge . TYPE_SWITCH : EdgeType . SWITCH , } edge = mapping . get ( edge_type ) if edge is not None : return edge raise ValueError ( \"Unable to decode Edge Type\" ) from_proto ( edge_type ) staticmethod Convert the protobuf value into this enumeration Source code in quokka/types.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 @staticmethod def from_proto ( edge_type : \"quokka.pb.Quokka.Edge.EdgeTypeValue\" , ) -> \"EdgeType\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . Edge . TYPE_UNCONDITIONAL : EdgeType . UNCONDITIONAL , quokka . pb . Quokka . Edge . TYPE_TRUE : EdgeType . TRUE , quokka . pb . Quokka . Edge . TYPE_FALSE : EdgeType . FALSE , quokka . pb . Quokka . Edge . TYPE_SWITCH : EdgeType . SWITCH , } edge = mapping . get ( edge_type ) if edge is not None : return edge raise ValueError ( \"Unable to decode Edge Type\" ) Endianness Bases: enum . Enum Endianness of the program LE: Little endian (least significant bit first) BE: Big endian (most significant bit first) TODO See how we can support mixed endianness Source code in quokka/types.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class Endianness ( enum . Enum ): \"\"\"Endianness of the program LE: Little endian (least significant bit first) BE: Big endian (most significant bit first) TODO: See how we can support mixed endianness \"\"\" LITTLE_ENDIAN = enum . auto () BIG_ENDIAN = enum . auto () UNKNOWN = enum . auto () @staticmethod def from_proto ( endianness : \"quokka.pb.Quokka.Meta.EndianessValue\" , ) -> Endianness : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . Meta . END_BE : Endianness . BIG_ENDIAN , quokka . pb . Quokka . Meta . END_LE : Endianness . LITTLE_ENDIAN , } return mapping . get ( endianness , Endianness . UNKNOWN ) from_proto ( endianness ) staticmethod Convert the protobuf value into this enumeration Source code in quokka/types.py 96 97 98 99 100 101 102 103 104 105 106 @staticmethod def from_proto ( endianness : \"quokka.pb.Quokka.Meta.EndianessValue\" , ) -> Endianness : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . Meta . END_BE : Endianness . BIG_ENDIAN , quokka . pb . Quokka . Meta . END_LE : Endianness . LITTLE_ENDIAN , } return mapping . get ( endianness , Endianness . UNKNOWN ) ExporterMode Bases: enum . IntEnum Mode type The exporter mode controls the type of exported data. Source code in quokka/types.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 class ExporterMode ( enum . IntEnum ): \"\"\"Mode type The exporter mode controls the type of exported data. \"\"\" LIGHT = enum . auto () FULL = enum . auto () NORMAL = enum . auto () @staticmethod def from_proto ( mode : \"quokka.pb.Quokka.ExporterMeta.ModeValue\" ) -> \"ExporterMode\" : mapping = { quokka . pb . Quokka . ExporterMeta . MODE_LIGHT : ExporterMode . LIGHT , quokka . pb . Quokka . ExporterMeta . MODE_FULL : ExporterMode . FULL , } return mapping . get ( mode , ExporterMode . NORMAL ) FunctionType Bases: enum . Enum Function Type Source code in quokka/types.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 class FunctionType ( enum . Enum ): \"\"\"Function Type\"\"\" NORMAL = enum . auto () IMPORTED = enum . auto () LIBRARY = enum . auto () THUNK = enum . auto () EXTERN = enum . auto () INVALID = enum . auto () @staticmethod def from_proto ( function_type : \"quokka.pb.Quokka.Function.FunctionTypeValue\" , ) -> \"FunctionType\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . Function . TYPE_NORMAL : FunctionType . NORMAL , quokka . pb . Quokka . Function . TYPE_IMPORTED : FunctionType . IMPORTED , quokka . pb . Quokka . Function . TYPE_LIBRARY : FunctionType . LIBRARY , quokka . pb . Quokka . Function . TYPE_THUNK : FunctionType . THUNK , } return mapping . get ( function_type , FunctionType . INVALID ) from_proto ( function_type ) staticmethod Convert the protobuf value into this enumeration Source code in quokka/types.py 146 147 148 149 150 151 152 153 154 155 156 157 158 @staticmethod def from_proto ( function_type : \"quokka.pb.Quokka.Function.FunctionTypeValue\" , ) -> \"FunctionType\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . Function . TYPE_NORMAL : FunctionType . NORMAL , quokka . pb . Quokka . Function . TYPE_IMPORTED : FunctionType . IMPORTED , quokka . pb . Quokka . Function . TYPE_LIBRARY : FunctionType . LIBRARY , quokka . pb . Quokka . Function . TYPE_THUNK : FunctionType . THUNK , } return mapping . get ( function_type , FunctionType . INVALID ) ReferenceType Bases: enum . Enum Reference Type Source code in quokka/types.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 class ReferenceType ( enum . Enum ): \"\"\"Reference Type\"\"\" CALL = enum . auto () DATA = enum . auto () ENUM = enum . auto () STRUC = enum . auto () UNKNOWN = enum . auto () @staticmethod def from_proto ( reference_type : \"quokka.pb.Quokka.Reference.ReferenceTypeValue\" , ) -> \"ReferenceType\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . Reference . REF_CALL : ReferenceType . CALL , quokka . pb . Quokka . Reference . REF_DATA : ReferenceType . DATA , quokka . pb . Quokka . Reference . REF_ENUM : ReferenceType . ENUM , quokka . pb . Quokka . Reference . REF_STRUC : ReferenceType . STRUC , } return mapping . get ( reference_type , ReferenceType . UNKNOWN ) from_proto ( reference_type ) staticmethod Convert the protobuf value into this enumeration Source code in quokka/types.py 203 204 205 206 207 208 209 210 211 212 213 214 215 @staticmethod def from_proto ( reference_type : \"quokka.pb.Quokka.Reference.ReferenceTypeValue\" , ) -> \"ReferenceType\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . Reference . REF_CALL : ReferenceType . CALL , quokka . pb . Quokka . Reference . REF_DATA : ReferenceType . DATA , quokka . pb . Quokka . Reference . REF_ENUM : ReferenceType . ENUM , quokka . pb . Quokka . Reference . REF_STRUC : ReferenceType . STRUC , } return mapping . get ( reference_type , ReferenceType . UNKNOWN ) SegmentType Bases: enum . Enum Segment Type Source code in quokka/types.py 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 class SegmentType ( enum . Enum ): \"\"\"Segment Type\"\"\" UNKNOWN = enum . auto () CODE = enum . auto () DATA = enum . auto () BSS = enum . auto () NULL = enum . auto () EXTERN = enum . auto () NORMAL = enum . auto () ABSOLUTE_SYMBOLS = enum . auto () @staticmethod def from_proto ( segment_type : \"quokka.pb.Quokka.Segment.TypeValue\" , ) -> \"SegmentType\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . Segment . SEGMENT_CODE : SegmentType . CODE , quokka . pb . Quokka . Segment . SEGMENT_DATA : SegmentType . DATA , quokka . pb . Quokka . Segment . SEGMENT_BSS : SegmentType . BSS , quokka . pb . Quokka . Segment . SEGMENT_NULL : SegmentType . NULL , quokka . pb . Quokka . Segment . SEGMENT_NORMAL : SegmentType . NORMAL , quokka . pb . Quokka . Segment . SEGMENT_EXTERN : SegmentType . EXTERN , quokka . pb . Quokka . Segment . SEGMENT_ABSOLUTE_SYMBOLS : SegmentType . ABSOLUTE_SYMBOLS , } return mapping . get ( segment_type , SegmentType . UNKNOWN ) from_proto ( segment_type ) staticmethod Convert the protobuf value into this enumeration Source code in quokka/types.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 @staticmethod def from_proto ( segment_type : \"quokka.pb.Quokka.Segment.TypeValue\" , ) -> \"SegmentType\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . Segment . SEGMENT_CODE : SegmentType . CODE , quokka . pb . Quokka . Segment . SEGMENT_DATA : SegmentType . DATA , quokka . pb . Quokka . Segment . SEGMENT_BSS : SegmentType . BSS , quokka . pb . Quokka . Segment . SEGMENT_NULL : SegmentType . NULL , quokka . pb . Quokka . Segment . SEGMENT_NORMAL : SegmentType . NORMAL , quokka . pb . Quokka . Segment . SEGMENT_EXTERN : SegmentType . EXTERN , quokka . pb . Quokka . Segment . SEGMENT_ABSOLUTE_SYMBOLS : SegmentType . ABSOLUTE_SYMBOLS , } return mapping . get ( segment_type , SegmentType . UNKNOWN ) StructureType Bases: enum . Enum Structure Type Source code in quokka/types.py 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 class StructureType ( enum . Enum ): \"\"\"Structure Type\"\"\" STRUCT = enum . auto () ENUM = enum . auto () UNION = enum . auto () UNKNOWN = enum . auto () @staticmethod def from_proto ( structure_type : \"quokka.pb.Quokka.Structure.StructureTypeValue\" , ) -> \"StructureType\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . Structure . TYPE_STRUCT : StructureType . STRUCT , quokka . pb . Quokka . Structure . TYPE_ENUM : StructureType . ENUM , quokka . pb . Quokka . Structure . TYPE_UNION : StructureType . UNION , } return mapping . get ( structure_type , StructureType . UNKNOWN ) from_proto ( structure_type ) staticmethod Convert the protobuf value into this enumeration Source code in quokka/types.py 292 293 294 295 296 297 298 299 300 301 302 303 @staticmethod def from_proto ( structure_type : \"quokka.pb.Quokka.Structure.StructureTypeValue\" , ) -> \"StructureType\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . Structure . TYPE_STRUCT : StructureType . STRUCT , quokka . pb . Quokka . Structure . TYPE_ENUM : StructureType . ENUM , quokka . pb . Quokka . Structure . TYPE_UNION : StructureType . UNION , } return mapping . get ( structure_type , StructureType . UNKNOWN )","title":"types"},{"location":"reference/python/types/#quokka.types.AddressSize","text":"Bases: enum . Enum Address size Source code in quokka/types.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class AddressSize ( enum . Enum ): \"\"\"Address size\"\"\" ADDRESS_64 = enum . auto () ADDRESS_32 = enum . auto () ADDRESS_16 = enum . auto () ADDRESS_UNK = enum . auto () @staticmethod def from_proto ( address_size : \"quokka.pb.Quokka.AddressSizeValue\" , ) -> \"AddressSize\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . ADDR_32 : AddressSize . ADDRESS_32 , quokka . pb . Quokka . ADDR_64 : AddressSize . ADDRESS_64 , } return mapping . get ( address_size , AddressSize . ADDRESS_UNK )","title":"AddressSize"},{"location":"reference/python/types/#quokka.types.AddressSize.from_proto","text":"Convert the protobuf value into this enumeration Source code in quokka/types.py 69 70 71 72 73 74 75 76 77 78 79 @staticmethod def from_proto ( address_size : \"quokka.pb.Quokka.AddressSizeValue\" , ) -> \"AddressSize\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . ADDR_32 : AddressSize . ADDRESS_32 , quokka . pb . Quokka . ADDR_64 : AddressSize . ADDRESS_64 , } return mapping . get ( address_size , AddressSize . ADDRESS_UNK )","title":"from_proto()"},{"location":"reference/python/types/#quokka.types.BlockType","text":"Bases: enum . Enum Block Type Source code in quokka/types.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 class BlockType ( enum . Enum ): \"\"\"Block Type\"\"\" NORMAL = enum . auto () INDJUMP = enum . auto () RET = enum . auto () NORET = enum . auto () CNDRET = enum . auto () ENORET = enum . auto () EXTERN = enum . auto () ERROR = enum . auto () FAKE = enum . auto () @staticmethod def from_proto ( block_type : \"quokka.pb.Quokka.FunctionChunk.Block.BlockTypeValue\" , ) -> BlockType : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_NORMAL : BlockType . NORMAL , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_INDJUMP : BlockType . INDJUMP , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_RET : BlockType . RET , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_NORET : BlockType . NORET , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_CNDRET : BlockType . CNDRET , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_ENORET : BlockType . ENORET , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_EXTERN : BlockType . EXTERN , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_ERROR : BlockType . ERROR , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_FAKE : BlockType . FAKE , } return mapping . get ( block_type , BlockType . FAKE )","title":"BlockType"},{"location":"reference/python/types/#quokka.types.BlockType.from_proto","text":"Convert the protobuf value into this enumeration Source code in quokka/types.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 @staticmethod def from_proto ( block_type : \"quokka.pb.Quokka.FunctionChunk.Block.BlockTypeValue\" , ) -> BlockType : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_NORMAL : BlockType . NORMAL , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_INDJUMP : BlockType . INDJUMP , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_RET : BlockType . RET , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_NORET : BlockType . NORET , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_CNDRET : BlockType . CNDRET , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_ENORET : BlockType . ENORET , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_EXTERN : BlockType . EXTERN , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_ERROR : BlockType . ERROR , quokka . pb . Quokka . FunctionChunk . Block . BLOCK_TYPE_FAKE : BlockType . FAKE , } return mapping . get ( block_type , BlockType . FAKE )","title":"from_proto()"},{"location":"reference/python/types/#quokka.types.DataType","text":"Bases: enum . Enum Data Type Source code in quokka/types.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 class DataType ( enum . Enum ): \"\"\"Data Type\"\"\" UNKNOWN = enum . auto () BYTE = enum . auto () WORD = enum . auto () DOUBLE_WORD = enum . auto () QUAD_WORD = enum . auto () OCTO_WORD = enum . auto () FLOAT = enum . auto () DOUBLE = enum . auto () ASCII = enum . auto () STRUCT = enum . auto () ALIGN = enum . auto () POINTER = enum . auto () @staticmethod def from_proto ( data_type : \"quokka.pb.Quokka.DataTypeValue\" ) -> \"DataType\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . TYPE_B : DataType . BYTE , quokka . pb . Quokka . TYPE_W : DataType . WORD , quokka . pb . Quokka . TYPE_DW : DataType . DOUBLE_WORD , quokka . pb . Quokka . TYPE_QW : DataType . QUAD_WORD , quokka . pb . Quokka . TYPE_OW : DataType . QUAD_WORD , quokka . pb . Quokka . TYPE_FLOAT : DataType . FLOAT , quokka . pb . Quokka . TYPE_DOUBLE : DataType . DOUBLE , quokka . pb . Quokka . TYPE_ASCII : DataType . ASCII , quokka . pb . Quokka . TYPE_STRUCT : DataType . STRUCT , quokka . pb . Quokka . TYPE_ALIGN : DataType . ALIGN , quokka . pb . Quokka . TYPE_POINTER : DataType . POINTER , } return mapping . get ( data_type , DataType . UNKNOWN )","title":"DataType"},{"location":"reference/python/types/#quokka.types.DataType.from_proto","text":"Convert the protobuf value into this enumeration Source code in quokka/types.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 @staticmethod def from_proto ( data_type : \"quokka.pb.Quokka.DataTypeValue\" ) -> \"DataType\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . TYPE_B : DataType . BYTE , quokka . pb . Quokka . TYPE_W : DataType . WORD , quokka . pb . Quokka . TYPE_DW : DataType . DOUBLE_WORD , quokka . pb . Quokka . TYPE_QW : DataType . QUAD_WORD , quokka . pb . Quokka . TYPE_OW : DataType . QUAD_WORD , quokka . pb . Quokka . TYPE_FLOAT : DataType . FLOAT , quokka . pb . Quokka . TYPE_DOUBLE : DataType . DOUBLE , quokka . pb . Quokka . TYPE_ASCII : DataType . ASCII , quokka . pb . Quokka . TYPE_STRUCT : DataType . STRUCT , quokka . pb . Quokka . TYPE_ALIGN : DataType . ALIGN , quokka . pb . Quokka . TYPE_POINTER : DataType . POINTER , } return mapping . get ( data_type , DataType . UNKNOWN )","title":"from_proto()"},{"location":"reference/python/types/#quokka.types.EdgeType","text":"Bases: enum . Enum Edge Type Source code in quokka/types.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 class EdgeType ( enum . Enum ): \"\"\"Edge Type\"\"\" UNCONDITIONAL = enum . auto () TRUE = enum . auto () FALSE = enum . auto () SWITCH = enum . auto () @staticmethod def from_proto ( edge_type : \"quokka.pb.Quokka.Edge.EdgeTypeValue\" , ) -> \"EdgeType\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . Edge . TYPE_UNCONDITIONAL : EdgeType . UNCONDITIONAL , quokka . pb . Quokka . Edge . TYPE_TRUE : EdgeType . TRUE , quokka . pb . Quokka . Edge . TYPE_FALSE : EdgeType . FALSE , quokka . pb . Quokka . Edge . TYPE_SWITCH : EdgeType . SWITCH , } edge = mapping . get ( edge_type ) if edge is not None : return edge raise ValueError ( \"Unable to decode Edge Type\" )","title":"EdgeType"},{"location":"reference/python/types/#quokka.types.EdgeType.from_proto","text":"Convert the protobuf value into this enumeration Source code in quokka/types.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 @staticmethod def from_proto ( edge_type : \"quokka.pb.Quokka.Edge.EdgeTypeValue\" , ) -> \"EdgeType\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . Edge . TYPE_UNCONDITIONAL : EdgeType . UNCONDITIONAL , quokka . pb . Quokka . Edge . TYPE_TRUE : EdgeType . TRUE , quokka . pb . Quokka . Edge . TYPE_FALSE : EdgeType . FALSE , quokka . pb . Quokka . Edge . TYPE_SWITCH : EdgeType . SWITCH , } edge = mapping . get ( edge_type ) if edge is not None : return edge raise ValueError ( \"Unable to decode Edge Type\" )","title":"from_proto()"},{"location":"reference/python/types/#quokka.types.Endianness","text":"Bases: enum . Enum Endianness of the program LE: Little endian (least significant bit first) BE: Big endian (most significant bit first) TODO See how we can support mixed endianness Source code in quokka/types.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class Endianness ( enum . Enum ): \"\"\"Endianness of the program LE: Little endian (least significant bit first) BE: Big endian (most significant bit first) TODO: See how we can support mixed endianness \"\"\" LITTLE_ENDIAN = enum . auto () BIG_ENDIAN = enum . auto () UNKNOWN = enum . auto () @staticmethod def from_proto ( endianness : \"quokka.pb.Quokka.Meta.EndianessValue\" , ) -> Endianness : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . Meta . END_BE : Endianness . BIG_ENDIAN , quokka . pb . Quokka . Meta . END_LE : Endianness . LITTLE_ENDIAN , } return mapping . get ( endianness , Endianness . UNKNOWN )","title":"Endianness"},{"location":"reference/python/types/#quokka.types.Endianness.from_proto","text":"Convert the protobuf value into this enumeration Source code in quokka/types.py 96 97 98 99 100 101 102 103 104 105 106 @staticmethod def from_proto ( endianness : \"quokka.pb.Quokka.Meta.EndianessValue\" , ) -> Endianness : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . Meta . END_BE : Endianness . BIG_ENDIAN , quokka . pb . Quokka . Meta . END_LE : Endianness . LITTLE_ENDIAN , } return mapping . get ( endianness , Endianness . UNKNOWN )","title":"from_proto()"},{"location":"reference/python/types/#quokka.types.ExporterMode","text":"Bases: enum . IntEnum Mode type The exporter mode controls the type of exported data. Source code in quokka/types.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 class ExporterMode ( enum . IntEnum ): \"\"\"Mode type The exporter mode controls the type of exported data. \"\"\" LIGHT = enum . auto () FULL = enum . auto () NORMAL = enum . auto () @staticmethod def from_proto ( mode : \"quokka.pb.Quokka.ExporterMeta.ModeValue\" ) -> \"ExporterMode\" : mapping = { quokka . pb . Quokka . ExporterMeta . MODE_LIGHT : ExporterMode . LIGHT , quokka . pb . Quokka . ExporterMeta . MODE_FULL : ExporterMode . FULL , } return mapping . get ( mode , ExporterMode . NORMAL )","title":"ExporterMode"},{"location":"reference/python/types/#quokka.types.FunctionType","text":"Bases: enum . Enum Function Type Source code in quokka/types.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 class FunctionType ( enum . Enum ): \"\"\"Function Type\"\"\" NORMAL = enum . auto () IMPORTED = enum . auto () LIBRARY = enum . auto () THUNK = enum . auto () EXTERN = enum . auto () INVALID = enum . auto () @staticmethod def from_proto ( function_type : \"quokka.pb.Quokka.Function.FunctionTypeValue\" , ) -> \"FunctionType\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . Function . TYPE_NORMAL : FunctionType . NORMAL , quokka . pb . Quokka . Function . TYPE_IMPORTED : FunctionType . IMPORTED , quokka . pb . Quokka . Function . TYPE_LIBRARY : FunctionType . LIBRARY , quokka . pb . Quokka . Function . TYPE_THUNK : FunctionType . THUNK , } return mapping . get ( function_type , FunctionType . INVALID )","title":"FunctionType"},{"location":"reference/python/types/#quokka.types.FunctionType.from_proto","text":"Convert the protobuf value into this enumeration Source code in quokka/types.py 146 147 148 149 150 151 152 153 154 155 156 157 158 @staticmethod def from_proto ( function_type : \"quokka.pb.Quokka.Function.FunctionTypeValue\" , ) -> \"FunctionType\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . Function . TYPE_NORMAL : FunctionType . NORMAL , quokka . pb . Quokka . Function . TYPE_IMPORTED : FunctionType . IMPORTED , quokka . pb . Quokka . Function . TYPE_LIBRARY : FunctionType . LIBRARY , quokka . pb . Quokka . Function . TYPE_THUNK : FunctionType . THUNK , } return mapping . get ( function_type , FunctionType . INVALID )","title":"from_proto()"},{"location":"reference/python/types/#quokka.types.ReferenceType","text":"Bases: enum . Enum Reference Type Source code in quokka/types.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 class ReferenceType ( enum . Enum ): \"\"\"Reference Type\"\"\" CALL = enum . auto () DATA = enum . auto () ENUM = enum . auto () STRUC = enum . auto () UNKNOWN = enum . auto () @staticmethod def from_proto ( reference_type : \"quokka.pb.Quokka.Reference.ReferenceTypeValue\" , ) -> \"ReferenceType\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . Reference . REF_CALL : ReferenceType . CALL , quokka . pb . Quokka . Reference . REF_DATA : ReferenceType . DATA , quokka . pb . Quokka . Reference . REF_ENUM : ReferenceType . ENUM , quokka . pb . Quokka . Reference . REF_STRUC : ReferenceType . STRUC , } return mapping . get ( reference_type , ReferenceType . UNKNOWN )","title":"ReferenceType"},{"location":"reference/python/types/#quokka.types.ReferenceType.from_proto","text":"Convert the protobuf value into this enumeration Source code in quokka/types.py 203 204 205 206 207 208 209 210 211 212 213 214 215 @staticmethod def from_proto ( reference_type : \"quokka.pb.Quokka.Reference.ReferenceTypeValue\" , ) -> \"ReferenceType\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . Reference . REF_CALL : ReferenceType . CALL , quokka . pb . Quokka . Reference . REF_DATA : ReferenceType . DATA , quokka . pb . Quokka . Reference . REF_ENUM : ReferenceType . ENUM , quokka . pb . Quokka . Reference . REF_STRUC : ReferenceType . STRUC , } return mapping . get ( reference_type , ReferenceType . UNKNOWN )","title":"from_proto()"},{"location":"reference/python/types/#quokka.types.SegmentType","text":"Bases: enum . Enum Segment Type Source code in quokka/types.py 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 class SegmentType ( enum . Enum ): \"\"\"Segment Type\"\"\" UNKNOWN = enum . auto () CODE = enum . auto () DATA = enum . auto () BSS = enum . auto () NULL = enum . auto () EXTERN = enum . auto () NORMAL = enum . auto () ABSOLUTE_SYMBOLS = enum . auto () @staticmethod def from_proto ( segment_type : \"quokka.pb.Quokka.Segment.TypeValue\" , ) -> \"SegmentType\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . Segment . SEGMENT_CODE : SegmentType . CODE , quokka . pb . Quokka . Segment . SEGMENT_DATA : SegmentType . DATA , quokka . pb . Quokka . Segment . SEGMENT_BSS : SegmentType . BSS , quokka . pb . Quokka . Segment . SEGMENT_NULL : SegmentType . NULL , quokka . pb . Quokka . Segment . SEGMENT_NORMAL : SegmentType . NORMAL , quokka . pb . Quokka . Segment . SEGMENT_EXTERN : SegmentType . EXTERN , quokka . pb . Quokka . Segment . SEGMENT_ABSOLUTE_SYMBOLS : SegmentType . ABSOLUTE_SYMBOLS , } return mapping . get ( segment_type , SegmentType . UNKNOWN )","title":"SegmentType"},{"location":"reference/python/types/#quokka.types.SegmentType.from_proto","text":"Convert the protobuf value into this enumeration Source code in quokka/types.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 @staticmethod def from_proto ( segment_type : \"quokka.pb.Quokka.Segment.TypeValue\" , ) -> \"SegmentType\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . Segment . SEGMENT_CODE : SegmentType . CODE , quokka . pb . Quokka . Segment . SEGMENT_DATA : SegmentType . DATA , quokka . pb . Quokka . Segment . SEGMENT_BSS : SegmentType . BSS , quokka . pb . Quokka . Segment . SEGMENT_NULL : SegmentType . NULL , quokka . pb . Quokka . Segment . SEGMENT_NORMAL : SegmentType . NORMAL , quokka . pb . Quokka . Segment . SEGMENT_EXTERN : SegmentType . EXTERN , quokka . pb . Quokka . Segment . SEGMENT_ABSOLUTE_SYMBOLS : SegmentType . ABSOLUTE_SYMBOLS , } return mapping . get ( segment_type , SegmentType . UNKNOWN )","title":"from_proto()"},{"location":"reference/python/types/#quokka.types.StructureType","text":"Bases: enum . Enum Structure Type Source code in quokka/types.py 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 class StructureType ( enum . Enum ): \"\"\"Structure Type\"\"\" STRUCT = enum . auto () ENUM = enum . auto () UNION = enum . auto () UNKNOWN = enum . auto () @staticmethod def from_proto ( structure_type : \"quokka.pb.Quokka.Structure.StructureTypeValue\" , ) -> \"StructureType\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . Structure . TYPE_STRUCT : StructureType . STRUCT , quokka . pb . Quokka . Structure . TYPE_ENUM : StructureType . ENUM , quokka . pb . Quokka . Structure . TYPE_UNION : StructureType . UNION , } return mapping . get ( structure_type , StructureType . UNKNOWN )","title":"StructureType"},{"location":"reference/python/types/#quokka.types.StructureType.from_proto","text":"Convert the protobuf value into this enumeration Source code in quokka/types.py 292 293 294 295 296 297 298 299 300 301 302 303 @staticmethod def from_proto ( structure_type : \"quokka.pb.Quokka.Structure.StructureTypeValue\" , ) -> \"StructureType\" : \"\"\"Convert the protobuf value into this enumeration\"\"\" mapping = { quokka . pb . Quokka . Structure . TYPE_STRUCT : StructureType . STRUCT , quokka . pb . Quokka . Structure . TYPE_ENUM : StructureType . ENUM , quokka . pb . Quokka . Structure . TYPE_UNION : StructureType . UNION , } return mapping . get ( structure_type , StructureType . UNKNOWN )","title":"from_proto()"},{"location":"reference/python/utils/","text":"Utilities functions check_hash ( hash_proto , file_path ) Check if the hash is valid This method computes the appropriate hash based on what is available in the export file and compare them. Parameters: Name Type Description Default hash_proto quokka . pb . Quokka . Meta . Hash Protobuf message containing the hash required file_path pathlib . Path Path to the binary required Returns: Type Description bool Boolean for success Source code in quokka/utils.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def check_hash ( hash_proto : quokka . pb . Quokka . Meta . Hash , file_path : pathlib . Path ) -> bool : \"\"\"Check if the hash is valid This method computes the appropriate hash based on what is available in the export file and compare them. Arguments: hash_proto: Protobuf message containing the hash file_path: Path to the binary Returns: Boolean for success \"\"\" hash_methods = { quokka . pb . Quokka . Meta . Hash . HASH_MD5 : md5_file , quokka . pb . Quokka . Meta . Hash . HASH_SHA256 : sha256_file , } hash_method = hash_methods . get ( hash_proto . hash_type ) if hash_method is None : logger . info ( \"Failed to verify hash for file because no hash was provided.\" ) return True file_hash = hash_method ( file_path ) return file_hash == hash_proto . hash_value convert_address_size ( proto_address_size ) Convert the proto address size to an int value Parameters: Name Type Description Default proto_address_size AddressSizeValue Protobuf field required Returns: Type Description int An integer value Raises: Type Description ValueError When the address size is not known Source code in quokka/utils.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def convert_address_size ( proto_address_size : \"quokka.pb.Quokka.AddressSizeValue\" , ) -> int : \"\"\"Convert the proto address size to an int value Arguments: proto_address_size: Protobuf field Returns: An integer value Raises: ValueError: When the address size is not known \"\"\" if proto_address_size == quokka . pb . Quokka . ADDR_32 : return 32 if proto_address_size == quokka . pb . Quokka . ADDR_64 : return 64 raise ValueError ( \"Address size not known\" ) get_arch ( isa , address_size , is_thumb = False ) cached Convert an isa to an arch. Parameters: Name Type Description Default isa ArchEnum Instruction set required address_size int Address size required is_thumb bool Is it thumb mode? False Returns: Type Description Type [ QuokkaArch ] A QuokkaArch Source code in quokka/utils.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 @functools . lru_cache ( maxsize = 2 , typed = True ) def get_arch ( isa : ArchEnum , address_size : int , is_thumb : bool = False ) -> Type [ \"QuokkaArch\" ]: \"\"\"Convert an isa to an arch. Arguments: isa: Instruction set address_size: Address size is_thumb: Is it thumb mode? Returns: A QuokkaArch \"\"\" mapping = { ArchEnum . ARM : { 32 : ArchARM , 64 : ArchARM64 , }, ArchEnum . X86 : { 32 : ArchX86 , 64 : ArchX64 , }, } platform_arch = mapping . get ( isa ) if platform_arch is None : return QuokkaArch arch = platform_arch . get ( address_size , QuokkaArch ) if arch == ArchARM and is_thumb : arch = ArchARMThumb return arch get_isa ( proto_isa ) Convert a proto isa to an architecture Source code in quokka/utils.py 85 86 87 88 89 90 91 92 93 94 95 96 def get_isa ( proto_isa : \"quokka.pb.Quokka.Meta.ISAValue\" , ) -> ArchEnum : \"\"\"Convert a proto isa to an architecture\"\"\" mapping = { quokka . pb . Quokka . Meta . PROC_INTEL : ArchEnum . X86 , quokka . pb . Quokka . Meta . PROC_ARM : ArchEnum . ARM , quokka . pb . Quokka . Meta . PROC_PPC : ArchEnum . PPC , quokka . pb . Quokka . Meta . PROC_MIPS : ArchEnum . MIPS , } return mapping . get ( proto_isa , ArchEnum . UNKNOWN ) md5_file ( file_path ) Compute the MD5 of a file Source code in quokka/utils.py 38 39 40 41 42 43 44 45 def md5_file ( file_path : pathlib . Path ) -> str : \"\"\"Compute the MD5 of a file\"\"\" md5 = hashlib . md5 () with open ( file_path . as_posix (), \"rb\" ) as fd : for byte in iter ( lambda : fd . read ( 65535 ), b \"\" ): md5 . update ( byte ) return md5 . hexdigest () sha256_file ( file_path ) Compute the SHA-256 of a file Source code in quokka/utils.py 48 49 50 51 52 53 54 55 def sha256_file ( file_path : pathlib . Path ) -> str : \"\"\"Compute the SHA-256 of a file\"\"\" sha = hashlib . sha256 () with open ( file_path . as_posix (), \"rb\" ) as fd : for byte in iter ( lambda : fd . read ( 65535 ), b \"\" ): sha . update ( byte ) return sha . hexdigest ()","title":"utils"},{"location":"reference/python/utils/#quokka.utils.check_hash","text":"Check if the hash is valid This method computes the appropriate hash based on what is available in the export file and compare them. Parameters: Name Type Description Default hash_proto quokka . pb . Quokka . Meta . Hash Protobuf message containing the hash required file_path pathlib . Path Path to the binary required Returns: Type Description bool Boolean for success Source code in quokka/utils.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def check_hash ( hash_proto : quokka . pb . Quokka . Meta . Hash , file_path : pathlib . Path ) -> bool : \"\"\"Check if the hash is valid This method computes the appropriate hash based on what is available in the export file and compare them. Arguments: hash_proto: Protobuf message containing the hash file_path: Path to the binary Returns: Boolean for success \"\"\" hash_methods = { quokka . pb . Quokka . Meta . Hash . HASH_MD5 : md5_file , quokka . pb . Quokka . Meta . Hash . HASH_SHA256 : sha256_file , } hash_method = hash_methods . get ( hash_proto . hash_type ) if hash_method is None : logger . info ( \"Failed to verify hash for file because no hash was provided.\" ) return True file_hash = hash_method ( file_path ) return file_hash == hash_proto . hash_value","title":"check_hash()"},{"location":"reference/python/utils/#quokka.utils.convert_address_size","text":"Convert the proto address size to an int value Parameters: Name Type Description Default proto_address_size AddressSizeValue Protobuf field required Returns: Type Description int An integer value Raises: Type Description ValueError When the address size is not known Source code in quokka/utils.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def convert_address_size ( proto_address_size : \"quokka.pb.Quokka.AddressSizeValue\" , ) -> int : \"\"\"Convert the proto address size to an int value Arguments: proto_address_size: Protobuf field Returns: An integer value Raises: ValueError: When the address size is not known \"\"\" if proto_address_size == quokka . pb . Quokka . ADDR_32 : return 32 if proto_address_size == quokka . pb . Quokka . ADDR_64 : return 64 raise ValueError ( \"Address size not known\" )","title":"convert_address_size()"},{"location":"reference/python/utils/#quokka.utils.get_arch","text":"Convert an isa to an arch. Parameters: Name Type Description Default isa ArchEnum Instruction set required address_size int Address size required is_thumb bool Is it thumb mode? False Returns: Type Description Type [ QuokkaArch ] A QuokkaArch Source code in quokka/utils.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 @functools . lru_cache ( maxsize = 2 , typed = True ) def get_arch ( isa : ArchEnum , address_size : int , is_thumb : bool = False ) -> Type [ \"QuokkaArch\" ]: \"\"\"Convert an isa to an arch. Arguments: isa: Instruction set address_size: Address size is_thumb: Is it thumb mode? Returns: A QuokkaArch \"\"\" mapping = { ArchEnum . ARM : { 32 : ArchARM , 64 : ArchARM64 , }, ArchEnum . X86 : { 32 : ArchX86 , 64 : ArchX64 , }, } platform_arch = mapping . get ( isa ) if platform_arch is None : return QuokkaArch arch = platform_arch . get ( address_size , QuokkaArch ) if arch == ArchARM and is_thumb : arch = ArchARMThumb return arch","title":"get_arch()"},{"location":"reference/python/utils/#quokka.utils.get_isa","text":"Convert a proto isa to an architecture Source code in quokka/utils.py 85 86 87 88 89 90 91 92 93 94 95 96 def get_isa ( proto_isa : \"quokka.pb.Quokka.Meta.ISAValue\" , ) -> ArchEnum : \"\"\"Convert a proto isa to an architecture\"\"\" mapping = { quokka . pb . Quokka . Meta . PROC_INTEL : ArchEnum . X86 , quokka . pb . Quokka . Meta . PROC_ARM : ArchEnum . ARM , quokka . pb . Quokka . Meta . PROC_PPC : ArchEnum . PPC , quokka . pb . Quokka . Meta . PROC_MIPS : ArchEnum . MIPS , } return mapping . get ( proto_isa , ArchEnum . UNKNOWN )","title":"get_isa()"},{"location":"reference/python/utils/#quokka.utils.md5_file","text":"Compute the MD5 of a file Source code in quokka/utils.py 38 39 40 41 42 43 44 45 def md5_file ( file_path : pathlib . Path ) -> str : \"\"\"Compute the MD5 of a file\"\"\" md5 = hashlib . md5 () with open ( file_path . as_posix (), \"rb\" ) as fd : for byte in iter ( lambda : fd . read ( 65535 ), b \"\" ): md5 . update ( byte ) return md5 . hexdigest ()","title":"md5_file()"},{"location":"reference/python/utils/#quokka.utils.sha256_file","text":"Compute the SHA-256 of a file Source code in quokka/utils.py 48 49 50 51 52 53 54 55 def sha256_file ( file_path : pathlib . Path ) -> str : \"\"\"Compute the SHA-256 of a file\"\"\" sha = hashlib . sha256 () with open ( file_path . as_posix (), \"rb\" ) as fd : for byte in iter ( lambda : fd . read ( 65535 ), b \"\" ): sha . update ( byte ) return sha . hexdigest ()","title":"sha256_file()"},{"location":"reference/python/analysis/arch/","text":"Architecture module ArchARM Bases: QuokkaArch ArchARM definition Source code in quokka/analysis/arch.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 class ArchARM ( QuokkaArch ): # type: ignore \"\"\"ArchARM definition\"\"\" ( cc , cpsflag , cpsmode , grps , insts , mb , op , regs , setend , sft , sysreg , vd , ) = make_enums ( capstone_module = capstone . arm_const , items = [ \"CC\" , \"CPSFLAG\" , \"CPSMODE\" , \"GRP\" , \"INS\" , \"MB\" , \"OP\" , \"REG\" , \"SETEND\" , \"SFT\" , \"SYSREG\" , \"VECTORDATA\" , ], blacklist = [ \"ENDING\" , \"R13\" , \"R14\" , \"R15\" , \"R9\" , \"R10\" , \"R11\" , \"R12\" ], flags_enums = [ \"SYSREG\" ], ) address_size = 32 compared_mnemonics = [ insts . CBNZ , insts . CMP , insts . CBZ , insts . CMN , ] frame_pointer = regs . FP stack_pointer = regs . SP inst_pointer = regs . PC ArchARM64 Bases: QuokkaArch Arch Arm64 definition Source code in quokka/analysis/arch.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 class ArchARM64 ( QuokkaArch ): # type: ignore \"\"\"Arch Arm64 definition\"\"\" ( at , barrier , cc , dc , ext , grp , ic , insts , op , prfm , pstate , regs , sft , sysreg , tlbi , vas , vess , ) = make_enums ( capstone_module = capstone . arm64_const , items = [ \"AT\" , \"BARRIER\" , \"CC\" , \"DC\" , \"EXT\" , \"GRP\" , \"IC\" , \"INS\" , \"OP\" , \"PRFM\" , \"PSTATE\" , \"REG\" , \"SFT\" , \"SYSREG\" , \"TLBI\" , \"VAS\" , \"VESS\" , ], blacklist = [ \"ENDING\" , \"X16\" , \"X17\" , \"X29\" , \"X30\" ], flags_enums = [], ) address_size = 64 compared_mnemonics = [ insts . CBZ , insts . CBNZ , insts . CMP , insts . CCMN , insts . CCMP , insts . CMN , insts . TBZ , insts . TBNZ , ] frame_pointer = regs . FP stack_pointer = regs . SP # TODO(dm)! inst_pointer = regs . X28 ArchARMThumb Bases: ArchARM Arch Arm Thum definition Source code in quokka/analysis/arch.py 165 166 167 168 class ArchARMThumb ( ArchARM ): # type: ignore \"\"\"Arch Arm Thum definition\"\"\" thumb : bool = True ArchEnum Bases: IntEnum Enum identifying various architectures. The integer values are based on capstone enum. Source code in quokka/analysis/arch.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class ArchEnum ( IntEnum ): \"\"\" Enum identifying various architectures. The integer values are based on capstone enum. \"\"\" UNKNOWN = capstone . CS_ARCH_ALL ARM = capstone . CS_ARCH_ARM ARM64 = capstone . CS_ARCH_ARM64 EVM = capstone . CS_ARCH_EVM M680X = capstone . CS_ARCH_M680X M68K = capstone . CS_ARCH_M68K MIPS = capstone . CS_ARCH_MIPS PPC = capstone . CS_ARCH_PPC SPARC = capstone . CS_ARCH_SPARC SYSZ = capstone . CS_ARCH_SYSZ TMS320C64X = capstone . CS_ARCH_TMS320C64X X86 = capstone . CS_ARCH_X86 XCORE = capstone . CS_ARCH_XCORE ArchX64 Bases: ArchX86 Arch X64 definition Source code in quokka/analysis/arch.py 106 107 108 109 110 111 112 113 class ArchX64 ( ArchX86 ): # type: ignore \"\"\"Arch X64 definition\"\"\" address_size = 64 frame_pointer = ArchX86 . regs . RBP stack_pointer = ArchX86 . regs . RSP inst_pointer = ArchX86 . regs . RIP ArchX86 Bases: QuokkaArch Arch X86 definition Source code in quokka/analysis/arch.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class ArchX86 ( QuokkaArch ): # type: ignore \"\"\"Arch X86 definition\"\"\" address_size = 32 regs , insts , groups , prefixes , optypes , _flags_state = make_enums ( capstone_module = capstone . x86_const , items = [ \"REG\" , \"INS\" , \"GRP\" , \"PREFIX\" , \"OP\" , \"EFLAGS\" ], blacklist = [ \"ENDING\" ], flags_enums = [ \"EFLAGS\" ], ) compared_mnemonics = [ insts . CMP , insts . TEST ] frame_pointer = regs . EBP stack_pointer = regs . ESP inst_pointer = regs . EIP QuokkaArch Base class for a QuokkaArch Source code in quokka/analysis/arch.py 78 79 80 81 82 83 84 class QuokkaArch : \"\"\"Base class for a QuokkaArch\"\"\" address_size : int compared_mnemonics : List [ str ] stack_pointer : RegType inst_pointer : RegType make_enums ( capstone_module , items , blacklist , flags_enums ) Make enums from capstone module Dynamically generate enums from capstone constants 0 Parameters: Name Type Description Default capstone_module ModuleType Capstone module required items List [ str ] Name of enums required blacklist List [ str ] Fields to not consider required flags_enums List [ str ] List of flag enums required Returns: Type Description List A list of IntEnum/IntFlag Source code in quokka/analysis/arch.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def make_enums ( capstone_module : ModuleType , items : List [ str ], blacklist : List [ str ], flags_enums : List [ str ] ) -> List : \"\"\"Make enums from capstone module Dynamically generate enums from capstone constants 0 Arguments: capstone_module: Capstone module items: Name of enums blacklist: Fields to not consider flags_enums: List of flag enums Returns: A list of IntEnum/IntFlag \"\"\" data = collections . defaultdict ( dict ) for key , val in getattr ( capstone_module , \"__dict__\" ) . items (): _ , cat , name = key . split ( \"_\" , maxsplit = 2 ) if name not in blacklist : name = \"_\" + name if \"0\" <= name [ 0 ] <= \"9\" else name data [ cat ][ name ] = val return [ IntEnum ( x , names = data [ x ], module = __name__ ) if x not in flags_enums else IntFlag ( x , names = data [ x ], module = __name__ ) for x in items if x ]","title":"arch"},{"location":"reference/python/analysis/arch/#quokka.analysis.arch.ArchARM","text":"Bases: QuokkaArch ArchARM definition Source code in quokka/analysis/arch.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 class ArchARM ( QuokkaArch ): # type: ignore \"\"\"ArchARM definition\"\"\" ( cc , cpsflag , cpsmode , grps , insts , mb , op , regs , setend , sft , sysreg , vd , ) = make_enums ( capstone_module = capstone . arm_const , items = [ \"CC\" , \"CPSFLAG\" , \"CPSMODE\" , \"GRP\" , \"INS\" , \"MB\" , \"OP\" , \"REG\" , \"SETEND\" , \"SFT\" , \"SYSREG\" , \"VECTORDATA\" , ], blacklist = [ \"ENDING\" , \"R13\" , \"R14\" , \"R15\" , \"R9\" , \"R10\" , \"R11\" , \"R12\" ], flags_enums = [ \"SYSREG\" ], ) address_size = 32 compared_mnemonics = [ insts . CBNZ , insts . CMP , insts . CBZ , insts . CMN , ] frame_pointer = regs . FP stack_pointer = regs . SP inst_pointer = regs . PC","title":"ArchARM"},{"location":"reference/python/analysis/arch/#quokka.analysis.arch.ArchARM64","text":"Bases: QuokkaArch Arch Arm64 definition Source code in quokka/analysis/arch.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 class ArchARM64 ( QuokkaArch ): # type: ignore \"\"\"Arch Arm64 definition\"\"\" ( at , barrier , cc , dc , ext , grp , ic , insts , op , prfm , pstate , regs , sft , sysreg , tlbi , vas , vess , ) = make_enums ( capstone_module = capstone . arm64_const , items = [ \"AT\" , \"BARRIER\" , \"CC\" , \"DC\" , \"EXT\" , \"GRP\" , \"IC\" , \"INS\" , \"OP\" , \"PRFM\" , \"PSTATE\" , \"REG\" , \"SFT\" , \"SYSREG\" , \"TLBI\" , \"VAS\" , \"VESS\" , ], blacklist = [ \"ENDING\" , \"X16\" , \"X17\" , \"X29\" , \"X30\" ], flags_enums = [], ) address_size = 64 compared_mnemonics = [ insts . CBZ , insts . CBNZ , insts . CMP , insts . CCMN , insts . CCMP , insts . CMN , insts . TBZ , insts . TBNZ , ] frame_pointer = regs . FP stack_pointer = regs . SP # TODO(dm)! inst_pointer = regs . X28","title":"ArchARM64"},{"location":"reference/python/analysis/arch/#quokka.analysis.arch.ArchARMThumb","text":"Bases: ArchARM Arch Arm Thum definition Source code in quokka/analysis/arch.py 165 166 167 168 class ArchARMThumb ( ArchARM ): # type: ignore \"\"\"Arch Arm Thum definition\"\"\" thumb : bool = True","title":"ArchARMThumb"},{"location":"reference/python/analysis/arch/#quokka.analysis.arch.ArchEnum","text":"Bases: IntEnum Enum identifying various architectures. The integer values are based on capstone enum. Source code in quokka/analysis/arch.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class ArchEnum ( IntEnum ): \"\"\" Enum identifying various architectures. The integer values are based on capstone enum. \"\"\" UNKNOWN = capstone . CS_ARCH_ALL ARM = capstone . CS_ARCH_ARM ARM64 = capstone . CS_ARCH_ARM64 EVM = capstone . CS_ARCH_EVM M680X = capstone . CS_ARCH_M680X M68K = capstone . CS_ARCH_M68K MIPS = capstone . CS_ARCH_MIPS PPC = capstone . CS_ARCH_PPC SPARC = capstone . CS_ARCH_SPARC SYSZ = capstone . CS_ARCH_SYSZ TMS320C64X = capstone . CS_ARCH_TMS320C64X X86 = capstone . CS_ARCH_X86 XCORE = capstone . CS_ARCH_XCORE","title":"ArchEnum"},{"location":"reference/python/analysis/arch/#quokka.analysis.arch.ArchX64","text":"Bases: ArchX86 Arch X64 definition Source code in quokka/analysis/arch.py 106 107 108 109 110 111 112 113 class ArchX64 ( ArchX86 ): # type: ignore \"\"\"Arch X64 definition\"\"\" address_size = 64 frame_pointer = ArchX86 . regs . RBP stack_pointer = ArchX86 . regs . RSP inst_pointer = ArchX86 . regs . RIP","title":"ArchX64"},{"location":"reference/python/analysis/arch/#quokka.analysis.arch.ArchX86","text":"Bases: QuokkaArch Arch X86 definition Source code in quokka/analysis/arch.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class ArchX86 ( QuokkaArch ): # type: ignore \"\"\"Arch X86 definition\"\"\" address_size = 32 regs , insts , groups , prefixes , optypes , _flags_state = make_enums ( capstone_module = capstone . x86_const , items = [ \"REG\" , \"INS\" , \"GRP\" , \"PREFIX\" , \"OP\" , \"EFLAGS\" ], blacklist = [ \"ENDING\" ], flags_enums = [ \"EFLAGS\" ], ) compared_mnemonics = [ insts . CMP , insts . TEST ] frame_pointer = regs . EBP stack_pointer = regs . ESP inst_pointer = regs . EIP","title":"ArchX86"},{"location":"reference/python/analysis/arch/#quokka.analysis.arch.QuokkaArch","text":"Base class for a QuokkaArch Source code in quokka/analysis/arch.py 78 79 80 81 82 83 84 class QuokkaArch : \"\"\"Base class for a QuokkaArch\"\"\" address_size : int compared_mnemonics : List [ str ] stack_pointer : RegType inst_pointer : RegType","title":"QuokkaArch"},{"location":"reference/python/analysis/arch/#quokka.analysis.arch.make_enums","text":"Make enums from capstone module Dynamically generate enums from capstone constants 0 Parameters: Name Type Description Default capstone_module ModuleType Capstone module required items List [ str ] Name of enums required blacklist List [ str ] Fields to not consider required flags_enums List [ str ] List of flag enums required Returns: Type Description List A list of IntEnum/IntFlag Source code in quokka/analysis/arch.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def make_enums ( capstone_module : ModuleType , items : List [ str ], blacklist : List [ str ], flags_enums : List [ str ] ) -> List : \"\"\"Make enums from capstone module Dynamically generate enums from capstone constants 0 Arguments: capstone_module: Capstone module items: Name of enums blacklist: Fields to not consider flags_enums: List of flag enums Returns: A list of IntEnum/IntFlag \"\"\" data = collections . defaultdict ( dict ) for key , val in getattr ( capstone_module , \"__dict__\" ) . items (): _ , cat , name = key . split ( \"_\" , maxsplit = 2 ) if name not in blacklist : name = \"_\" + name if \"0\" <= name [ 0 ] <= \"9\" else name data [ cat ][ name ] = val return [ IntEnum ( x , names = data [ x ], module = __name__ ) if x not in flags_enums else IntFlag ( x , names = data [ x ], module = __name__ ) for x in items if x ]","title":"make_enums()"},{"location":"reference/python/analysis/calling_convention/","text":"Calling conventions ARM64CC Bases: CallingConvention AAPCS calling convention for Aarch64 Source code in quokka/analysis/calling_convention.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 class ARM64CC ( CallingConvention ): \"\"\"AAPCS calling convention for Aarch64\"\"\" name = \"aapcs\" argument_registers = [ ArchARM64 . regs . X0 , ArchARM64 . regs . X1 , ArchARM64 . regs . X2 , ArchARM64 . regs . X3 , ArchARM64 . regs . X4 , ArchARM64 . regs . X5 , ArchARM64 . regs . X6 , ArchARM64 . regs . X7 , ] floating_point_registers : List [ RegType ] = [] # TODO caller_saved_registers : List [ RegType ] = [] return_value = ArchARM64 . regs . X0 ARMCC Bases: CallingConvention AAPCS calling convention for ARM Source code in quokka/analysis/calling_convention.py 132 133 134 135 136 137 138 139 140 141 142 143 144 class ARMCC ( CallingConvention ): \"\"\"AAPCS calling convention for ARM\"\"\" name = \"aapcs\" argument_registers = [ ArchARM . regs . R0 , ArchARM . regs . R1 , ArchARM . regs . R2 , ArchARM . regs . R3 , ] floating_point_registers : List [ RegType ] = [] # TODO caller_saved_registers : List [ RegType ] = [] return_value = ArchARM . regs . R0 CCdecl Bases: CallingConvention Cdecl calling convention Source code in quokka/analysis/calling_convention.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class CCdecl ( CallingConvention ): \"\"\"Cdecl calling convention\"\"\" name = \"cdecl\" argument_registers : List [ RegType ] = [] # All arguments are on the stack floating_point_registers : List [ RegType ] = [] # Same caller_saved_registers = [ ArchX86 . regs . EAX , ArchX86 . regs . ECX , ArchX86 . regs . EDX , ] return_value = ArchX86 . regs . EAX overflow_return = ArchX86 . regs . EDX CallingConvention Base class for a calling convention Source code in quokka/analysis/calling_convention.py 23 24 25 26 27 28 29 30 31 32 33 class CallingConvention : \"\"\"Base class for a calling convention\"\"\" name : str argument_registers : List [ RegType ] floating_point_registers : List [ RegType ] caller_saved_registers : List [ RegType ] callee_saved : bool = False return_value : RegType overflow_return : RegType Fastcall Bases: CallingConvention Fastcall calling convention Source code in quokka/analysis/calling_convention.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class Fastcall ( CallingConvention ): \"\"\"Fastcall calling convention\"\"\" name = \"fastcall\" argument_registers = [ ArchX86 . regs . ECX , ArchX86 . regs . EDX ] floating_point_registers = [ ArchX86 . regs . ST0 , ArchX86 . regs . ST1 ] # TODO(dm) check caller_saved_registers = [ ArchX86 . regs . EBX , ArchX86 . regs . EBX , ArchX86 . regs . ESI , ArchX86 . regs . EDI , ] return_value = ArchX86 . regs . EAX overflow_return = ArchX86 . regs . EDX MicrosoftAMD64 Bases: CallingConvention Microsoft 64 calling convention Source code in quokka/analysis/calling_convention.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 class MicrosoftAMD64 ( CallingConvention ): \"\"\"Microsoft 64 calling convention\"\"\" name = \"ms\" argument_registers = [ ArchX64 . regs . RCX , ArchX64 . regs . RDX , ArchX64 . regs . R8 , ArchX64 . regs . R9 , ] floating_point_registers = [ ArchX64 . regs . XMM0 , ArchX64 . regs . XMM1 , ArchX64 . regs . XMM2 , ArchX64 . regs . XMM3 , ] return_value = ArchX64 . regs . RAX overflow_return = ArchX64 . regs . RDX Stdcall Bases: CCdecl Stdcall calling convention Source code in quokka/analysis/calling_convention.py 52 53 54 55 56 class Stdcall ( CCdecl ): \"\"\"Stdcall calling convention\"\"\" name = \"stdcall\" callee_saved = True SystemVAMD Bases: CallingConvention SysV calling convention Source code in quokka/analysis/calling_convention.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 class SystemVAMD ( CallingConvention ): \"\"\"SysV calling convention\"\"\" name = \"sysv\" argument_registers = [ ArchX64 . regs . RDI , ArchX64 . regs . RSI , ArchX64 . regs . RDX , ArchX64 . regs . RCX , ArchX64 . regs . R8 , ArchX64 . regs . R9 , ] floating_point_registers = [ ArchX64 . regs . XMM0 , ArchX64 . regs . XMM1 , ArchX64 . regs . XMM2 , ArchX64 . regs . XMM3 , ArchX64 . regs . XMM4 , ArchX64 . regs . XMM5 , ArchX64 . regs . XMM6 , ArchX64 . regs . XMM7 , ] caller_saved_registers = argument_registers + [ ArchX64 . regs . R10 , ArchX64 . regs . R11 , ArchX64 . regs . RAX , ] return_value = ArchX64 . regs . RAX overflow_return = ArchX64 . regs . RDX","title":"calling_convention"},{"location":"reference/python/analysis/calling_convention/#quokka.analysis.calling_convention.ARM64CC","text":"Bases: CallingConvention AAPCS calling convention for Aarch64 Source code in quokka/analysis/calling_convention.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 class ARM64CC ( CallingConvention ): \"\"\"AAPCS calling convention for Aarch64\"\"\" name = \"aapcs\" argument_registers = [ ArchARM64 . regs . X0 , ArchARM64 . regs . X1 , ArchARM64 . regs . X2 , ArchARM64 . regs . X3 , ArchARM64 . regs . X4 , ArchARM64 . regs . X5 , ArchARM64 . regs . X6 , ArchARM64 . regs . X7 , ] floating_point_registers : List [ RegType ] = [] # TODO caller_saved_registers : List [ RegType ] = [] return_value = ArchARM64 . regs . X0","title":"ARM64CC"},{"location":"reference/python/analysis/calling_convention/#quokka.analysis.calling_convention.ARMCC","text":"Bases: CallingConvention AAPCS calling convention for ARM Source code in quokka/analysis/calling_convention.py 132 133 134 135 136 137 138 139 140 141 142 143 144 class ARMCC ( CallingConvention ): \"\"\"AAPCS calling convention for ARM\"\"\" name = \"aapcs\" argument_registers = [ ArchARM . regs . R0 , ArchARM . regs . R1 , ArchARM . regs . R2 , ArchARM . regs . R3 , ] floating_point_registers : List [ RegType ] = [] # TODO caller_saved_registers : List [ RegType ] = [] return_value = ArchARM . regs . R0","title":"ARMCC"},{"location":"reference/python/analysis/calling_convention/#quokka.analysis.calling_convention.CCdecl","text":"Bases: CallingConvention Cdecl calling convention Source code in quokka/analysis/calling_convention.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class CCdecl ( CallingConvention ): \"\"\"Cdecl calling convention\"\"\" name = \"cdecl\" argument_registers : List [ RegType ] = [] # All arguments are on the stack floating_point_registers : List [ RegType ] = [] # Same caller_saved_registers = [ ArchX86 . regs . EAX , ArchX86 . regs . ECX , ArchX86 . regs . EDX , ] return_value = ArchX86 . regs . EAX overflow_return = ArchX86 . regs . EDX","title":"CCdecl"},{"location":"reference/python/analysis/calling_convention/#quokka.analysis.calling_convention.CallingConvention","text":"Base class for a calling convention Source code in quokka/analysis/calling_convention.py 23 24 25 26 27 28 29 30 31 32 33 class CallingConvention : \"\"\"Base class for a calling convention\"\"\" name : str argument_registers : List [ RegType ] floating_point_registers : List [ RegType ] caller_saved_registers : List [ RegType ] callee_saved : bool = False return_value : RegType overflow_return : RegType","title":"CallingConvention"},{"location":"reference/python/analysis/calling_convention/#quokka.analysis.calling_convention.Fastcall","text":"Bases: CallingConvention Fastcall calling convention Source code in quokka/analysis/calling_convention.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class Fastcall ( CallingConvention ): \"\"\"Fastcall calling convention\"\"\" name = \"fastcall\" argument_registers = [ ArchX86 . regs . ECX , ArchX86 . regs . EDX ] floating_point_registers = [ ArchX86 . regs . ST0 , ArchX86 . regs . ST1 ] # TODO(dm) check caller_saved_registers = [ ArchX86 . regs . EBX , ArchX86 . regs . EBX , ArchX86 . regs . ESI , ArchX86 . regs . EDI , ] return_value = ArchX86 . regs . EAX overflow_return = ArchX86 . regs . EDX","title":"Fastcall"},{"location":"reference/python/analysis/calling_convention/#quokka.analysis.calling_convention.MicrosoftAMD64","text":"Bases: CallingConvention Microsoft 64 calling convention Source code in quokka/analysis/calling_convention.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 class MicrosoftAMD64 ( CallingConvention ): \"\"\"Microsoft 64 calling convention\"\"\" name = \"ms\" argument_registers = [ ArchX64 . regs . RCX , ArchX64 . regs . RDX , ArchX64 . regs . R8 , ArchX64 . regs . R9 , ] floating_point_registers = [ ArchX64 . regs . XMM0 , ArchX64 . regs . XMM1 , ArchX64 . regs . XMM2 , ArchX64 . regs . XMM3 , ] return_value = ArchX64 . regs . RAX overflow_return = ArchX64 . regs . RDX","title":"MicrosoftAMD64"},{"location":"reference/python/analysis/calling_convention/#quokka.analysis.calling_convention.Stdcall","text":"Bases: CCdecl Stdcall calling convention Source code in quokka/analysis/calling_convention.py 52 53 54 55 56 class Stdcall ( CCdecl ): \"\"\"Stdcall calling convention\"\"\" name = \"stdcall\" callee_saved = True","title":"Stdcall"},{"location":"reference/python/analysis/calling_convention/#quokka.analysis.calling_convention.SystemVAMD","text":"Bases: CallingConvention SysV calling convention Source code in quokka/analysis/calling_convention.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 class SystemVAMD ( CallingConvention ): \"\"\"SysV calling convention\"\"\" name = \"sysv\" argument_registers = [ ArchX64 . regs . RDI , ArchX64 . regs . RSI , ArchX64 . regs . RDX , ArchX64 . regs . RCX , ArchX64 . regs . R8 , ArchX64 . regs . R9 , ] floating_point_registers = [ ArchX64 . regs . XMM0 , ArchX64 . regs . XMM1 , ArchX64 . regs . XMM2 , ArchX64 . regs . XMM3 , ArchX64 . regs . XMM4 , ArchX64 . regs . XMM5 , ArchX64 . regs . XMM6 , ArchX64 . regs . XMM7 , ] caller_saved_registers = argument_registers + [ ArchX64 . regs . R10 , ArchX64 . regs . R11 , ArchX64 . regs . RAX , ] return_value = ArchX64 . regs . RAX overflow_return = ArchX64 . regs . RDX","title":"SystemVAMD"},{"location":"reference/python/analysis/env/","text":"Environment module Environment Environment base class Parameters: Name Type Description Default platform quokka . analysis . Platform Platform required arch Type [ quokka . analysis . arch . QuokkaArch ] Architecture required Attributes: Name Type Description platform quokka . analysis . Platform Platform arch Type [ quokka . analysis . arch . QuokkaArch ] Architecture calling_convention Type [ cc . CallingConvention ] Calling convention Source code in quokka/analysis/env.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 class Environment : \"\"\"Environment base class Args: platform: Platform arch: Architecture Attributes: platform: Platform arch: Architecture calling_convention: Calling convention \"\"\" def __init__ ( self , platform : quokka . analysis . Platform , arch : Type [ quokka . analysis . arch . QuokkaArch ], ): \"\"\"Constructor\"\"\" self . platform : quokka . analysis . Platform = platform self . arch : Type [ quokka . analysis . arch . QuokkaArch ] = arch self . calling_convention : Type [ cc . CallingConvention ] = get_calling_convention_for_arch_platform ( platform , arch ) __init__ ( platform , arch ) Constructor Source code in quokka/analysis/env.py 77 78 79 80 81 82 83 84 85 86 87 def __init__ ( self , platform : quokka . analysis . Platform , arch : Type [ quokka . analysis . arch . QuokkaArch ], ): \"\"\"Constructor\"\"\" self . platform : quokka . analysis . Platform = platform self . arch : Type [ quokka . analysis . arch . QuokkaArch ] = arch self . calling_convention : Type [ cc . CallingConvention ] = get_calling_convention_for_arch_platform ( platform , arch ) Platform Bases: enum . Enum Platform enumeration Source code in quokka/analysis/env.py 90 91 92 93 94 95 96 class Platform ( enum . Enum ): \"\"\"Platform enumeration\"\"\" UNKNOWN = enum . auto () WINDOWS = enum . auto () LINUX = enum . auto () APPLE = enum . auto () get_calling_convention_for_arch_platform ( platform , arch ) Retrieve the calling convention used for this couple platform/arch Parameters: Name Type Description Default platform quokka . analysis . Platform Used platform required arch Type [ quokka . analysis . QuokkaArch ] Used architecture required Returns: Type Description Type [ cc . CallingConvention ] A calling convention Source code in quokka/analysis/env.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def get_calling_convention_for_arch_platform ( platform : quokka . analysis . Platform , arch : Type [ quokka . analysis . QuokkaArch ], ) -> Type [ cc . CallingConvention ]: \"\"\"Retrieve the calling convention used for this couple platform/arch Arguments: platform: Used platform arch: Used architecture Returns: A calling convention \"\"\" mapping = { quokka . analysis . Platform . LINUX : { ArchX64 : cc . SystemVAMD , # Must be before x86 ArchX86 : cc . CCdecl , ArchARM : cc . ARMCC , ArchARM64 : cc . ARM64CC , }, quokka . analysis . Platform . WINDOWS : { ArchX86 : cc . Stdcall , ArchX64 : cc . MicrosoftAMD64 , }, } platform_mapping = mapping . get ( platform ) if platform_mapping is None : return cc . CallingConvention for architecture , convention in platform_mapping . items (): if issubclass ( arch , architecture ): return convention return cc . CallingConvention","title":"env"},{"location":"reference/python/analysis/env/#quokka.analysis.env.Environment","text":"Environment base class Parameters: Name Type Description Default platform quokka . analysis . Platform Platform required arch Type [ quokka . analysis . arch . QuokkaArch ] Architecture required Attributes: Name Type Description platform quokka . analysis . Platform Platform arch Type [ quokka . analysis . arch . QuokkaArch ] Architecture calling_convention Type [ cc . CallingConvention ] Calling convention Source code in quokka/analysis/env.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 class Environment : \"\"\"Environment base class Args: platform: Platform arch: Architecture Attributes: platform: Platform arch: Architecture calling_convention: Calling convention \"\"\" def __init__ ( self , platform : quokka . analysis . Platform , arch : Type [ quokka . analysis . arch . QuokkaArch ], ): \"\"\"Constructor\"\"\" self . platform : quokka . analysis . Platform = platform self . arch : Type [ quokka . analysis . arch . QuokkaArch ] = arch self . calling_convention : Type [ cc . CallingConvention ] = get_calling_convention_for_arch_platform ( platform , arch )","title":"Environment"},{"location":"reference/python/analysis/env/#quokka.analysis.env.Environment.__init__","text":"Constructor Source code in quokka/analysis/env.py 77 78 79 80 81 82 83 84 85 86 87 def __init__ ( self , platform : quokka . analysis . Platform , arch : Type [ quokka . analysis . arch . QuokkaArch ], ): \"\"\"Constructor\"\"\" self . platform : quokka . analysis . Platform = platform self . arch : Type [ quokka . analysis . arch . QuokkaArch ] = arch self . calling_convention : Type [ cc . CallingConvention ] = get_calling_convention_for_arch_platform ( platform , arch )","title":"__init__()"},{"location":"reference/python/analysis/env/#quokka.analysis.env.Platform","text":"Bases: enum . Enum Platform enumeration Source code in quokka/analysis/env.py 90 91 92 93 94 95 96 class Platform ( enum . Enum ): \"\"\"Platform enumeration\"\"\" UNKNOWN = enum . auto () WINDOWS = enum . auto () LINUX = enum . auto () APPLE = enum . auto ()","title":"Platform"},{"location":"reference/python/analysis/env/#quokka.analysis.env.get_calling_convention_for_arch_platform","text":"Retrieve the calling convention used for this couple platform/arch Parameters: Name Type Description Default platform quokka . analysis . Platform Used platform required arch Type [ quokka . analysis . QuokkaArch ] Used architecture required Returns: Type Description Type [ cc . CallingConvention ] A calling convention Source code in quokka/analysis/env.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def get_calling_convention_for_arch_platform ( platform : quokka . analysis . Platform , arch : Type [ quokka . analysis . QuokkaArch ], ) -> Type [ cc . CallingConvention ]: \"\"\"Retrieve the calling convention used for this couple platform/arch Arguments: platform: Used platform arch: Used architecture Returns: A calling convention \"\"\" mapping = { quokka . analysis . Platform . LINUX : { ArchX64 : cc . SystemVAMD , # Must be before x86 ArchX86 : cc . CCdecl , ArchARM : cc . ARMCC , ArchARM64 : cc . ARM64CC , }, quokka . analysis . Platform . WINDOWS : { ArchX86 : cc . Stdcall , ArchX64 : cc . MicrosoftAMD64 , }, } platform_mapping = mapping . get ( platform ) if platform_mapping is None : return cc . CallingConvention for architecture , convention in platform_mapping . items (): if issubclass ( arch , architecture ): return convention return cc . CallingConvention","title":"get_calling_convention_for_arch_platform()"},{"location":"reference/python/analysis/replacer/","text":"Replacer Replacer class Warning: This class has been used in some experiments but will/should probably be removed because it does not belong to the project. Source code in quokka/analysis/replacer.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class Replacer : \"\"\"Replacer class Warning: This class has been used in some experiments but will/should probably be removed because it does not belong to the project. \"\"\" ignored_registers : List [ str ] ignored_mnemonics : List [ str ] regs : RegType compared_mnemonics : List [ str ] calling_registers : List [ RegType ] replacement : Dict [ RegType , RegType ] @staticmethod def norm_mnemonic ( mnemonic : str ) -> str : \"\"\" Norm a mnemonic (remove everything after '.'). Examples: cmp.w -> CMP mov -> MOV Arguments: mnemonic: Mnemonic to norm Returns: Normed mnemonic \"\"\" if \".\" in mnemonic : return mnemonic [: mnemonic . rfind ( \".\" )] . upper () return mnemonic . upper () def get ( self , item ) -> RegType : assert self . replacement is not None if isinstance ( item , RegType ): return self . replacement . get ( item , item ) return item def is_ignored ( self , item ) -> bool : assert self . ignored_registers is not None return self . get ( item ) in self . ignored_registers def __call__ ( self , * args : Any , ** kwargs : Any ) -> RegType : return self . get ( * args , ** kwargs ) def is_ignored_mnemonics ( self , mnemonic : str ) -> bool : assert self . ignored_mnemonics is not None return self . norm_mnemonic ( mnemonic ) in self . ignored_mnemonics def is_compared_mnemonic ( self , mnemonic : str ) -> bool : assert self . compared_mnemonics is not None return self . norm_mnemonic ( mnemonic ) in self . compared_mnemonics def calling_convention ( self ) -> List [ RegType ]: assert self . calling_registers is not None return self . calling_registers def argument_registers ( self , platform : quokka . analysis . Platform ) -> List : return [] norm_mnemonic ( mnemonic ) staticmethod Norm a mnemonic (remove everything after '.'). Examples: cmp.w -> CMP mov -> MOV Parameters: Name Type Description Default mnemonic str Mnemonic to norm required Returns: Type Description str Normed mnemonic Source code in quokka/analysis/replacer.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 @staticmethod def norm_mnemonic ( mnemonic : str ) -> str : \"\"\" Norm a mnemonic (remove everything after '.'). Examples: cmp.w -> CMP mov -> MOV Arguments: mnemonic: Mnemonic to norm Returns: Normed mnemonic \"\"\" if \".\" in mnemonic : return mnemonic [: mnemonic . rfind ( \".\" )] . upper () return mnemonic . upper ()","title":"replacer"},{"location":"reference/python/analysis/replacer/#quokka.analysis.replacer.Replacer","text":"Replacer class Warning: This class has been used in some experiments but will/should probably be removed because it does not belong to the project. Source code in quokka/analysis/replacer.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class Replacer : \"\"\"Replacer class Warning: This class has been used in some experiments but will/should probably be removed because it does not belong to the project. \"\"\" ignored_registers : List [ str ] ignored_mnemonics : List [ str ] regs : RegType compared_mnemonics : List [ str ] calling_registers : List [ RegType ] replacement : Dict [ RegType , RegType ] @staticmethod def norm_mnemonic ( mnemonic : str ) -> str : \"\"\" Norm a mnemonic (remove everything after '.'). Examples: cmp.w -> CMP mov -> MOV Arguments: mnemonic: Mnemonic to norm Returns: Normed mnemonic \"\"\" if \".\" in mnemonic : return mnemonic [: mnemonic . rfind ( \".\" )] . upper () return mnemonic . upper () def get ( self , item ) -> RegType : assert self . replacement is not None if isinstance ( item , RegType ): return self . replacement . get ( item , item ) return item def is_ignored ( self , item ) -> bool : assert self . ignored_registers is not None return self . get ( item ) in self . ignored_registers def __call__ ( self , * args : Any , ** kwargs : Any ) -> RegType : return self . get ( * args , ** kwargs ) def is_ignored_mnemonics ( self , mnemonic : str ) -> bool : assert self . ignored_mnemonics is not None return self . norm_mnemonic ( mnemonic ) in self . ignored_mnemonics def is_compared_mnemonic ( self , mnemonic : str ) -> bool : assert self . compared_mnemonics is not None return self . norm_mnemonic ( mnemonic ) in self . compared_mnemonics def calling_convention ( self ) -> List [ RegType ]: assert self . calling_registers is not None return self . calling_registers def argument_registers ( self , platform : quokka . analysis . Platform ) -> List : return []","title":"Replacer"},{"location":"reference/python/analysis/replacer/#quokka.analysis.replacer.Replacer.norm_mnemonic","text":"Norm a mnemonic (remove everything after '.'). Examples: cmp.w -> CMP mov -> MOV Parameters: Name Type Description Default mnemonic str Mnemonic to norm required Returns: Type Description str Normed mnemonic Source code in quokka/analysis/replacer.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 @staticmethod def norm_mnemonic ( mnemonic : str ) -> str : \"\"\" Norm a mnemonic (remove everything after '.'). Examples: cmp.w -> CMP mov -> MOV Arguments: mnemonic: Mnemonic to norm Returns: Normed mnemonic \"\"\" if \".\" in mnemonic : return mnemonic [: mnemonic . rfind ( \".\" )] . upper () return mnemonic . upper ()","title":"norm_mnemonic()"},{"location":"reference/python/analysis/utils/","text":"Utilities functions for the analysis split_chunk ( chunk ) Split a chunk if it is composed of multiple components. If a chunk is composed of multiple connected components, we want to split them so some analysis may be performed. Parameters: Name Type Description Default chunk quokka . Chunk A chunk to split required Returns: Type Description Union [ quokka . Chunk , quokka . SuperChunk ] Either a Chunk or a SuperChunk Source code in quokka/analysis/utils.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def split_chunk ( chunk : quokka . Chunk , ) -> Union [ quokka . Chunk , quokka . SuperChunk ]: \"\"\"Split a chunk if it is composed of multiple components. If a chunk is composed of multiple connected components, we want to split them so some analysis may be performed. Arguments: chunk: A chunk to split Returns: Either a Chunk or a SuperChunk \"\"\" components = list ( nx . connected_components ( nx . Graph ( chunk . graph ))) if len ( components ) <= 1 : return chunk return quokka . function . SuperChunk ( chunk , components )","title":"utils"},{"location":"reference/python/analysis/utils/#quokka.analysis.utils.split_chunk","text":"Split a chunk if it is composed of multiple components. If a chunk is composed of multiple connected components, we want to split them so some analysis may be performed. Parameters: Name Type Description Default chunk quokka . Chunk A chunk to split required Returns: Type Description Union [ quokka . Chunk , quokka . SuperChunk ] Either a Chunk or a SuperChunk Source code in quokka/analysis/utils.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def split_chunk ( chunk : quokka . Chunk , ) -> Union [ quokka . Chunk , quokka . SuperChunk ]: \"\"\"Split a chunk if it is composed of multiple components. If a chunk is composed of multiple connected components, we want to split them so some analysis may be performed. Arguments: chunk: A chunk to split Returns: Either a Chunk or a SuperChunk \"\"\" components = list ( nx . connected_components ( nx . Graph ( chunk . graph ))) if len ( components ) <= 1 : return chunk return quokka . function . SuperChunk ( chunk , components )","title":"split_chunk()"},{"location":"reference/python/backends/capstone/","text":"Capstone integration capstone_decode_instruction ( inst ) Decode an instruction with capstone Decode an instruction and retry for ARM to check if the Thumb mode was activated The decoding logic is done by the inner method _decode . Parameters: Name Type Description Default inst quokka . Instruction Instruction to translate required Returns: Type Description Optional [ capstone . CsInsn ] A capstone instruction if it has been decoded Source code in quokka/backends/capstone.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def capstone_decode_instruction ( inst : quokka . Instruction , ) -> Optional [ capstone . CsInsn ]: \"\"\"Decode an instruction with capstone Decode an instruction and retry for ARM to check if the Thumb mode was activated The decoding logic is done by the inner method `_decode`. Arguments: inst: Instruction to translate Returns: A capstone instruction if it has been decoded \"\"\" context : capstone . Cs = update_capstone_context ( inst . program , inst . thumb ) capstone_inst = _decode ( context , inst . bytes , inst . address , count = 1 ) if capstone_inst is None and context . arch == capstone . CS_ARCH_ARM : if context . mode == capstone . CS_MODE_THUMB : new_context = get_capstone_context ( quokka . analysis . ArchARM ) else : new_context = get_capstone_context ( quokka . analysis . ArchARMThumb ) capstone_inst = _decode ( new_context , inst . bytes , inst . address , count = 1 ) return capstone_inst get_capstone_context ( arch ) Compute the capstone context for the program The Capstone context is used to decode instructions afterwards. Since we are interested in most of the details, we already set the details to True. Parameters: Name Type Description Default arch Type [ quokka . analysis . QuokkaArch ] Quokka program architecture required Returns: Type Description capstone . Cs A capstone Cs instance Source code in quokka/backends/capstone.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def get_capstone_context ( arch : Type [ quokka . analysis . QuokkaArch ]) -> capstone . Cs : \"\"\"Compute the capstone context for the program The Capstone context is used to decode instructions afterwards. Since we are interested in most of the details, we already set the details to True. Arguments: arch: Quokka program architecture Returns: A capstone Cs instance \"\"\" mapping = { quokka . analysis . ArchARM : ( capstone . CS_ARCH_ARM , capstone . CS_MODE_ARM ), quokka . analysis . ArchARM64 : ( capstone . CS_ARCH_ARM64 , capstone . CS_MODE_ARM ), quokka . analysis . ArchX86 : ( capstone . CS_ARCH_X86 , capstone . CS_MODE_32 ), quokka . analysis . ArchX64 : ( capstone . CS_ARCH_X86 , capstone . CS_MODE_64 ), quokka . analysis . ArchARMThumb : ( capstone . CS_ARCH_ARM , capstone . CS_MODE_THUMB , ), } try : capstone_arch , capstone_mode = mapping . get ( arch ) except TypeError as exc : raise quokka . CapstoneError ( \"Unable to find the Architecture\" ) from exc context = capstone . Cs ( capstone_arch , capstone_mode ) context . detail = True return context update_capstone_context ( program , is_thumb ) Returns an appropriate context for Capstone instructions For ARM architecture, if the instruction is Thumb, we must use a different context. Parameters: Name Type Description Default program quokka . Program Program to consider required is_thumb bool Is the instruction a thumb one? required Returns: Type Description capstone . Cs The correct capstone context Source code in quokka/backends/capstone.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def update_capstone_context ( program : quokka . Program , is_thumb : bool ) -> capstone . Cs : \"\"\"Returns an appropriate context for Capstone instructions For ARM architecture, if the instruction is Thumb, we must use a different context. Arguments: program: Program to consider is_thumb: Is the instruction a thumb one? Returns: The correct capstone context \"\"\" if ( program . arch in ( quokka . analysis . ArchARM , quokka . analysis . ArchARM64 , quokka . analysis . ArchARMThumb , ) and is_thumb ): return get_capstone_context ( quokka . analysis . ArchARMThumb ) return program . capstone","title":"capstone"},{"location":"reference/python/backends/capstone/#quokka.backends.capstone.capstone_decode_instruction","text":"Decode an instruction with capstone Decode an instruction and retry for ARM to check if the Thumb mode was activated The decoding logic is done by the inner method _decode . Parameters: Name Type Description Default inst quokka . Instruction Instruction to translate required Returns: Type Description Optional [ capstone . CsInsn ] A capstone instruction if it has been decoded Source code in quokka/backends/capstone.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def capstone_decode_instruction ( inst : quokka . Instruction , ) -> Optional [ capstone . CsInsn ]: \"\"\"Decode an instruction with capstone Decode an instruction and retry for ARM to check if the Thumb mode was activated The decoding logic is done by the inner method `_decode`. Arguments: inst: Instruction to translate Returns: A capstone instruction if it has been decoded \"\"\" context : capstone . Cs = update_capstone_context ( inst . program , inst . thumb ) capstone_inst = _decode ( context , inst . bytes , inst . address , count = 1 ) if capstone_inst is None and context . arch == capstone . CS_ARCH_ARM : if context . mode == capstone . CS_MODE_THUMB : new_context = get_capstone_context ( quokka . analysis . ArchARM ) else : new_context = get_capstone_context ( quokka . analysis . ArchARMThumb ) capstone_inst = _decode ( new_context , inst . bytes , inst . address , count = 1 ) return capstone_inst","title":"capstone_decode_instruction()"},{"location":"reference/python/backends/capstone/#quokka.backends.capstone.get_capstone_context","text":"Compute the capstone context for the program The Capstone context is used to decode instructions afterwards. Since we are interested in most of the details, we already set the details to True. Parameters: Name Type Description Default arch Type [ quokka . analysis . QuokkaArch ] Quokka program architecture required Returns: Type Description capstone . Cs A capstone Cs instance Source code in quokka/backends/capstone.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def get_capstone_context ( arch : Type [ quokka . analysis . QuokkaArch ]) -> capstone . Cs : \"\"\"Compute the capstone context for the program The Capstone context is used to decode instructions afterwards. Since we are interested in most of the details, we already set the details to True. Arguments: arch: Quokka program architecture Returns: A capstone Cs instance \"\"\" mapping = { quokka . analysis . ArchARM : ( capstone . CS_ARCH_ARM , capstone . CS_MODE_ARM ), quokka . analysis . ArchARM64 : ( capstone . CS_ARCH_ARM64 , capstone . CS_MODE_ARM ), quokka . analysis . ArchX86 : ( capstone . CS_ARCH_X86 , capstone . CS_MODE_32 ), quokka . analysis . ArchX64 : ( capstone . CS_ARCH_X86 , capstone . CS_MODE_64 ), quokka . analysis . ArchARMThumb : ( capstone . CS_ARCH_ARM , capstone . CS_MODE_THUMB , ), } try : capstone_arch , capstone_mode = mapping . get ( arch ) except TypeError as exc : raise quokka . CapstoneError ( \"Unable to find the Architecture\" ) from exc context = capstone . Cs ( capstone_arch , capstone_mode ) context . detail = True return context","title":"get_capstone_context()"},{"location":"reference/python/backends/capstone/#quokka.backends.capstone.update_capstone_context","text":"Returns an appropriate context for Capstone instructions For ARM architecture, if the instruction is Thumb, we must use a different context. Parameters: Name Type Description Default program quokka . Program Program to consider required is_thumb bool Is the instruction a thumb one? required Returns: Type Description capstone . Cs The correct capstone context Source code in quokka/backends/capstone.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def update_capstone_context ( program : quokka . Program , is_thumb : bool ) -> capstone . Cs : \"\"\"Returns an appropriate context for Capstone instructions For ARM architecture, if the instruction is Thumb, we must use a different context. Arguments: program: Program to consider is_thumb: Is the instruction a thumb one? Returns: The correct capstone context \"\"\" if ( program . arch in ( quokka . analysis . ArchARM , quokka . analysis . ArchARM64 , quokka . analysis . ArchARMThumb , ) and is_thumb ): return get_capstone_context ( quokka . analysis . ArchARMThumb ) return program . capstone","title":"update_capstone_context()"},{"location":"reference/python/backends/pypcode/","text":"PyPCode integration combine_instructions ( block , translated_instructions ) Combine instructions between the Quokka and PyPcode Some instruction are split between IDA and Ghidra, so we have to account for it. A problem for example is the support of prefixes (such LOCK) which are decoded as 2 instructions by Ghidra (wrong) but only 1 by IDA (correct). Parameters: Name Type Description Default block quokka . Block Quokka block required translated_instructions Sequence [ pypcode . Translation ] Translated instructions by Pypcode required Raises PypcodeError: if the combination doesn't work Returns: Type Description List [ pypcode . PcodeOp ] A list of Pypcode statements Source code in quokka/backends/pypcode.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def combine_instructions ( block : quokka . Block , translated_instructions : Sequence [ pypcode . Translation ] ) -> List [ pypcode . PcodeOp ]: \"\"\"Combine instructions between the Quokka and PyPcode Some instruction are split between IDA and Ghidra, so we have to account for it. A problem for example is the support of prefixes (such LOCK) which are decoded as 2 instructions by Ghidra (wrong) but only 1 by IDA (correct). Arguments: block: Quokka block translated_instructions: Translated instructions by Pypcode Raises PypcodeError: if the combination doesn't work Returns: A list of Pypcode statements \"\"\" pcode_instructions : List [ pypcode . PcodeOp ] = [] translated_instructions = iter ( translated_instructions ) instruction : quokka . Instruction for instruction in block . instructions : instruction . _pcode_insts = [] remaining_size : int = instruction . size while remaining_size > 0 : try : pcode_inst : pypcode . Translation = next ( translated_instructions ) except StopIteration as exc : logger . error ( \"Disassembly discrepancy between Pypcode / IDA: missing inst\" ) raise quokka . PypcodeError ( f \"Decoding error for block at 0x { block . start : x } \" ) from exc remaining_size -= pcode_inst . length instruction . _pcode_insts . extend ( pcode_inst . ops ) if remaining_size < 0 : logger . error ( \"Disassembly discrepancy between Pypcode / IDA: sizes mismatch\" ) raise quokka . PypcodeError ( f \"Decoding error for block at 0x { block . start : x } \" ) pcode_instructions . extend ( list ( pcode_inst . ops )) return pcode_instructions equality ( self , other ) Check if two pypcode objets are the same We use monkey patching to attach the equality method to other classes and rely on slots to check which fields to check. Parameters: Name Type Description Default self pypcode . ContextObj First object required other Any Other variable required Returns: Type Description bool Boolean for equality Source code in quokka/backends/pypcode.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def equality ( self : pypcode . ContextObj , other : Any ) -> bool : \"\"\"Check if two pypcode objets are the same We use monkey patching to attach the equality method to other classes and rely on __slots__ to check which fields to check. Arguments: self: First object other: Other variable Returns: Boolean for equality \"\"\" return isinstance ( other , self . __class__ ) and all ( getattr ( other , attr ) == getattr ( self , attr ) for attr in self . __slots__ if attr != \"cobj\" ) get_arch_from_string ( target_id ) Find the architecture for an arch based on the target identification Parameters: Name Type Description Default target_id str Identifier of the architecture required Raises: Type Description PypcodeError if the architecture is not found Returns: Type Description pypcode . ArchLanguage The appropriate ArchLang Source code in quokka/backends/pypcode.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def get_arch_from_string ( target_id : str ) -> pypcode . ArchLanguage : \"\"\"Find the architecture for an arch based on the target identification Arguments: target_id: Identifier of the architecture Raises: PypcodeError: if the architecture is not found Returns: The appropriate ArchLang \"\"\" pcode_arch : pypcode . Arch for pcode_arch in pypcode . Arch . enumerate (): for lang in pcode_arch . languages : if lang . id == target_id : return lang raise quokka . PypcodeError ( \"Unable to find the appropriate arch: missing lang\" ) get_pypcode_context ( arch ) Convert an arch from Quokka to Pypcode For the moment, only the arch described in quokka.analysis are supported. This method is a bit slow because enum are generated by pypcode on the fly but should be executed only once. Parameters: Name Type Description Default arch Type [ quokka . analysis . QuokkaArch ] Quokka program architecture required Raises: Type Description PypcodeError if the conversion for arch is not found Returns: Type Description pypcode . Context A pypcode.Context instance Source code in quokka/backends/pypcode.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def get_pypcode_context ( arch : Type [ quokka . analysis . QuokkaArch ], ) -> pypcode . Context : \"\"\"Convert an arch from Quokka to Pypcode For the moment, only the arch described in quokka.analysis are supported. This method is a bit slow because enum are generated by pypcode on the fly but should be executed only once. Arguments: arch: Quokka program architecture Raises: PypcodeError: if the conversion for arch is not found Returns: A pypcode.Context instance \"\"\" names : Dict [ Type [ quokka . analysis . arch . QuokkaArch ], str ] = { quokka . analysis . ArchX64 : \"x86:LE:64:default\" , quokka . analysis . ArchX86 : \"x86:LE:32:default\" , quokka . analysis . ArchARM : \"ARM:LE:32:v8\" , quokka . analysis . ArchARM64 : \"AARCH64:LE:64:v8A\" , quokka . analysis . ArchARMThumb : \"ARM:LE:32:v8T\" , } try : target_id = names [ arch ] except KeyError as exc : raise quokka . PypcodeError ( \"Unable to find the appropriate arch: missing id\" ) from exc pcode_arch = get_arch_from_string ( target_id ) return pypcode . Context ( pcode_arch ) object_hash ( obj ) Create a hash value for a pypcode object This allows to create set of values. Parameters: Name Type Description Default obj pypcode . ContextObj Object to hash required Returns: Type Description int An integer for the hash Source code in quokka/backends/pypcode.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def object_hash ( obj : pypcode . ContextObj ) -> int : \"\"\"Create a hash value for a pypcode object This allows to create set of values. Arguments: obj: Object to hash Returns: An integer for the hash \"\"\" assert isinstance ( obj , pypcode . ContextObj ) return sum ( hash ( getattr ( obj , attr )) for attr in obj . __slots__ if attr != \"cobj\" ) pypcode_decode_block ( block ) Decode a block at once. This method decode a block of instructions using Pypcode context all at once. This is faster than multiple calls to the decode at the instruction level. Parameters: Name Type Description Default block quokka . Block Block to decode required Returns: Type Description List [ pypcode . PcodeOp ] A list of pcode operations Source code in quokka/backends/pypcode.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def pypcode_decode_block ( block : quokka . Block ) -> List [ pypcode . PcodeOp ]: \"\"\"Decode a block at once. This method decode a block of instructions using Pypcode context all at once. This is faster than multiple calls to the decode at the instruction level. Arguments: block: Block to decode Returns: A list of pcode operations \"\"\" # Fast guard, empty blocks do not have any Pcode operations first_instruction : Optional [ quokka . Instruction ] = next ( block . instructions , None ) if first_instruction is None : return [] # Retrieve the context from the instruction context : pypcode . Context = update_pypcode_context ( block . program , first_instruction . thumb ) # Translate translation = context . translate ( code = block . bytes , base = block . start , max_inst = 0 , ) if translation . error : logger . error ( translation . error . explain ) raise quokka . PypcodeError ( f \"Decoding error for block at 0x { block . start : x } \" ) pcode_instructions = combine_instructions ( block , translation . instructions ) return pcode_instructions pypcode_decode_instruction ( inst ) Decode an instruction using Pypcode This will return the list of Pcode operations done for the instruction. Note that a (binary) instruction is expected to have several pcode instructions associated. Parameters: Name Type Description Default inst quokka . Instruction Instruction to translate required Raises: Type Description PypcodeError if the decoding fails Returns: Type Description Sequence [ pypcode . PcodeOp ] A sequence of PcodeOp Source code in quokka/backends/pypcode.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 def pypcode_decode_instruction ( inst : quokka . Instruction , ) -> Sequence [ pypcode . PcodeOp ]: \"\"\"Decode an instruction using Pypcode This will return the list of Pcode operations done for the instruction. Note that a (binary) instruction is expected to have several pcode instructions associated. Arguments: inst: Instruction to translate Raises: PypcodeError: if the decoding fails Returns: A sequence of PcodeOp \"\"\" context : pypcode . Context = update_pypcode_context ( inst . program , inst . thumb ) translation = context . translate ( code = inst . bytes , base = inst . address , max_inst = 1 , ) if not translation . error : instructions = translation . instructions if len ( instructions ) > 1 : logger . warning ( \"Mismatch of instruction size IDA/Pypcode\" ) instructions = list ( itertools . chain . from_iterable ( inst . ops for inst in instructions ) ) return instructions logger . error ( translation . error . explain ) raise quokka . PypcodeError ( \"Unable to decode instruction\" ) update_pypcode_context ( program , is_thumb ) Return an appropriate pypcode context for the decoding For ARM architecture, if the block starts with a Thumb instruction, we must use a different pypcode Context. We use the boolean is_thumb directly to allow caching of the call here because it is costly to generate the context. Parameters: Name Type Description Default program quokka . Program Program to consider required is_thumb bool Is the instruction a thumb one? required Returns: Type Description pypcode . Context The correct pypcode context Source code in quokka/backends/pypcode.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 def update_pypcode_context ( program : quokka . Program , is_thumb : bool ) -> pypcode . Context : \"\"\"Return an appropriate pypcode context for the decoding For ARM architecture, if the block starts with a Thumb instruction, we must use a different pypcode Context. We use the boolean `is_thumb` directly to allow caching of the call here because it is costly to generate the context. Arguments: program: Program to consider is_thumb: Is the instruction a thumb one? Returns: The correct pypcode context \"\"\" if ( program . arch in ( quokka . analysis . ArchARM , quokka . analysis . ArchARM64 , quokka . analysis . ArchARMThumb , ) and is_thumb ): return get_pypcode_context ( quokka . analysis . ArchARMThumb ) return program . pypcode","title":"pypcode"},{"location":"reference/python/backends/pypcode/#quokka.backends.pypcode.combine_instructions","text":"Combine instructions between the Quokka and PyPcode Some instruction are split between IDA and Ghidra, so we have to account for it. A problem for example is the support of prefixes (such LOCK) which are decoded as 2 instructions by Ghidra (wrong) but only 1 by IDA (correct). Parameters: Name Type Description Default block quokka . Block Quokka block required translated_instructions Sequence [ pypcode . Translation ] Translated instructions by Pypcode required Raises PypcodeError: if the combination doesn't work Returns: Type Description List [ pypcode . PcodeOp ] A list of Pypcode statements Source code in quokka/backends/pypcode.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def combine_instructions ( block : quokka . Block , translated_instructions : Sequence [ pypcode . Translation ] ) -> List [ pypcode . PcodeOp ]: \"\"\"Combine instructions between the Quokka and PyPcode Some instruction are split between IDA and Ghidra, so we have to account for it. A problem for example is the support of prefixes (such LOCK) which are decoded as 2 instructions by Ghidra (wrong) but only 1 by IDA (correct). Arguments: block: Quokka block translated_instructions: Translated instructions by Pypcode Raises PypcodeError: if the combination doesn't work Returns: A list of Pypcode statements \"\"\" pcode_instructions : List [ pypcode . PcodeOp ] = [] translated_instructions = iter ( translated_instructions ) instruction : quokka . Instruction for instruction in block . instructions : instruction . _pcode_insts = [] remaining_size : int = instruction . size while remaining_size > 0 : try : pcode_inst : pypcode . Translation = next ( translated_instructions ) except StopIteration as exc : logger . error ( \"Disassembly discrepancy between Pypcode / IDA: missing inst\" ) raise quokka . PypcodeError ( f \"Decoding error for block at 0x { block . start : x } \" ) from exc remaining_size -= pcode_inst . length instruction . _pcode_insts . extend ( pcode_inst . ops ) if remaining_size < 0 : logger . error ( \"Disassembly discrepancy between Pypcode / IDA: sizes mismatch\" ) raise quokka . PypcodeError ( f \"Decoding error for block at 0x { block . start : x } \" ) pcode_instructions . extend ( list ( pcode_inst . ops )) return pcode_instructions","title":"combine_instructions()"},{"location":"reference/python/backends/pypcode/#quokka.backends.pypcode.equality","text":"Check if two pypcode objets are the same We use monkey patching to attach the equality method to other classes and rely on slots to check which fields to check. Parameters: Name Type Description Default self pypcode . ContextObj First object required other Any Other variable required Returns: Type Description bool Boolean for equality Source code in quokka/backends/pypcode.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def equality ( self : pypcode . ContextObj , other : Any ) -> bool : \"\"\"Check if two pypcode objets are the same We use monkey patching to attach the equality method to other classes and rely on __slots__ to check which fields to check. Arguments: self: First object other: Other variable Returns: Boolean for equality \"\"\" return isinstance ( other , self . __class__ ) and all ( getattr ( other , attr ) == getattr ( self , attr ) for attr in self . __slots__ if attr != \"cobj\" )","title":"equality()"},{"location":"reference/python/backends/pypcode/#quokka.backends.pypcode.get_arch_from_string","text":"Find the architecture for an arch based on the target identification Parameters: Name Type Description Default target_id str Identifier of the architecture required Raises: Type Description PypcodeError if the architecture is not found Returns: Type Description pypcode . ArchLanguage The appropriate ArchLang Source code in quokka/backends/pypcode.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def get_arch_from_string ( target_id : str ) -> pypcode . ArchLanguage : \"\"\"Find the architecture for an arch based on the target identification Arguments: target_id: Identifier of the architecture Raises: PypcodeError: if the architecture is not found Returns: The appropriate ArchLang \"\"\" pcode_arch : pypcode . Arch for pcode_arch in pypcode . Arch . enumerate (): for lang in pcode_arch . languages : if lang . id == target_id : return lang raise quokka . PypcodeError ( \"Unable to find the appropriate arch: missing lang\" )","title":"get_arch_from_string()"},{"location":"reference/python/backends/pypcode/#quokka.backends.pypcode.get_pypcode_context","text":"Convert an arch from Quokka to Pypcode For the moment, only the arch described in quokka.analysis are supported. This method is a bit slow because enum are generated by pypcode on the fly but should be executed only once. Parameters: Name Type Description Default arch Type [ quokka . analysis . QuokkaArch ] Quokka program architecture required Raises: Type Description PypcodeError if the conversion for arch is not found Returns: Type Description pypcode . Context A pypcode.Context instance Source code in quokka/backends/pypcode.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def get_pypcode_context ( arch : Type [ quokka . analysis . QuokkaArch ], ) -> pypcode . Context : \"\"\"Convert an arch from Quokka to Pypcode For the moment, only the arch described in quokka.analysis are supported. This method is a bit slow because enum are generated by pypcode on the fly but should be executed only once. Arguments: arch: Quokka program architecture Raises: PypcodeError: if the conversion for arch is not found Returns: A pypcode.Context instance \"\"\" names : Dict [ Type [ quokka . analysis . arch . QuokkaArch ], str ] = { quokka . analysis . ArchX64 : \"x86:LE:64:default\" , quokka . analysis . ArchX86 : \"x86:LE:32:default\" , quokka . analysis . ArchARM : \"ARM:LE:32:v8\" , quokka . analysis . ArchARM64 : \"AARCH64:LE:64:v8A\" , quokka . analysis . ArchARMThumb : \"ARM:LE:32:v8T\" , } try : target_id = names [ arch ] except KeyError as exc : raise quokka . PypcodeError ( \"Unable to find the appropriate arch: missing id\" ) from exc pcode_arch = get_arch_from_string ( target_id ) return pypcode . Context ( pcode_arch )","title":"get_pypcode_context()"},{"location":"reference/python/backends/pypcode/#quokka.backends.pypcode.object_hash","text":"Create a hash value for a pypcode object This allows to create set of values. Parameters: Name Type Description Default obj pypcode . ContextObj Object to hash required Returns: Type Description int An integer for the hash Source code in quokka/backends/pypcode.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def object_hash ( obj : pypcode . ContextObj ) -> int : \"\"\"Create a hash value for a pypcode object This allows to create set of values. Arguments: obj: Object to hash Returns: An integer for the hash \"\"\" assert isinstance ( obj , pypcode . ContextObj ) return sum ( hash ( getattr ( obj , attr )) for attr in obj . __slots__ if attr != \"cobj\" )","title":"object_hash()"},{"location":"reference/python/backends/pypcode/#quokka.backends.pypcode.pypcode_decode_block","text":"Decode a block at once. This method decode a block of instructions using Pypcode context all at once. This is faster than multiple calls to the decode at the instruction level. Parameters: Name Type Description Default block quokka . Block Block to decode required Returns: Type Description List [ pypcode . PcodeOp ] A list of pcode operations Source code in quokka/backends/pypcode.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def pypcode_decode_block ( block : quokka . Block ) -> List [ pypcode . PcodeOp ]: \"\"\"Decode a block at once. This method decode a block of instructions using Pypcode context all at once. This is faster than multiple calls to the decode at the instruction level. Arguments: block: Block to decode Returns: A list of pcode operations \"\"\" # Fast guard, empty blocks do not have any Pcode operations first_instruction : Optional [ quokka . Instruction ] = next ( block . instructions , None ) if first_instruction is None : return [] # Retrieve the context from the instruction context : pypcode . Context = update_pypcode_context ( block . program , first_instruction . thumb ) # Translate translation = context . translate ( code = block . bytes , base = block . start , max_inst = 0 , ) if translation . error : logger . error ( translation . error . explain ) raise quokka . PypcodeError ( f \"Decoding error for block at 0x { block . start : x } \" ) pcode_instructions = combine_instructions ( block , translation . instructions ) return pcode_instructions","title":"pypcode_decode_block()"},{"location":"reference/python/backends/pypcode/#quokka.backends.pypcode.pypcode_decode_instruction","text":"Decode an instruction using Pypcode This will return the list of Pcode operations done for the instruction. Note that a (binary) instruction is expected to have several pcode instructions associated. Parameters: Name Type Description Default inst quokka . Instruction Instruction to translate required Raises: Type Description PypcodeError if the decoding fails Returns: Type Description Sequence [ pypcode . PcodeOp ] A sequence of PcodeOp Source code in quokka/backends/pypcode.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 def pypcode_decode_instruction ( inst : quokka . Instruction , ) -> Sequence [ pypcode . PcodeOp ]: \"\"\"Decode an instruction using Pypcode This will return the list of Pcode operations done for the instruction. Note that a (binary) instruction is expected to have several pcode instructions associated. Arguments: inst: Instruction to translate Raises: PypcodeError: if the decoding fails Returns: A sequence of PcodeOp \"\"\" context : pypcode . Context = update_pypcode_context ( inst . program , inst . thumb ) translation = context . translate ( code = inst . bytes , base = inst . address , max_inst = 1 , ) if not translation . error : instructions = translation . instructions if len ( instructions ) > 1 : logger . warning ( \"Mismatch of instruction size IDA/Pypcode\" ) instructions = list ( itertools . chain . from_iterable ( inst . ops for inst in instructions ) ) return instructions logger . error ( translation . error . explain ) raise quokka . PypcodeError ( \"Unable to decode instruction\" )","title":"pypcode_decode_instruction()"},{"location":"reference/python/backends/pypcode/#quokka.backends.pypcode.update_pypcode_context","text":"Return an appropriate pypcode context for the decoding For ARM architecture, if the block starts with a Thumb instruction, we must use a different pypcode Context. We use the boolean is_thumb directly to allow caching of the call here because it is costly to generate the context. Parameters: Name Type Description Default program quokka . Program Program to consider required is_thumb bool Is the instruction a thumb one? required Returns: Type Description pypcode . Context The correct pypcode context Source code in quokka/backends/pypcode.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 def update_pypcode_context ( program : quokka . Program , is_thumb : bool ) -> pypcode . Context : \"\"\"Return an appropriate pypcode context for the decoding For ARM architecture, if the block starts with a Thumb instruction, we must use a different pypcode Context. We use the boolean `is_thumb` directly to allow caching of the call here because it is costly to generate the context. Arguments: program: Program to consider is_thumb: Is the instruction a thumb one? Returns: The correct pypcode context \"\"\" if ( program . arch in ( quokka . analysis . ArchARM , quokka . analysis . ArchARM64 , quokka . analysis . ArchARMThumb , ) and is_thumb ): return get_pypcode_context ( quokka . analysis . ArchARMThumb ) return program . pypcode","title":"update_pypcode_context()"},{"location":"tutorials/bionic/SUMMARY/","text":"Introduction Strategy Final","title":"SUMMARY"},{"location":"tutorials/bionic/final/","text":"Final words The final script looks like this # Copyright 2022 Quarkslab # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # https://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. \"\"\"BIONIC User ID extractor This snippet uses Quokka to extract the user ID mapping from a Bionic LibC Usage: python ./script <bionic_path> Author: Written by dm (Alexis Challande) in 2022. \"\"\" import quokka from quokka import Data from quokka.types import AddressT , DataType def print_usertable ( bionic : quokka . Program ): \"\"\"Extract the user table with a bionic libc\"\"\" # Step1 : Find the function getpwuid = bionic . get_function ( \"getpwuid\" , approximative = False ) # Step 2: find the data ref user_table : Data = getpwuid . data_references [ 1 ] # Step 3: Read the first entry users = [] first_user = bionic . executable . read_string ( user_table . value ) first_id = bionic . get_data ( user_table . address + 0x4 ) . value users . append (( first_user , first_id )) # Read other entries def read_userid ( prog : quokka . Program , address : AddressT ) -> int : return prog . executable . read_data ( prog . addresser . file ( address ), DataType . DOUBLE_WORD ) # Gather all components together start = user_table . address + 0x8 while True : data : Data = bionic . get_data ( start ) if data . code_references : break user_name = bionic . executable . read_string ( data . value ) user_id = read_userid ( bionic , data . address + 0x4 ) print ( f \"New user { user_name } with ID { user_id } \" ) users . append (( user_name , user_id )) start += 0x8 # Print the user table for user_name , user_id in users : print ( f \" { user_name =} : { user_id =} \" ) if __name__ == \"__main__\" : program : quokka . Program = quokka . Program . from_binary ( sys . argv [ 1 ]) print_usertable ( program )","title":"Final"},{"location":"tutorials/bionic/final/#final-words","text":"The final script looks like this # Copyright 2022 Quarkslab # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # https://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. \"\"\"BIONIC User ID extractor This snippet uses Quokka to extract the user ID mapping from a Bionic LibC Usage: python ./script <bionic_path> Author: Written by dm (Alexis Challande) in 2022. \"\"\" import quokka from quokka import Data from quokka.types import AddressT , DataType def print_usertable ( bionic : quokka . Program ): \"\"\"Extract the user table with a bionic libc\"\"\" # Step1 : Find the function getpwuid = bionic . get_function ( \"getpwuid\" , approximative = False ) # Step 2: find the data ref user_table : Data = getpwuid . data_references [ 1 ] # Step 3: Read the first entry users = [] first_user = bionic . executable . read_string ( user_table . value ) first_id = bionic . get_data ( user_table . address + 0x4 ) . value users . append (( first_user , first_id )) # Read other entries def read_userid ( prog : quokka . Program , address : AddressT ) -> int : return prog . executable . read_data ( prog . addresser . file ( address ), DataType . DOUBLE_WORD ) # Gather all components together start = user_table . address + 0x8 while True : data : Data = bionic . get_data ( start ) if data . code_references : break user_name = bionic . executable . read_string ( data . value ) user_id = read_userid ( bionic , data . address + 0x4 ) print ( f \"New user { user_name } with ID { user_id } \" ) users . append (( user_name , user_id )) start += 0x8 # Print the user table for user_name , user_id in users : print ( f \" { user_name =} : { user_id =} \" ) if __name__ == \"__main__\" : program : quokka . Program = quokka . Program . from_binary ( sys . argv [ 1 ]) print_usertable ( program )","title":"Final words"},{"location":"tutorials/bionic/introduction/","text":"Bionic in Android In this tutorial, we will learn how to extract the user mapping in the Android libc: Bionic . Context Android, the mobile operating system, uses a custom libc : bionic . A few notable changes exist from the classic implementation of the libc found on most desktop Linux systems. One of them is that the user table is embedded within the binary. Objective Automatically extract the user mapping from the binary 1 . Requirements A working Quokka Installation The bionic library ( sha256sum: 5975c8366fce5e47ccdf80f5d01f3e4521fee3b1dcf719243f4e4236d9699443 ) An export of the bionic library Check requirements import quokka bionic = quokka . Program ( \"libc.quokka\" , \"libc.so\" ) assert bionic is not None Final words Once you are set, we can advance to the next steps. This exercise is based on an idea from Robin David in his IDA scripting training. \u21a9","title":"Introduction"},{"location":"tutorials/bionic/introduction/#bionic-in-android","text":"In this tutorial, we will learn how to extract the user mapping in the Android libc: Bionic .","title":"Bionic in Android"},{"location":"tutorials/bionic/introduction/#context","text":"Android, the mobile operating system, uses a custom libc : bionic . A few notable changes exist from the classic implementation of the libc found on most desktop Linux systems. One of them is that the user table is embedded within the binary.","title":"Context"},{"location":"tutorials/bionic/introduction/#objective","text":"Automatically extract the user mapping from the binary 1 .","title":"Objective"},{"location":"tutorials/bionic/introduction/#requirements","text":"A working Quokka Installation The bionic library ( sha256sum: 5975c8366fce5e47ccdf80f5d01f3e4521fee3b1dcf719243f4e4236d9699443 ) An export of the bionic library","title":"Requirements"},{"location":"tutorials/bionic/introduction/#check-requirements","text":"import quokka bionic = quokka . Program ( \"libc.quokka\" , \"libc.so\" ) assert bionic is not None","title":"Check requirements"},{"location":"tutorials/bionic/introduction/#final-words","text":"Once you are set, we can advance to the next steps. This exercise is based on an idea from Robin David in his IDA scripting training. \u21a9","title":"Final words"},{"location":"tutorials/bionic/strategy/","text":"Strategy Before diving within Quokka, let's try to understand how we could solve the problem on paper. Steps Identify a function using the user table Find a data reference to the table Identify the table boundaries Read one entry Repeat until the end of the table Step 1: Identify a function using the user table For this, we have no choice but to read the manual. The getpwuid function is a good candidate, look at the manual below: The getpwuid() function returns a pointer to a structure containing the broken-out fields of the record in the password database that matches the user ID uid. Lets select the function: # WARNING: Not working from quokka import Function function : Function = bionic . get_function ( \"getpwuid\" ) assert function . name == \"getpwuid\" # Raises an error The previous snippet generates an error. Indeed, the function selected is not getpwuid but j_getpwuid . However, the signature of the get_function method has an additional parameter: Program . get_function ( name : 'str' , approximative : 'bool' = True , normal : 'bool' = False ) -> 'quokka.Function' Thus, the correct code to select the getpwuid function is: getpwuid : Function = bionic . get_function ( \"getpwuid\" , approximative = False ) assert getpwuid . name == \"getpwuid\" # Correct Step 2: Find the data reference to the table We know that the getpwuid functions must use the user mapping we are searching. So, a (data) reference towards the table must exist within the function. Lets explore them: for data in getpwuid . data_references : print ( f \" { data . name } ( { data . type } ) at 0x { data . address : x } \" ) None ( DataType.DOUBLE_WORD ) at 0x1d024 _ZL11android_ids ( DataType.DOUBLE_WORD ) at 0x8cda0 _ZL11android_ids ( DataType.DOUBLE_WORD ) at 0x8cda0 None ( DataType.DOUBLE_WORD ) at 0x8cda4 So the second and third reference in the function are towards the table we are looking for! Let's find the beginning of our user table: from quokka import Data user_table : Data = getpwuid . data_references [ 1 ] print ( f \" { user_table . address =: x } \" ) # user_table.address=8cda0 Step 3: Identify the table boundaries For this step, we are going to use an heuristic: * We know that the user table is contiguous in memory * We know that there are no code-references to the middle of the table So we are going to iterate the memory, starting at the first entry until an element as a code reference pointing towards it. To find if an element has a code reference, there is a convenient accessor: data = bionic . get_data ( address ) assert data . code_references != [], \"Has code references\" So our loop to iterate until the end of the table will look like this: from quokka.types import AddressT address : AddressT while True : data = bionic . get_data ( address ) if data . code_references : break ... Step 4: Read one entry The structure of the table is as followed: struct android_id_info { const char name [ 17 ]; unsigned aid ; }; To read this with Quokka: # Start with the first entry, using the read_string method user_name = bionic . executable . read_string ( user_table . value ) # cameraserver And read the user ID too: it will be on the next DWORD: first_id = bionic . get_data ( user_table . address + 0x4 ) . value # 1047 However, the snippet above works only if IDA found the data in the program. Otherwise, it will fail with the following error: ValueError: No data at offset 0x8cdbc Another solution is to write this helper script: from quokka import Program from quokka.types import AddressT , DataType def read_userid ( prog : Program , address : AddressT ) -> int : \"\"\"Read an user ID within the program at `address`\"\"\" return prog . executable . read_data ( prog . addresser . file ( address ), DataType . DOUBLE_WORD ) Step 5: Repeat until the end of the table Now, we have every component of our script, let put it together within a loop: from quokka.types import AddressT start : AddressT = user_table . address + 0x8 while True : data = bionic . get_data ( start ) if data . code_references : break user_name = bionic . executable . read_string ( data . value ) user_id = read_userid ( bionic , data . address + 0x4 ) start += 0x8","title":"Strategy"},{"location":"tutorials/bionic/strategy/#strategy","text":"Before diving within Quokka, let's try to understand how we could solve the problem on paper.","title":"Strategy"},{"location":"tutorials/bionic/strategy/#steps","text":"Identify a function using the user table Find a data reference to the table Identify the table boundaries Read one entry Repeat until the end of the table","title":"Steps"},{"location":"tutorials/bionic/strategy/#step-1-identify-a-function-using-the-user-table","text":"For this, we have no choice but to read the manual. The getpwuid function is a good candidate, look at the manual below: The getpwuid() function returns a pointer to a structure containing the broken-out fields of the record in the password database that matches the user ID uid. Lets select the function: # WARNING: Not working from quokka import Function function : Function = bionic . get_function ( \"getpwuid\" ) assert function . name == \"getpwuid\" # Raises an error The previous snippet generates an error. Indeed, the function selected is not getpwuid but j_getpwuid . However, the signature of the get_function method has an additional parameter: Program . get_function ( name : 'str' , approximative : 'bool' = True , normal : 'bool' = False ) -> 'quokka.Function' Thus, the correct code to select the getpwuid function is: getpwuid : Function = bionic . get_function ( \"getpwuid\" , approximative = False ) assert getpwuid . name == \"getpwuid\" # Correct","title":"Step 1: Identify a function using the user table"},{"location":"tutorials/bionic/strategy/#step-2-find-the-data-reference-to-the-table","text":"We know that the getpwuid functions must use the user mapping we are searching. So, a (data) reference towards the table must exist within the function. Lets explore them: for data in getpwuid . data_references : print ( f \" { data . name } ( { data . type } ) at 0x { data . address : x } \" ) None ( DataType.DOUBLE_WORD ) at 0x1d024 _ZL11android_ids ( DataType.DOUBLE_WORD ) at 0x8cda0 _ZL11android_ids ( DataType.DOUBLE_WORD ) at 0x8cda0 None ( DataType.DOUBLE_WORD ) at 0x8cda4 So the second and third reference in the function are towards the table we are looking for! Let's find the beginning of our user table: from quokka import Data user_table : Data = getpwuid . data_references [ 1 ] print ( f \" { user_table . address =: x } \" ) # user_table.address=8cda0","title":"Step 2: Find the data reference to the table"},{"location":"tutorials/bionic/strategy/#step-3-identify-the-table-boundaries","text":"For this step, we are going to use an heuristic: * We know that the user table is contiguous in memory * We know that there are no code-references to the middle of the table So we are going to iterate the memory, starting at the first entry until an element as a code reference pointing towards it. To find if an element has a code reference, there is a convenient accessor: data = bionic . get_data ( address ) assert data . code_references != [], \"Has code references\" So our loop to iterate until the end of the table will look like this: from quokka.types import AddressT address : AddressT while True : data = bionic . get_data ( address ) if data . code_references : break ...","title":"Step 3: Identify the table boundaries"},{"location":"tutorials/bionic/strategy/#step-4-read-one-entry","text":"The structure of the table is as followed: struct android_id_info { const char name [ 17 ]; unsigned aid ; }; To read this with Quokka: # Start with the first entry, using the read_string method user_name = bionic . executable . read_string ( user_table . value ) # cameraserver And read the user ID too: it will be on the next DWORD: first_id = bionic . get_data ( user_table . address + 0x4 ) . value # 1047 However, the snippet above works only if IDA found the data in the program. Otherwise, it will fail with the following error: ValueError: No data at offset 0x8cdbc Another solution is to write this helper script: from quokka import Program from quokka.types import AddressT , DataType def read_userid ( prog : Program , address : AddressT ) -> int : \"\"\"Read an user ID within the program at `address`\"\"\" return prog . executable . read_data ( prog . addresser . file ( address ), DataType . DOUBLE_WORD )","title":"Step 4: Read one entry"},{"location":"tutorials/bionic/strategy/#step-5-repeat-until-the-end-of-the-table","text":"Now, we have every component of our script, let put it together within a loop: from quokka.types import AddressT start : AddressT = user_table . address + 0x8 while True : data = bionic . get_data ( start ) if data . code_references : break user_name = bionic . executable . read_string ( data . value ) user_id = read_userid ( bionic , data . address + 0x4 ) start += 0x8","title":"Step 5: Repeat until the end of the table"},{"location":"tutorials/features/00_intro/","text":"Features extraction Note This tutorial is adapted from the demonstration presented in GreHack'22. Context Let's try to reproduce one of the feature extractor of the great How Machine Learning Is Solving the Binary Function Similarity Problem 1 paper. Idea This tutorial simply tries to demonstrate how to perform common feature extraction using Quokka API instead of using IDA's API. By using Quokka, you gain several advantages: A saner API A compatibility with multiple IDA versions Reusable scripts A faster feature extraction Original code The original code for this tutorial is found in Cisco-Talos repository and reproduced below just for documentation purpose. From [https://github.com/Cisco-Talos/binary_function_similarity/blob/main/IDA_scripts/IDA_acfg_features/IDA_acfg_features.py](https://github.com/Cisco-Talos/binary_function_similarity/blob/main/IDA_scripts/IDA_acfg_features/IDA_acfg_features.py) ############################################################################## # # # Code for the USENIX Security '22 paper: # # How Machine Learning Is Solving the Binary Function Similarity Problem. # # # # MIT License # # # # Copyright (c) 2019-2022 Cisco Talos # # # # Permission is hereby granted, free of charge, to any person obtaining # # a copy of this software and associated documentation files (the # # \"Software\"), to deal in the Software without restriction, including # # without limitation the rights to use, copy, modify, merge, publish, # # distribute, sublicense, and/or sell copies of the Software, and to # # permit persons to whom the Software is furnished to do so, subject to # # the following conditions: # # # # The above copyright notice and this permission notice shall be # # included in all copies or substantial portions of the Software. # # # # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, # # EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF # # MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND # # NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE # # LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION # # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION # # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. # # # # IDA_acfg_features.py - acfg_features IDA plugin implementation. # # # # This plugin contains code from: # # github.com/williballenthin/python-idb/ licensed under Apache License 2.0 # # # ############################################################################## import idautils import idc import json import ntpath import os import time from capstone import * from collections import namedtuple from core import * BasicBlock = namedtuple ( 'BasicBlock' , [ 'va' , 'size' , 'succs' ]) def get_bitness (): \"\"\"Return 32/64 according to the binary bitness.\"\"\" info = idaapi . get_inf_structure () if info . is_64bit (): return 64 elif info . is_32bit (): return 32 def initialize_capstone ( procname , bitness ): \"\"\" Initialize the Capstone disassembler. Original code from Willi Ballenthin (Apache License 2.0): https://github.com/williballenthin/python-idb/blob/ 2de7df8356ee2d2a96a795343e59848c1b4cb45b/idb/idapython.py#L874 \"\"\" md = None arch = \"\" # WARNING: mipsl mode not supported here if procname == 'mipsb' : arch = \"MIPS\" if bitness == 32 : md = Cs ( CS_ARCH_MIPS , CS_MODE_MIPS32 | CS_MODE_BIG_ENDIAN ) if bitness == 64 : md = Cs ( CS_ARCH_MIPS , CS_MODE_MIPS64 | CS_MODE_BIG_ENDIAN ) if procname == \"arm\" : arch = \"ARM\" if bitness == 32 : # WARNING: THUMB mode not supported here md = Cs ( CS_ARCH_ARM , CS_MODE_ARM ) if bitness == 64 : md = Cs ( CS_ARCH_ARM64 , CS_MODE_ARM ) if \"pc\" in procname : arch = \"x86\" if bitness == 32 : md = Cs ( CS_ARCH_X86 , CS_MODE_32 ) if bitness == 64 : md = Cs ( CS_ARCH_X86 , CS_MODE_64 ) if md is None : raise RuntimeError ( \"Capstone initialization failure ( {} , {} )\" . format ( procname , bitness )) # Set detail to True to get the operand detailed info md . detail = True return md , arch def capstone_disassembly ( md , ea , size ): \"\"\"Disassemble a basic block using Capstone.\"\"\" try : # Define a fixed constant to extract immediates max_imm = 4096 bb_heads = list () bb_mnems = list () bb_disasm = list () bb_numerics = list () # Get the binary data corresponding to the instruction. binary_data = idc . get_bytes ( ea , size ) # Iterate over each instruction in the BB for i_inst in md . disasm ( binary_data , ea ): # Get the address bb_heads . append ( i_inst . address ) # Get the mnemonic bb_mnems . append ( i_inst . mnemonic ) # Get the disasm bb_disasm . append ( \" {} {} \" . format ( i_inst . mnemonic , i_inst . op_str )) # Iterate over the operands for op in i_inst . operands : # Type immediate if ( op . type == 2 ): if op . imm <= max_imm : bb_numerics . append ( op . imm ) return bb_heads , bb_mnems , bb_disasm , bb_numerics except Exception as e : print ( \"[!] Capstone exception\" , e ) return list (), list (), list (), list () def get_basic_blocks ( fva ): \"\"\"Return the list of BasicBlock for a given function.\"\"\" bb_list = list () func = idaapi . get_func ( fva ) if func is None : return bb_list for bb in idaapi . FlowChart ( func ): # WARNING: this function includes the BBs with size 0 # This is different from what IDA_acfg_disasm does. # if bb.end_ea - bb.start_ea > 0: bb_list . append ( BasicBlock ( va = bb . start_ea , size = bb . end_ea - bb . start_ea , succs = [ x . start_ea for x in bb . succs ()])) return bb_list def get_bb_disasm ( bb , md ): \"\"\"Wrapper around a basic block disassembly.\"\"\" bb_bytes = idc . get_bytes ( bb . va , bb . size ) bb_heads , bb_mnems , bb_disasm , bb_numerics = \\ capstone_disassembly ( md , bb . va , bb . size ) return bb_bytes , bb_heads , bb_mnems , bb_disasm , bb_numerics def get_bb_features ( bb , string_list , md , arch ): \"\"\"Extract the features associated to a BB.\"\"\" features_dict = dict () # Corner case if bb . size == 0 : features_dict = dict ( bb_len = 0 , # BB list-type features bb_numerics = list (), bb_strings = list (), # BB numerical-type features n_numeric_consts = 0 , n_string_consts = 0 , n_instructions = 0 , n_arith_instrs = 0 , n_call_instrs = 0 , n_logic_instrs = 0 , n_transfer_instrs = 0 , n_redirect_instrs = 0 ) return features_dict # Get the BB bytes, disassembly, mnemonics and other features bb_bytes , bb_heads , bb_mnems , bb_disasm , bb_numerics = \\ get_bb_disasm ( bb , md ) # Get static strings from the BB bb_strings = get_bb_strings ( bb , string_list ) features_dict = dict ( bb_len = bb . size , # BB list-type features bb_numerics = bb_numerics , bb_strings = bb_strings , # BB numerical-type features n_numeric_consts = len ( bb_numerics ), n_string_consts = len ( bb_strings ), n_instructions = len ( bb_mnems ), n_arith_instrs = get_n_arith_instrs ( bb_mnems , arch ), n_call_instrs = get_n_call_instrs ( bb_mnems , arch ), n_logic_instrs = get_n_logic_instrs ( bb_mnems , arch ), n_transfer_instrs = get_n_transfer_instrs ( bb_mnems , arch ), n_redirect_instrs = get_n_redirect_instrs ( bb_mnems , arch ) ) return features_dict def run_acfg_features ( idb_path , fva_list , output_dir ): \"\"\"Extract the features from each function. Save results to JSON.\"\"\" print ( \"[D] Processing: %s \" % idb_path ) # Create output directory if it does not exist if not os . path . isdir ( output_dir ): os . mkdir ( output_dir ) output_dict = dict () output_dict [ idb_path ] = dict () procname = idaapi . get_inf_structure () . procName . lower () bitness = get_bitness () md , arch = initialize_capstone ( procname , bitness ) # Get the list of Strings for the IDB string_list = list ( idautils . Strings ()) # Iterate over each function for fva in fva_list : try : start_time = time . time () nodes_set , edges_set = set (), set () bbs_dict = dict () for bb in get_basic_blocks ( fva ): # CFG nodes_set . add ( bb . va ) for dest_ea in bb . succs : edges_set . add (( bb . va , dest_ea )) # BB-level features bbs_dict [ bb . va ] = get_bb_features ( bb , string_list , md , arch ) # Function-level features function_features = get_function_features ( fva , bbs_dict , len ( edges_set )) elapsed_time = time . time () - start_time func_dict = { 'nodes' : list ( nodes_set ), 'edges' : list ( edges_set ), 'features' : function_features , 'basic_blocks' : bbs_dict , 'elapsed_time' : elapsed_time , } output_dict [ idb_path ][ hex ( fva )] = func_dict except Exception as e : print ( \"[!] Exception: skipping function fva: %d \" % fva ) print ( e ) out_name = ntpath . basename ( idb_path . replace ( \".i64\" , \"_acfg_features.json\" )) with open ( os . path . join ( output_dir , out_name ), \"w\" ) as f_out : json . dump ( output_dict , f_out ) if __name__ == '__main__' : if not idaapi . get_plugin_options ( \"acfg_features\" ): print ( \"[!] -Oacfg_features option is missing\" ) idc . Exit ( 1 ) plugin_options = idaapi . get_plugin_options ( \"acfg_features\" ) . split ( \":\" ) if len ( plugin_options ) != 3 : print ( \"[!] -Oacfg_features:INPUT_JSON:IDB_PATH:OUTPUT_DIR is required\" ) idc . Exit ( 1 ) input_json = plugin_options [ 0 ] idb_path = plugin_options [ 1 ] output_dir = plugin_options [ 2 ] with open ( input_json ) as f_in : selected_functions = json . load ( f_in ) if idb_path not in selected_functions : print ( \"[!] Error! IDB path ( %s ) not in %s \" % ( idb_path , input_json )) idc . Exit ( 1 ) fva_list = selected_functions [ idb_path ] print ( \"[D] Found %d addresses\" % len ( fva_list )) run_acfg_features ( idb_path , fva_list , output_dir ) idc . Exit ( 0 ) Andrea Marcelli, Mariano Graziano, Xabier Ugarte-Pedrero, Yanick Fratantonio, Mohamad Mansouri, Davide Balzarotti. How Machine Learning Is Solving the Binary Function Similarity Problem. USENIX Security '22. \u21a9","title":"Introduction"},{"location":"tutorials/features/00_intro/#features-extraction","text":"Note This tutorial is adapted from the demonstration presented in GreHack'22.","title":"Features extraction"},{"location":"tutorials/features/00_intro/#context","text":"Let's try to reproduce one of the feature extractor of the great How Machine Learning Is Solving the Binary Function Similarity Problem 1 paper.","title":"Context"},{"location":"tutorials/features/00_intro/#idea","text":"This tutorial simply tries to demonstrate how to perform common feature extraction using Quokka API instead of using IDA's API. By using Quokka, you gain several advantages: A saner API A compatibility with multiple IDA versions Reusable scripts A faster feature extraction","title":"Idea"},{"location":"tutorials/features/00_intro/#original-code","text":"The original code for this tutorial is found in Cisco-Talos repository and reproduced below just for documentation purpose. From [https://github.com/Cisco-Talos/binary_function_similarity/blob/main/IDA_scripts/IDA_acfg_features/IDA_acfg_features.py](https://github.com/Cisco-Talos/binary_function_similarity/blob/main/IDA_scripts/IDA_acfg_features/IDA_acfg_features.py) ############################################################################## # # # Code for the USENIX Security '22 paper: # # How Machine Learning Is Solving the Binary Function Similarity Problem. # # # # MIT License # # # # Copyright (c) 2019-2022 Cisco Talos # # # # Permission is hereby granted, free of charge, to any person obtaining # # a copy of this software and associated documentation files (the # # \"Software\"), to deal in the Software without restriction, including # # without limitation the rights to use, copy, modify, merge, publish, # # distribute, sublicense, and/or sell copies of the Software, and to # # permit persons to whom the Software is furnished to do so, subject to # # the following conditions: # # # # The above copyright notice and this permission notice shall be # # included in all copies or substantial portions of the Software. # # # # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, # # EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF # # MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND # # NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE # # LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION # # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION # # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. # # # # IDA_acfg_features.py - acfg_features IDA plugin implementation. # # # # This plugin contains code from: # # github.com/williballenthin/python-idb/ licensed under Apache License 2.0 # # # ############################################################################## import idautils import idc import json import ntpath import os import time from capstone import * from collections import namedtuple from core import * BasicBlock = namedtuple ( 'BasicBlock' , [ 'va' , 'size' , 'succs' ]) def get_bitness (): \"\"\"Return 32/64 according to the binary bitness.\"\"\" info = idaapi . get_inf_structure () if info . is_64bit (): return 64 elif info . is_32bit (): return 32 def initialize_capstone ( procname , bitness ): \"\"\" Initialize the Capstone disassembler. Original code from Willi Ballenthin (Apache License 2.0): https://github.com/williballenthin/python-idb/blob/ 2de7df8356ee2d2a96a795343e59848c1b4cb45b/idb/idapython.py#L874 \"\"\" md = None arch = \"\" # WARNING: mipsl mode not supported here if procname == 'mipsb' : arch = \"MIPS\" if bitness == 32 : md = Cs ( CS_ARCH_MIPS , CS_MODE_MIPS32 | CS_MODE_BIG_ENDIAN ) if bitness == 64 : md = Cs ( CS_ARCH_MIPS , CS_MODE_MIPS64 | CS_MODE_BIG_ENDIAN ) if procname == \"arm\" : arch = \"ARM\" if bitness == 32 : # WARNING: THUMB mode not supported here md = Cs ( CS_ARCH_ARM , CS_MODE_ARM ) if bitness == 64 : md = Cs ( CS_ARCH_ARM64 , CS_MODE_ARM ) if \"pc\" in procname : arch = \"x86\" if bitness == 32 : md = Cs ( CS_ARCH_X86 , CS_MODE_32 ) if bitness == 64 : md = Cs ( CS_ARCH_X86 , CS_MODE_64 ) if md is None : raise RuntimeError ( \"Capstone initialization failure ( {} , {} )\" . format ( procname , bitness )) # Set detail to True to get the operand detailed info md . detail = True return md , arch def capstone_disassembly ( md , ea , size ): \"\"\"Disassemble a basic block using Capstone.\"\"\" try : # Define a fixed constant to extract immediates max_imm = 4096 bb_heads = list () bb_mnems = list () bb_disasm = list () bb_numerics = list () # Get the binary data corresponding to the instruction. binary_data = idc . get_bytes ( ea , size ) # Iterate over each instruction in the BB for i_inst in md . disasm ( binary_data , ea ): # Get the address bb_heads . append ( i_inst . address ) # Get the mnemonic bb_mnems . append ( i_inst . mnemonic ) # Get the disasm bb_disasm . append ( \" {} {} \" . format ( i_inst . mnemonic , i_inst . op_str )) # Iterate over the operands for op in i_inst . operands : # Type immediate if ( op . type == 2 ): if op . imm <= max_imm : bb_numerics . append ( op . imm ) return bb_heads , bb_mnems , bb_disasm , bb_numerics except Exception as e : print ( \"[!] Capstone exception\" , e ) return list (), list (), list (), list () def get_basic_blocks ( fva ): \"\"\"Return the list of BasicBlock for a given function.\"\"\" bb_list = list () func = idaapi . get_func ( fva ) if func is None : return bb_list for bb in idaapi . FlowChart ( func ): # WARNING: this function includes the BBs with size 0 # This is different from what IDA_acfg_disasm does. # if bb.end_ea - bb.start_ea > 0: bb_list . append ( BasicBlock ( va = bb . start_ea , size = bb . end_ea - bb . start_ea , succs = [ x . start_ea for x in bb . succs ()])) return bb_list def get_bb_disasm ( bb , md ): \"\"\"Wrapper around a basic block disassembly.\"\"\" bb_bytes = idc . get_bytes ( bb . va , bb . size ) bb_heads , bb_mnems , bb_disasm , bb_numerics = \\ capstone_disassembly ( md , bb . va , bb . size ) return bb_bytes , bb_heads , bb_mnems , bb_disasm , bb_numerics def get_bb_features ( bb , string_list , md , arch ): \"\"\"Extract the features associated to a BB.\"\"\" features_dict = dict () # Corner case if bb . size == 0 : features_dict = dict ( bb_len = 0 , # BB list-type features bb_numerics = list (), bb_strings = list (), # BB numerical-type features n_numeric_consts = 0 , n_string_consts = 0 , n_instructions = 0 , n_arith_instrs = 0 , n_call_instrs = 0 , n_logic_instrs = 0 , n_transfer_instrs = 0 , n_redirect_instrs = 0 ) return features_dict # Get the BB bytes, disassembly, mnemonics and other features bb_bytes , bb_heads , bb_mnems , bb_disasm , bb_numerics = \\ get_bb_disasm ( bb , md ) # Get static strings from the BB bb_strings = get_bb_strings ( bb , string_list ) features_dict = dict ( bb_len = bb . size , # BB list-type features bb_numerics = bb_numerics , bb_strings = bb_strings , # BB numerical-type features n_numeric_consts = len ( bb_numerics ), n_string_consts = len ( bb_strings ), n_instructions = len ( bb_mnems ), n_arith_instrs = get_n_arith_instrs ( bb_mnems , arch ), n_call_instrs = get_n_call_instrs ( bb_mnems , arch ), n_logic_instrs = get_n_logic_instrs ( bb_mnems , arch ), n_transfer_instrs = get_n_transfer_instrs ( bb_mnems , arch ), n_redirect_instrs = get_n_redirect_instrs ( bb_mnems , arch ) ) return features_dict def run_acfg_features ( idb_path , fva_list , output_dir ): \"\"\"Extract the features from each function. Save results to JSON.\"\"\" print ( \"[D] Processing: %s \" % idb_path ) # Create output directory if it does not exist if not os . path . isdir ( output_dir ): os . mkdir ( output_dir ) output_dict = dict () output_dict [ idb_path ] = dict () procname = idaapi . get_inf_structure () . procName . lower () bitness = get_bitness () md , arch = initialize_capstone ( procname , bitness ) # Get the list of Strings for the IDB string_list = list ( idautils . Strings ()) # Iterate over each function for fva in fva_list : try : start_time = time . time () nodes_set , edges_set = set (), set () bbs_dict = dict () for bb in get_basic_blocks ( fva ): # CFG nodes_set . add ( bb . va ) for dest_ea in bb . succs : edges_set . add (( bb . va , dest_ea )) # BB-level features bbs_dict [ bb . va ] = get_bb_features ( bb , string_list , md , arch ) # Function-level features function_features = get_function_features ( fva , bbs_dict , len ( edges_set )) elapsed_time = time . time () - start_time func_dict = { 'nodes' : list ( nodes_set ), 'edges' : list ( edges_set ), 'features' : function_features , 'basic_blocks' : bbs_dict , 'elapsed_time' : elapsed_time , } output_dict [ idb_path ][ hex ( fva )] = func_dict except Exception as e : print ( \"[!] Exception: skipping function fva: %d \" % fva ) print ( e ) out_name = ntpath . basename ( idb_path . replace ( \".i64\" , \"_acfg_features.json\" )) with open ( os . path . join ( output_dir , out_name ), \"w\" ) as f_out : json . dump ( output_dict , f_out ) if __name__ == '__main__' : if not idaapi . get_plugin_options ( \"acfg_features\" ): print ( \"[!] -Oacfg_features option is missing\" ) idc . Exit ( 1 ) plugin_options = idaapi . get_plugin_options ( \"acfg_features\" ) . split ( \":\" ) if len ( plugin_options ) != 3 : print ( \"[!] -Oacfg_features:INPUT_JSON:IDB_PATH:OUTPUT_DIR is required\" ) idc . Exit ( 1 ) input_json = plugin_options [ 0 ] idb_path = plugin_options [ 1 ] output_dir = plugin_options [ 2 ] with open ( input_json ) as f_in : selected_functions = json . load ( f_in ) if idb_path not in selected_functions : print ( \"[!] Error! IDB path ( %s ) not in %s \" % ( idb_path , input_json )) idc . Exit ( 1 ) fva_list = selected_functions [ idb_path ] print ( \"[D] Found %d addresses\" % len ( fva_list )) run_acfg_features ( idb_path , fva_list , output_dir ) idc . Exit ( 0 ) Andrea Marcelli, Mariano Graziano, Xabier Ugarte-Pedrero, Yanick Fratantonio, Mohamad Mansouri, Davide Balzarotti. How Machine Learning Is Solving the Binary Function Similarity Problem. USENIX Security '22. \u21a9","title":"Original code"},{"location":"tutorials/features/01_block/","text":"Block features In this 1st part, let's look at how to extract the block features for the paper. Final snippet from typing import Dict , Union , List import quokka # Use the code from arch.py in this repo # Originally # https://github.com/Cisco-Talos/binary_function_similarity/blob/main/IDA_scripts/IDA_acfg_features/core/architecture.py ARCH_MNEM = ... FeaturesDict = Dict [ str , Union [ int , List [ str ], List [ int ]]] def get_bb_features ( block : quokka . Block ) -> FeaturesDict : mnemonics = [ inst . cs_inst . mnemonic for inst in block . instructions ] arch = block . program . isa . name return { \"bb_len\" : block . size , # (1)! # List features \"bb_numerics\" : block . constants , # (2)! \"bb_strings\" : block . strings , # (3)! # Numeric features \"n_numeric_consts\" : len ( block . constants ), # (4)! \"n_string_consts\" : len ( block . strings ), # (5)! \"n_instructions\" : len ( mnemonics ), # (6)! \"n_arith_instrs\" : sum ( 1 for m in mnemonics if m in ARCH_MNEM [ arch ][ \"arithmetic\" ] # (7)! ), \"n_call_instrs\" : sum ( 1 for m in mnemonics if m in ARCH_MNEM [ arch ][ \"call\" ]), \"n_logic_instrs\" : sum ( 1 for m in mnemonics if m in ARCH_MNEM [ arch ][ \"logic\" ]), \"n_transfer_instrs\" : sum ( 1 for m in mnemonics if m in ARCH_MNEM [ arch ][ \"transfer\" ] ), \"n_redirect_instrs\" : sum ( 1 for m in mnemonics if ( m in ARCH_MNEM [ arch ][ \"unconditional\" ]) or ( m in ARCH_MNEM [ arch ][ \"conditional\" ]) or ( m in ARCH_MNEM [ arch ][ \"call\" ]) ), } First, let's take the len of the block as its size The list of numerics constants used in the block is accessible using the .constants attribute The list of strings found in the block is accessible by .strings The number of constants is simply found using the len of the constants list The number of strings is simply found using the len of the strings list We count the number of instruction using the number of the mnemonics in the list. Classify instructions using the ARCH_MNEM mapping provided ARCH_MNEM This mapping has been created by the paper's authors to classify the instructions in each architecture. For example, the mnemonic used to touch the stack in ARM are the following: ARCH_MNEM = {} ARCH_MNEM [ \"ARM\" ][ \"stack\" ] = { 'pop' , 'popeq' , 'popne' , 'pople' , 'pophs' , 'poplt' , 'push' } Obtaining the mnemonics If you paid attention to the snippet, this line was used to obtain the mnemonics: ... mnemonics = [ inst . cs_inst . mnemonic for inst in block . instructions ] ... Why did we use the cs_inst attribute instead of the more simple one mnenomic from the Instruction class? To simply demonstrate the usage of the capstone bindings.","title":"Block features"},{"location":"tutorials/features/01_block/#block-features","text":"In this 1st part, let's look at how to extract the block features for the paper.","title":"Block features"},{"location":"tutorials/features/01_block/#final-snippet","text":"from typing import Dict , Union , List import quokka # Use the code from arch.py in this repo # Originally # https://github.com/Cisco-Talos/binary_function_similarity/blob/main/IDA_scripts/IDA_acfg_features/core/architecture.py ARCH_MNEM = ... FeaturesDict = Dict [ str , Union [ int , List [ str ], List [ int ]]] def get_bb_features ( block : quokka . Block ) -> FeaturesDict : mnemonics = [ inst . cs_inst . mnemonic for inst in block . instructions ] arch = block . program . isa . name return { \"bb_len\" : block . size , # (1)! # List features \"bb_numerics\" : block . constants , # (2)! \"bb_strings\" : block . strings , # (3)! # Numeric features \"n_numeric_consts\" : len ( block . constants ), # (4)! \"n_string_consts\" : len ( block . strings ), # (5)! \"n_instructions\" : len ( mnemonics ), # (6)! \"n_arith_instrs\" : sum ( 1 for m in mnemonics if m in ARCH_MNEM [ arch ][ \"arithmetic\" ] # (7)! ), \"n_call_instrs\" : sum ( 1 for m in mnemonics if m in ARCH_MNEM [ arch ][ \"call\" ]), \"n_logic_instrs\" : sum ( 1 for m in mnemonics if m in ARCH_MNEM [ arch ][ \"logic\" ]), \"n_transfer_instrs\" : sum ( 1 for m in mnemonics if m in ARCH_MNEM [ arch ][ \"transfer\" ] ), \"n_redirect_instrs\" : sum ( 1 for m in mnemonics if ( m in ARCH_MNEM [ arch ][ \"unconditional\" ]) or ( m in ARCH_MNEM [ arch ][ \"conditional\" ]) or ( m in ARCH_MNEM [ arch ][ \"call\" ]) ), } First, let's take the len of the block as its size The list of numerics constants used in the block is accessible using the .constants attribute The list of strings found in the block is accessible by .strings The number of constants is simply found using the len of the constants list The number of strings is simply found using the len of the strings list We count the number of instruction using the number of the mnemonics in the list. Classify instructions using the ARCH_MNEM mapping provided","title":"Final snippet"},{"location":"tutorials/features/01_block/#arch_mnem","text":"This mapping has been created by the paper's authors to classify the instructions in each architecture. For example, the mnemonic used to touch the stack in ARM are the following: ARCH_MNEM = {} ARCH_MNEM [ \"ARM\" ][ \"stack\" ] = { 'pop' , 'popeq' , 'popne' , 'pople' , 'pophs' , 'poplt' , 'push' }","title":"ARCH_MNEM"},{"location":"tutorials/features/01_block/#obtaining-the-mnemonics","text":"If you paid attention to the snippet, this line was used to obtain the mnemonics: ... mnemonics = [ inst . cs_inst . mnemonic for inst in block . instructions ] ... Why did we use the cs_inst attribute instead of the more simple one mnenomic from the Instruction class? To simply demonstrate the usage of the capstone bindings.","title":"Obtaining the mnemonics"},{"location":"tutorials/features/02_functions/","text":"Functions features Original code # From https://github.com/Cisco-Talos/binary_function_similarity/blob/main/IDA_scripts/IDA_acfg_features/core/ff_features.py#L76 def get_function_features ( fva , bbs_dict , len_edges ): \"\"\" Construction the dictionary with function-level features. Args: fva: function virtual address bbs_dict: a dictionary with all the features, one per BB len_eges: number of edges Return: a dictionary with function-level features \"\"\" f_dict = { 'n_func_calls' : f_sum ( bbs_dict , 'n_call_instrs' ), 'n_logic_instrs' : f_sum ( bbs_dict , 'n_logic_instrs' ), 'n_redirections' : f_sum ( bbs_dict , 'n_redirect_instrs' ), 'n_transfer_instrs' : f_sum ( bbs_dict , 'n_transfer_instrs' ), 'size_local_variables' : get_size_local_vars ( fva ), 'n_bb' : len ( bbs_dict ), 'n_edges' : len_edges , 'n_incoming_calls' : get_func_incoming_calls ( fva ), 'n_instructions' : f_sum ( bbs_dict , 'n_instructions' ) } return f_dict Quokka code import quokka FeaturesDict = ... def sum_block_features ( bb_features : FeaturesDict , feature : str ) -> int : \"\"\"Sum the values for every basic block in the function\"\"\" assert feature . startswith ( \"n_\" ), \"Only numeric values can be summed\" return sum ( basic_block [ feature ] for basic_block in bb_features . values ()) def get_func_features ( func : quokka . Function ) -> FeaturesDict : bb_features = {} for block_start in func . graph : block = func . get_block ( block_start ) bb_features [ block_start ] = get_bb_features ( block ) return { 'n_func_calls' : sum_block_features ( bb_features , 'n_call_instrs' ), 'n_logic_instrs' : sum_block_features ( bb_features , 'n_logic_instrs' ), 'n_redirections' : sum_block_features ( bb_features , 'n_redirect_instrs' ), 'n_transfer_instrs' : sum_block_features ( bb_features , 'n_transfer_instrs' ), 'size_local_variables' : ... , # Not possible with Quokka 'n_bb' : len ( bb_features ), 'n_edges' : len ( func . graph . edges ), 'n_incoming_calls' : len ( func . callers ), 'n_instructions' : sum ( 1 for _ in func . instructions ), \"basic_blocks\" : bb_features , } Et voil\u00e0!","title":"Function features"},{"location":"tutorials/features/02_functions/#functions-features","text":"","title":"Functions features"},{"location":"tutorials/features/02_functions/#original-code","text":"# From https://github.com/Cisco-Talos/binary_function_similarity/blob/main/IDA_scripts/IDA_acfg_features/core/ff_features.py#L76 def get_function_features ( fva , bbs_dict , len_edges ): \"\"\" Construction the dictionary with function-level features. Args: fva: function virtual address bbs_dict: a dictionary with all the features, one per BB len_eges: number of edges Return: a dictionary with function-level features \"\"\" f_dict = { 'n_func_calls' : f_sum ( bbs_dict , 'n_call_instrs' ), 'n_logic_instrs' : f_sum ( bbs_dict , 'n_logic_instrs' ), 'n_redirections' : f_sum ( bbs_dict , 'n_redirect_instrs' ), 'n_transfer_instrs' : f_sum ( bbs_dict , 'n_transfer_instrs' ), 'size_local_variables' : get_size_local_vars ( fva ), 'n_bb' : len ( bbs_dict ), 'n_edges' : len_edges , 'n_incoming_calls' : get_func_incoming_calls ( fva ), 'n_instructions' : f_sum ( bbs_dict , 'n_instructions' ) } return f_dict","title":"Original code"},{"location":"tutorials/features/02_functions/#quokka-code","text":"import quokka FeaturesDict = ... def sum_block_features ( bb_features : FeaturesDict , feature : str ) -> int : \"\"\"Sum the values for every basic block in the function\"\"\" assert feature . startswith ( \"n_\" ), \"Only numeric values can be summed\" return sum ( basic_block [ feature ] for basic_block in bb_features . values ()) def get_func_features ( func : quokka . Function ) -> FeaturesDict : bb_features = {} for block_start in func . graph : block = func . get_block ( block_start ) bb_features [ block_start ] = get_bb_features ( block ) return { 'n_func_calls' : sum_block_features ( bb_features , 'n_call_instrs' ), 'n_logic_instrs' : sum_block_features ( bb_features , 'n_logic_instrs' ), 'n_redirections' : sum_block_features ( bb_features , 'n_redirect_instrs' ), 'n_transfer_instrs' : sum_block_features ( bb_features , 'n_transfer_instrs' ), 'size_local_variables' : ... , # Not possible with Quokka 'n_bb' : len ( bb_features ), 'n_edges' : len ( func . graph . edges ), 'n_incoming_calls' : len ( func . callers ), 'n_instructions' : sum ( 1 for _ in func . instructions ), \"basic_blocks\" : bb_features , } Et voil\u00e0!","title":"Quokka code"},{"location":"tutorials/features/03_final/","text":"Wrapping up The two snippets presented in the previous pages can be concatenated in a single extract you can run on your binaries to get a basic feature extractor. # Copyright 2022 Quarkslab # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # https://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. \"\"\" Feature Extractor This snippet uses Quokka to extract features from the every function (and block) of the program. Usage: python ./script <binary_path> Author: Written by dm (Alexis Challande) in 2022. \"\"\" from __future__ import annotations import json import sys from typing import Dict , Union , List import quokka # Use the code from arch.py in this repo # Originally # https://github.com/Cisco-Talos/binary_function_similarity/blob/main/IDA_scripts/IDA_acfg_features/core/architecture.py ARCH_MNEM = ... FeaturesDict = Dict [ str , Union [ int , List [ str ], List [ int ], \"FeaturesDict\" ]] def get_bb_features ( block : quokka . Block ) -> FeaturesDict : \"\"\"Extract features from a Basic Block\"\"\" mnemonics = [ inst . cs_inst . mnemonic for inst in block . instructions ] arch = block . program . isa . name return { \"bb_len\" : block . size , # List features \"bb_numerics\" : block . constants , \"bb_strings\" : block . strings , # Numeric features \"n_numeric_consts\" : len ( block . constants ), \"n_string_consts\" : len ( block . strings ), \"n_instructions\" : len ( mnemonics ), \"n_arith_instrs\" : sum ( 1 for m in mnemonics if m in ARCH_MNEM [ arch ][ \"arithmetic\" ] ), \"n_call_instrs\" : sum ( 1 for m in mnemonics if m in ARCH_MNEM [ arch ][ \"call\" ]), \"n_logic_instrs\" : sum ( 1 for m in mnemonics if m in ARCH_MNEM [ arch ][ \"logic\" ]), \"n_transfer_instrs\" : sum ( 1 for m in mnemonics if m in ARCH_MNEM [ arch ][ \"transfer\" ] ), \"n_redirect_instrs\" : sum ( 1 for m in mnemonics if ( m in ARCH_MNEM [ arch ][ \"unconditional\" ]) or ( m in ARCH_MNEM [ arch ][ \"conditional\" ]) or ( m in ARCH_MNEM [ arch ][ \"call\" ]) ), } def sum_block_features ( bb_features : FeaturesDict , feature : str ) -> int : \"\"\"Sum the values for every basic block in the function\"\"\" assert feature . startswith ( \"n_\" ), \"Only numeric values can be summed\" return sum ( basic_block [ feature ] for basic_block in bb_features . values ()) def get_func_features ( func : quokka . Function ) -> FeaturesDict : \"\"\"Extracts features from a Function\"\"\" bb_features = {} for block_start in func . graph : block = func . get_block ( block_start ) bb_features [ block_start ] = get_bb_features ( block ) return { \"n_func_calls\" : sum_block_features ( bb_features , \"n_call_instrs\" ), \"n_logic_instrs\" : sum_block_features ( bb_features , \"n_logic_instrs\" ), \"n_redirections\" : sum_block_features ( bb_features , \"n_redirect_instrs\" ), \"n_transfer_instrs\" : sum_block_features ( bb_features , \"n_transfer_instrs\" ), \"size_local_variables\" : ... , # Not possible with Quokka \"n_bb\" : len ( bb_features ), \"n_edges\" : len ( func . graph . edges ), \"n_incoming_calls\" : len ( func . callers ), \"n_instructions\" : sum ( 1 for _ in func . instructions ), \"basic_blocks\" : bb_features , } def export_binary ( binary : quokka . Program ) -> None : \"\"\"Export features from a Program\"\"\" prog_features : FeaturesDict = {} for func in binary . values (): prog_features [ func . start ] = get_func_features ( func ) with open ( f \" { binary . name } .json\" , \"w\" ) as fp : json . dump ( prog_features , fp , indent = True ) if __name__ == \"main\" : program : quokka . Program = quokka . Program . from_binary ( sys . argv [ 1 ]) export_binary ( program )","title":"Wrapping up"},{"location":"tutorials/features/03_final/#wrapping-up","text":"The two snippets presented in the previous pages can be concatenated in a single extract you can run on your binaries to get a basic feature extractor. # Copyright 2022 Quarkslab # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # https://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. \"\"\" Feature Extractor This snippet uses Quokka to extract features from the every function (and block) of the program. Usage: python ./script <binary_path> Author: Written by dm (Alexis Challande) in 2022. \"\"\" from __future__ import annotations import json import sys from typing import Dict , Union , List import quokka # Use the code from arch.py in this repo # Originally # https://github.com/Cisco-Talos/binary_function_similarity/blob/main/IDA_scripts/IDA_acfg_features/core/architecture.py ARCH_MNEM = ... FeaturesDict = Dict [ str , Union [ int , List [ str ], List [ int ], \"FeaturesDict\" ]] def get_bb_features ( block : quokka . Block ) -> FeaturesDict : \"\"\"Extract features from a Basic Block\"\"\" mnemonics = [ inst . cs_inst . mnemonic for inst in block . instructions ] arch = block . program . isa . name return { \"bb_len\" : block . size , # List features \"bb_numerics\" : block . constants , \"bb_strings\" : block . strings , # Numeric features \"n_numeric_consts\" : len ( block . constants ), \"n_string_consts\" : len ( block . strings ), \"n_instructions\" : len ( mnemonics ), \"n_arith_instrs\" : sum ( 1 for m in mnemonics if m in ARCH_MNEM [ arch ][ \"arithmetic\" ] ), \"n_call_instrs\" : sum ( 1 for m in mnemonics if m in ARCH_MNEM [ arch ][ \"call\" ]), \"n_logic_instrs\" : sum ( 1 for m in mnemonics if m in ARCH_MNEM [ arch ][ \"logic\" ]), \"n_transfer_instrs\" : sum ( 1 for m in mnemonics if m in ARCH_MNEM [ arch ][ \"transfer\" ] ), \"n_redirect_instrs\" : sum ( 1 for m in mnemonics if ( m in ARCH_MNEM [ arch ][ \"unconditional\" ]) or ( m in ARCH_MNEM [ arch ][ \"conditional\" ]) or ( m in ARCH_MNEM [ arch ][ \"call\" ]) ), } def sum_block_features ( bb_features : FeaturesDict , feature : str ) -> int : \"\"\"Sum the values for every basic block in the function\"\"\" assert feature . startswith ( \"n_\" ), \"Only numeric values can be summed\" return sum ( basic_block [ feature ] for basic_block in bb_features . values ()) def get_func_features ( func : quokka . Function ) -> FeaturesDict : \"\"\"Extracts features from a Function\"\"\" bb_features = {} for block_start in func . graph : block = func . get_block ( block_start ) bb_features [ block_start ] = get_bb_features ( block ) return { \"n_func_calls\" : sum_block_features ( bb_features , \"n_call_instrs\" ), \"n_logic_instrs\" : sum_block_features ( bb_features , \"n_logic_instrs\" ), \"n_redirections\" : sum_block_features ( bb_features , \"n_redirect_instrs\" ), \"n_transfer_instrs\" : sum_block_features ( bb_features , \"n_transfer_instrs\" ), \"size_local_variables\" : ... , # Not possible with Quokka \"n_bb\" : len ( bb_features ), \"n_edges\" : len ( func . graph . edges ), \"n_incoming_calls\" : len ( func . callers ), \"n_instructions\" : sum ( 1 for _ in func . instructions ), \"basic_blocks\" : bb_features , } def export_binary ( binary : quokka . Program ) -> None : \"\"\"Export features from a Program\"\"\" prog_features : FeaturesDict = {} for func in binary . values (): prog_features [ func . start ] = get_func_features ( func ) with open ( f \" { binary . name } .json\" , \"w\" ) as fp : json . dump ( prog_features , fp , indent = True ) if __name__ == \"main\" : program : quokka . Program = quokka . Program . from_binary ( sys . argv [ 1 ]) export_binary ( program )","title":"Wrapping up"},{"location":"tutorials/features/SUMMARY/","text":"Introduction Block features Function features Wrapping up","title":"SUMMARY"},{"location":"tutorials/qb-crackme/00_intro/","text":"Tutorial This tutorial show some usage Quokka Python API. Run the code Info All the code snippets are valid Python / Bash snippet and may be run directly. I suggest installing IPython for an interactive Python terminal with syntax highlighting and auto-completion Step 1: Install quokka Tip It's best to install quokka in a virtualenv . $ pip install pip install git+https://github.com/quarkslab/quokka.git Step 2: Download the binaries for the tutorial For this tutorial, we will use a simple CrackMe. You can download it here . If you don't have IDA, you will also need the exported file: here . Check Let's now check that quokka has been installed! $ python -c \"import quokka\" If the result is not the following (or any other errors), congrats! Traceback ( most recent call last ) : File \"<string>\" , line 1 , in <module> ModuleNotFoundError: No module named 'quokka'","title":"0 - Introduction"},{"location":"tutorials/qb-crackme/00_intro/#tutorial","text":"This tutorial show some usage Quokka Python API.","title":"Tutorial"},{"location":"tutorials/qb-crackme/00_intro/#run-the-code","text":"Info All the code snippets are valid Python / Bash snippet and may be run directly. I suggest installing IPython for an interactive Python terminal with syntax highlighting and auto-completion","title":"Run the code"},{"location":"tutorials/qb-crackme/00_intro/#step-1-install-quokka","text":"Tip It's best to install quokka in a virtualenv . $ pip install pip install git+https://github.com/quarkslab/quokka.git","title":"Step 1: Install quokka"},{"location":"tutorials/qb-crackme/00_intro/#step-2-download-the-binaries-for-the-tutorial","text":"For this tutorial, we will use a simple CrackMe. You can download it here . If you don't have IDA, you will also need the exported file: here .","title":"Step 2: Download the binaries for the tutorial"},{"location":"tutorials/qb-crackme/00_intro/#check","text":"Let's now check that quokka has been installed! $ python -c \"import quokka\" If the result is not the following (or any other errors), congrats! Traceback ( most recent call last ) : File \"<string>\" , line 1 , in <module> ModuleNotFoundError: No module named 'quokka'","title":"Check"},{"location":"tutorials/qb-crackme/01_load/","text":"Binary loading Before doing anything with a quokka file, you need to load it. Tip For the remaining of this tutorial, I will be using an interactive IPython shell. To load a program, quokka needs both the export file and the original binary. Indeed, to reduce the size of the export, information directly available in the binary are not exported. import quokka from pathlib import Path samples = Path ( 'docs/samples' ) assert samples . is_dir (), \"You should run this code in Quokka main directory\" prog = quokka . Program ( samples / \"qb-crackme.quokka\" , samples / \"qb-crackme\" ) # Let's check if it worked print ( f 'Program base address is 0x { prog . base_address : x } ' ) # Should print: Program base address is 0x8048000. Explore a bit the Program object We now have in prog a complete program representation. Using dir(prog) , you can see the different possibilities. For instance, you can list the strings found in the program using : import quokka prog = quokka . Program ( \"docs/samples/qb-crackme.quokka\" , \"docs/samples/qb-crackme\" ) print ( f \"Found { len ( prog . strings ) } in { prog . export_file . stem } \" ) Using the protobuf directly Of note, the protobuf generated by the plugin is available in prog.proto . You should not access it directly because it's a rather compact format not well documented. Export and load If the IDA plugin has been installed you can also create the exported directly using the convenient method from_binary . import quokka prog = quokka . Program . from_binary ( 'docs/samples/qb-crackme' ) assert prog is not None , \"Unable to export qb-crackme\" Tips & tricks By default, IDA will store the database of the exported file next to the binary file. However, this is not convenient when dealing with read only filesystems. Use the database_file option to control where it should be stored. import quokka prog = quokka . Program . from_binary ( '/bin/ls' ) # Will fail because /bin is not writable assert prog is None , \"/bin is writable -- this is unusual\" prog = quokka . Program . from_binary ( '/bin/ls' , output_file = 'docs/samples/ls.quokka' , database_file = 'docs/samples/ls.i64' ) assert prog is not None , \"Unable to export ls\" The debug parameter of the same method will control the output. One of its effect is that it will print the exporter output and the command used to launch it.","title":"1 - Loading"},{"location":"tutorials/qb-crackme/01_load/#binary-loading","text":"Before doing anything with a quokka file, you need to load it. Tip For the remaining of this tutorial, I will be using an interactive IPython shell. To load a program, quokka needs both the export file and the original binary. Indeed, to reduce the size of the export, information directly available in the binary are not exported. import quokka from pathlib import Path samples = Path ( 'docs/samples' ) assert samples . is_dir (), \"You should run this code in Quokka main directory\" prog = quokka . Program ( samples / \"qb-crackme.quokka\" , samples / \"qb-crackme\" ) # Let's check if it worked print ( f 'Program base address is 0x { prog . base_address : x } ' ) # Should print: Program base address is 0x8048000.","title":"Binary loading"},{"location":"tutorials/qb-crackme/01_load/#explore-a-bit-the-program-object","text":"We now have in prog a complete program representation. Using dir(prog) , you can see the different possibilities. For instance, you can list the strings found in the program using : import quokka prog = quokka . Program ( \"docs/samples/qb-crackme.quokka\" , \"docs/samples/qb-crackme\" ) print ( f \"Found { len ( prog . strings ) } in { prog . export_file . stem } \" ) Using the protobuf directly Of note, the protobuf generated by the plugin is available in prog.proto . You should not access it directly because it's a rather compact format not well documented.","title":"Explore a bit the Program object"},{"location":"tutorials/qb-crackme/01_load/#export-and-load","text":"If the IDA plugin has been installed you can also create the exported directly using the convenient method from_binary . import quokka prog = quokka . Program . from_binary ( 'docs/samples/qb-crackme' ) assert prog is not None , \"Unable to export qb-crackme\"","title":"Export and load"},{"location":"tutorials/qb-crackme/01_load/#tips-tricks","text":"By default, IDA will store the database of the exported file next to the binary file. However, this is not convenient when dealing with read only filesystems. Use the database_file option to control where it should be stored. import quokka prog = quokka . Program . from_binary ( '/bin/ls' ) # Will fail because /bin is not writable assert prog is None , \"/bin is writable -- this is unusual\" prog = quokka . Program . from_binary ( '/bin/ls' , output_file = 'docs/samples/ls.quokka' , database_file = 'docs/samples/ls.i64' ) assert prog is not None , \"Unable to export ls\" The debug parameter of the same method will control the output. One of its effect is that it will print the exporter output and the command used to launch it.","title":"Tips &amp; tricks"},{"location":"tutorials/qb-crackme/02_functions/","text":"Functions One of the most common binary abstraction level is the function . Thus, quokka offers nicer way to interact to them (compared to the default IDA API). Prerequisites For this part of the tutorial, I asssume you already have a working installation of quokka and you already exported qb-crackme . Finding functions import quokka prog : quokka . Program # First way: accessing a function by its address func = prog [ 0x8049000 ] print ( func ) # This is <Function _init_proc at 0x8049000> # Second solution: by its name func = prog . fun_names [ '_init_proc' ] # Third: by the get_function method prog . get_function ( name = '_init_pr' , # Something in the name approximative = True , # Accept non-exact match normal = True ) # Only regular functions Function Types ? Binary functions have types in IDA (e.g. NORMAL, THUNK ...). The get_function method allows to restrict results to the NORMAL one : functions that are defined inside the program with regular body. The complete list of function types is: Type Definition EXTERN Function defined in an external library IMPORTED NORMAL Regular functions LIBRARY THUNK Thunk functions INVALID Errored type, should not exist The type of a function is accessible through function.type attribute. The Function object Like most of the object in quokka , the function object is in itself a mapping. The keys are the address and the values the corresponding chunks . Info A chunk is an IDA specific concept to deal with code reuse across functions. A function must have at least one chunk but a chunk may be shared by multiple functions. See Igor's explanation Warning The direct successors of a function are chunks. However, the interface of function and chunk is similar and most of the functions works the same on the both levels. Example prog : quokka . Program func = prog . fun_names [ '_init_proc' ] print ( f \"Function { func . name } calls { len ( func . calls ) } function(s).\" ) # Print: Function _init_proc calls 1 function(s). Manipulating function The Function class offers fast accessors to common properties. The snippet below list some of them : import quokka prog = quokka . Program ( 'docs/samples/qb-crackme.Quokka' , 'docs/samples/qb-crackme' ) func = prog . fun_names [ 'level_1' ] print ( f 'Func { func . name } starts at 0x { func . start : x } and finished at 0x { func . end : x } ' ) # Print the strings in the function print ( func . strings ) # Does the function uses constants ? if func . constants : print ( f ' { func . name } use constants' ) # What are the names of the functions called by this one ? for called in func . calls : print ( called . name ) Function CFG The CFG of the function is accessible through the func.graph attribute. It is a networkx.DiGraph where the nodes are the blocks (of all the chunks). Warning You must use the get_block method to retrieve a block from a function object as the dict in itself only refers Chunk . Chunks & Super chunks We already stated that Functions are composed of Chunks, themselves composed of Basic Blocks. However, the Chunk abstraction is never really used... Thus, most accessors at the function level propagate the requests at the block level. Super Chunks Super chunks are an abstraction used to deal with functions have multiple non-connected subcomponents. A SuperChunk is composed of Chunks itself. To iterate through all the chunks of a program a special method exists : program.iter_chunk . This method deals with SuperChunks and Functions to enumerate all the chunks defined in the program.","title":"2 - Functions"},{"location":"tutorials/qb-crackme/02_functions/#functions","text":"One of the most common binary abstraction level is the function . Thus, quokka offers nicer way to interact to them (compared to the default IDA API). Prerequisites For this part of the tutorial, I asssume you already have a working installation of quokka and you already exported qb-crackme .","title":"Functions"},{"location":"tutorials/qb-crackme/02_functions/#finding-functions","text":"import quokka prog : quokka . Program # First way: accessing a function by its address func = prog [ 0x8049000 ] print ( func ) # This is <Function _init_proc at 0x8049000> # Second solution: by its name func = prog . fun_names [ '_init_proc' ] # Third: by the get_function method prog . get_function ( name = '_init_pr' , # Something in the name approximative = True , # Accept non-exact match normal = True ) # Only regular functions Function Types ? Binary functions have types in IDA (e.g. NORMAL, THUNK ...). The get_function method allows to restrict results to the NORMAL one : functions that are defined inside the program with regular body. The complete list of function types is: Type Definition EXTERN Function defined in an external library IMPORTED NORMAL Regular functions LIBRARY THUNK Thunk functions INVALID Errored type, should not exist The type of a function is accessible through function.type attribute.","title":"Finding functions"},{"location":"tutorials/qb-crackme/02_functions/#the-function-object","text":"Like most of the object in quokka , the function object is in itself a mapping. The keys are the address and the values the corresponding chunks . Info A chunk is an IDA specific concept to deal with code reuse across functions. A function must have at least one chunk but a chunk may be shared by multiple functions. See Igor's explanation Warning The direct successors of a function are chunks. However, the interface of function and chunk is similar and most of the functions works the same on the both levels. Example prog : quokka . Program func = prog . fun_names [ '_init_proc' ] print ( f \"Function { func . name } calls { len ( func . calls ) } function(s).\" ) # Print: Function _init_proc calls 1 function(s).","title":"The Function object"},{"location":"tutorials/qb-crackme/02_functions/#manipulating-function","text":"The Function class offers fast accessors to common properties. The snippet below list some of them : import quokka prog = quokka . Program ( 'docs/samples/qb-crackme.Quokka' , 'docs/samples/qb-crackme' ) func = prog . fun_names [ 'level_1' ] print ( f 'Func { func . name } starts at 0x { func . start : x } and finished at 0x { func . end : x } ' ) # Print the strings in the function print ( func . strings ) # Does the function uses constants ? if func . constants : print ( f ' { func . name } use constants' ) # What are the names of the functions called by this one ? for called in func . calls : print ( called . name )","title":"Manipulating function"},{"location":"tutorials/qb-crackme/02_functions/#function-cfg","text":"The CFG of the function is accessible through the func.graph attribute. It is a networkx.DiGraph where the nodes are the blocks (of all the chunks). Warning You must use the get_block method to retrieve a block from a function object as the dict in itself only refers Chunk .","title":"Function CFG"},{"location":"tutorials/qb-crackme/02_functions/#chunks-super-chunks","text":"We already stated that Functions are composed of Chunks, themselves composed of Basic Blocks. However, the Chunk abstraction is never really used... Thus, most accessors at the function level propagate the requests at the block level.","title":"Chunks &amp; Super chunks"},{"location":"tutorials/qb-crackme/02_functions/#super-chunks","text":"Super chunks are an abstraction used to deal with functions have multiple non-connected subcomponents. A SuperChunk is composed of Chunks itself. To iterate through all the chunks of a program a special method exists : program.iter_chunk . This method deals with SuperChunks and Functions to enumerate all the chunks defined in the program.","title":"Super Chunks"},{"location":"tutorials/qb-crackme/03_blocks/","text":"Blocks Blocks are parts of a function. They are in itself dict with a mapping from instruction address to instruction. Finding a block import quokka # Load the program and get a function prog = quokka . Program ( 'docs/samples/qb-crackme.quokka' , 'docs/samples/qb-crackme' ) func = prog . fun_names [ 'level_1' ] block_start : int = 0x80494e8 # Method 1 : Get a block through the function block = func . get_block ( address = block_start ) # Method 2 : Get a block from an instruction inst = prog . get_instruction ( block_start ) block = inst . parent Block attributes It should be no suprise that a Block is also a mapping. Indeed, it holds a mapping from address to Instructions. However, it still has some properties CFG A block maintains a list of successors and predecessors (from the CFG). successor : int for successor in block . successors : assert ( successor in block . parent ) Strings, constants and comments Strings, constants (and other data) are accessible with the eponyms attributes. Moreover, if a comment has been defined in IDA, it is accessible through comments . Type Basic blocks have types in IDA which is exported by quokka . Use block.type to access it.","title":"3 - Blocks"},{"location":"tutorials/qb-crackme/03_blocks/#blocks","text":"Blocks are parts of a function. They are in itself dict with a mapping from instruction address to instruction.","title":"Blocks"},{"location":"tutorials/qb-crackme/03_blocks/#finding-a-block","text":"import quokka # Load the program and get a function prog = quokka . Program ( 'docs/samples/qb-crackme.quokka' , 'docs/samples/qb-crackme' ) func = prog . fun_names [ 'level_1' ] block_start : int = 0x80494e8 # Method 1 : Get a block through the function block = func . get_block ( address = block_start ) # Method 2 : Get a block from an instruction inst = prog . get_instruction ( block_start ) block = inst . parent","title":"Finding a block"},{"location":"tutorials/qb-crackme/03_blocks/#block-attributes","text":"It should be no suprise that a Block is also a mapping. Indeed, it holds a mapping from address to Instructions. However, it still has some properties","title":"Block attributes"},{"location":"tutorials/qb-crackme/03_blocks/#cfg","text":"A block maintains a list of successors and predecessors (from the CFG). successor : int for successor in block . successors : assert ( successor in block . parent )","title":"CFG"},{"location":"tutorials/qb-crackme/03_blocks/#strings-constants-and-comments","text":"Strings, constants (and other data) are accessible with the eponyms attributes. Moreover, if a comment has been defined in IDA, it is accessible through comments .","title":"Strings, constants and comments"},{"location":"tutorials/qb-crackme/03_blocks/#type","text":"Basic blocks have types in IDA which is exported by quokka . Use block.type to access it.","title":"Type"},{"location":"tutorials/qb-crackme/04_instructions/","text":"Instructions Instructions are the main component of a program. quokka enables a seamless interaction with them and offers a first-class support for both capstone and pypcode . Finding an instruction import quokka prog = quokka . Program ( 'docs/samples/qb-crackme.quokka' , 'docs/samples/qb-crackme' ) # Method 1 : from the program by its address inst = prog . get_instruction ( 0x80494e8 ) # print(inst) # Method 2: by the function func = prog . fun_names [ 'level1' ] inst = func . get_instruction ( 0x80494e8 ) # Method 3: by the block block = func . get_block ( func . start ) inst = block . get_instruction ( 0x80494e8 ) Instructions attributes Printing the mnemonic print ( inst ) # <Inst push> print ( inst . mnemonic ) # push Using the capstone bindings If capstone is installed, it's possible to access the capstone object by using inst.cs_inst . print ( inst . cs_inst ) # <CsInsn 0x80494e8 [55]: push ebp> With this method, you can access every capstone attributes. For instance, to get the read registers: for reg in inst . cs_inst . regs_read : print ( inst . cs_inst . reg_name ( reg )) Mnemonics and operands The mnemonic is given by IDA and found using instruction.mnemonic . Warning There exists some discrepancies between IDA and Capstone, and they may not agree all the time on the disassembly. quokka tries to fall back to sane values. Operands Error Operands are not fully implemented. Use carefully. The instruction operands are listed in the operands attribute. The fields of the operands are directly replicated from the protobuf (and found in IDA). The details field replicates some attributes from capstone if needed. Warning At some point, the information extracted from IDA will be unserialized, and it will be possible to fully understand what the fields mean.","title":"4 - Instructions"},{"location":"tutorials/qb-crackme/04_instructions/#instructions","text":"Instructions are the main component of a program. quokka enables a seamless interaction with them and offers a first-class support for both capstone and pypcode .","title":"Instructions"},{"location":"tutorials/qb-crackme/04_instructions/#finding-an-instruction","text":"import quokka prog = quokka . Program ( 'docs/samples/qb-crackme.quokka' , 'docs/samples/qb-crackme' ) # Method 1 : from the program by its address inst = prog . get_instruction ( 0x80494e8 ) # print(inst) # Method 2: by the function func = prog . fun_names [ 'level1' ] inst = func . get_instruction ( 0x80494e8 ) # Method 3: by the block block = func . get_block ( func . start ) inst = block . get_instruction ( 0x80494e8 )","title":"Finding an instruction"},{"location":"tutorials/qb-crackme/04_instructions/#instructions-attributes","text":"","title":"Instructions attributes"},{"location":"tutorials/qb-crackme/04_instructions/#printing-the-mnemonic","text":"print ( inst ) # <Inst push> print ( inst . mnemonic ) # push","title":"Printing the mnemonic"},{"location":"tutorials/qb-crackme/04_instructions/#using-the-capstone-bindings","text":"If capstone is installed, it's possible to access the capstone object by using inst.cs_inst . print ( inst . cs_inst ) # <CsInsn 0x80494e8 [55]: push ebp> With this method, you can access every capstone attributes. For instance, to get the read registers: for reg in inst . cs_inst . regs_read : print ( inst . cs_inst . reg_name ( reg ))","title":"Using the capstone bindings"},{"location":"tutorials/qb-crackme/04_instructions/#mnemonics-and-operands","text":"The mnemonic is given by IDA and found using instruction.mnemonic . Warning There exists some discrepancies between IDA and Capstone, and they may not agree all the time on the disassembly. quokka tries to fall back to sane values.","title":"Mnemonics and operands"},{"location":"tutorials/qb-crackme/04_instructions/#operands","text":"Error Operands are not fully implemented. Use carefully. The instruction operands are listed in the operands attribute. The fields of the operands are directly replicated from the protobuf (and found in IDA). The details field replicates some attributes from capstone if needed. Warning At some point, the information extracted from IDA will be unserialized, and it will be possible to fully understand what the fields mean.","title":"Operands"},{"location":"tutorials/qb-crackme/05_references/","text":"References One important element in programs are the relations between different subcomponents. We denote links between two element as References . Reference Types quokka uses several Reference Types listed below that are self-explanatory. Extract of types.py class ReferenceType ( enum . Enum ): CALL = enum . auto () DATA = enum . auto () ENUM = enum . auto () STRUC = enum . auto () UNKNOWN = enum . auto () Call References A Call reference is a link from one Instruction to a Chunk . Usually, the mnemonic is something like call . For instance: import quokka prog = quokka . Program ( 'docs/samples/qb-crackme.quokka' , 'docs/samples/qb-crackme' ) inst : quokka . Instruction = prog . get_instruction ( 0x804950f ) target : quokka . Chunk = inst . call_target print ( f \"Inst { inst } calls ` { target . name } `\" ) # Inst <call 0x8049270> calls `get_input` Data References Sometimes, instruction manipulates Data . import quokka prog = quokka . Program ( 'docs/samples/qb-crackme.quokka' , 'docs/samples/qb-crackme' ) inst = prog . get_instruction ( 0x8049287 ) print ( inst . cs_inst ) # <CsInsn 0x8049287 [a140e00408]: mov eax, dword ptr [0x804e040]> for data in inst . data_references : print ( f \" { data . type } : { data . address } { data . value } \" ) # DataType.DOUBLE_WORD : 0x804e040 None Reference Manager Every Reference is stored in the Reference Manager. The API is not yet stabilized and the Reference Manager should not be used directly. import quokka prog = quokka . Program ( 'docs/samples/qb-crackme.quokka' , 'docs/samples/qb-crackme' ) # To list every call to a `Chunk` func = prog . fun_names [ \"get_input\" ] chunk = func [ func . start ] prog . references . resolve_calls ( chunk )","title":"5 - References"},{"location":"tutorials/qb-crackme/05_references/#references","text":"One important element in programs are the relations between different subcomponents. We denote links between two element as References .","title":"References"},{"location":"tutorials/qb-crackme/05_references/#reference-types","text":"quokka uses several Reference Types listed below that are self-explanatory. Extract of types.py class ReferenceType ( enum . Enum ): CALL = enum . auto () DATA = enum . auto () ENUM = enum . auto () STRUC = enum . auto () UNKNOWN = enum . auto ()","title":"Reference Types"},{"location":"tutorials/qb-crackme/05_references/#call-references","text":"A Call reference is a link from one Instruction to a Chunk . Usually, the mnemonic is something like call . For instance: import quokka prog = quokka . Program ( 'docs/samples/qb-crackme.quokka' , 'docs/samples/qb-crackme' ) inst : quokka . Instruction = prog . get_instruction ( 0x804950f ) target : quokka . Chunk = inst . call_target print ( f \"Inst { inst } calls ` { target . name } `\" ) # Inst <call 0x8049270> calls `get_input`","title":"Call References"},{"location":"tutorials/qb-crackme/05_references/#data-references","text":"Sometimes, instruction manipulates Data . import quokka prog = quokka . Program ( 'docs/samples/qb-crackme.quokka' , 'docs/samples/qb-crackme' ) inst = prog . get_instruction ( 0x8049287 ) print ( inst . cs_inst ) # <CsInsn 0x8049287 [a140e00408]: mov eax, dword ptr [0x804e040]> for data in inst . data_references : print ( f \" { data . type } : { data . address } { data . value } \" ) # DataType.DOUBLE_WORD : 0x804e040 None","title":"Data References"},{"location":"tutorials/qb-crackme/05_references/#reference-manager","text":"Every Reference is stored in the Reference Manager. The API is not yet stabilized and the Reference Manager should not be used directly. import quokka prog = quokka . Program ( 'docs/samples/qb-crackme.quokka' , 'docs/samples/qb-crackme' ) # To list every call to a `Chunk` func = prog . fun_names [ \"get_input\" ] chunk = func [ func . start ] prog . references . resolve_calls ( chunk )","title":"Reference Manager"},{"location":"tutorials/qb-crackme/06_other/","text":"Structures Structures exported from IDA are found in program.structures . A structure is composed of his members and most of all the information found in IDA are extracted. Note Unions , enums and structures are all merged into the more generic term structure in Quokka. The structure type is found in structure.type . Segments The segments exported from IDA are available under program.segments Strings All the strings of the binary are also listed in program.strings . Executable The executable file is best dealt with the program.executable attribute. Methods are provided to read from the file content at both absolute and relative address.","title":"6 - Others"},{"location":"tutorials/qb-crackme/06_other/#structures","text":"Structures exported from IDA are found in program.structures . A structure is composed of his members and most of all the information found in IDA are extracted. Note Unions , enums and structures are all merged into the more generic term structure in Quokka. The structure type is found in structure.type .","title":"Structures"},{"location":"tutorials/qb-crackme/06_other/#segments","text":"The segments exported from IDA are available under program.segments","title":"Segments"},{"location":"tutorials/qb-crackme/06_other/#strings","text":"All the strings of the binary are also listed in program.strings .","title":"Strings"},{"location":"tutorials/qb-crackme/06_other/#executable","text":"The executable file is best dealt with the program.executable attribute. Methods are provided to read from the file content at both absolute and relative address.","title":"Executable"},{"location":"tutorials/qb-crackme/07_solving/","text":"Solving the crackme As you have already seen, the sample we use since the beginning of this tutorial is a (simple) crackme. Let's try to see how we can start to solve it with quokka . Finding the challenges import quokka prog = quokka . Program ( 'docs/samples/qb-crackme.Quokka' , 'docs/samples/qb-crackme' ) # Get the functions name for func in prog . fun_names : if func . startswith ( \"level\" ): print ( prog . fun_names [ func ]) It yields to the following results! <Function level0 at 0x80492bc> <Function level1 at 0x80494e8> <Function level2 at 0x8049568> <Function level3 at 0x80495c3> <Function level4 at 0x80496f0> <Function level5 at 0x804980c> <Function level6 at 0x804987e> <Function level7 at 0x80499af> <Function level8 at 0x8049b69> <Function level9 at 0x8049cfe> Great, we have about 10 levels to solve. Let start by the first one. Level 0 First, get the function: func = prog . fun_names [ \"level0\" ] Then, let's examine it: # Get the size print ( len ( func )) # 1 Chunk print ( len ( func [ func . start ])) # 7 basic blocks We see that the functions have 3 strings: for str in func . strings : print ( str ) 0;-LS|iX|:rlAy1ZWr;|+Ab1S3},IV.z*t:%|pHyY_9&AuW*.jJX`<5]z{nB``mEdntH5f#`n={JPGLF0r>ua!ObZE?y.VjfpsZ6rTvD|Y--9E~AXeuY9I2&[iNTIr^]!%dAu-m82$CF#[of+]7RcgdKd.W&~D01j^fI}=Cda+7W)zg:m1[=!]JdiUaq({@H:)+/JZ.z0(!?ekIV55oq-6an3Ag8o)5k-mu,RH1z7fSy:s@K4oQ.TkYg7^i F00d1e What's the flag? And it's calling 3 functions: for chunk in func . calls : print ( chunk . name ) get_input _strlen _strlen Let's now print the disassembly of the first block to understand what's happening: for inst in func . get_block ( func . start ): print ( inst . cs_inst ) <CsInsn 0x80492bc [55]: push ebp> <CsInsn 0x80492bd [89e5]: mov ebp, esp> <CsInsn 0x80492bf [81ec28020000]: sub esp, 0x228> <CsInsn 0x80492c5 [c745ec88b00408]: mov dword ptr [ebp - 0x14], 0x804b088> <CsInsn 0x80492cc [c745e88fb00408]: mov dword ptr [ebp - 0x18], 0x804b08f> <CsInsn 0x80492d3 [83ec04]: sub esp, 4> <CsInsn 0x80492d6 [8d85dcfdffff]: lea eax, [ebp - 0x224]> <CsInsn 0x80492dc [50]: push eax> <CsInsn 0x80492dd [ff75e8]: push dword ptr [ebp - 0x18]> <CsInsn 0x80492e0 [ff75ec]: push dword ptr [ebp - 0x14]> <CsInsn 0x80492e3 [e888ffffff]: call 0x8049270> <CsInsn 0x80492e8 [83c410]: add esp, 0x10> <CsInsn 0x80492eb [c745e4a0b00408]: mov dword ptr [ebp - 0x1c], 0x804b0a0> <CsInsn 0x80492f2 [83ec0c]: sub esp, 0xc> <CsInsn 0x80492f5 [ff75e4]: push dword ptr [ebp - 0x1c]> <CsInsn 0x80492f8 [e863fdffff]: call 0x8049060> <CsInsn 0x80492fd [83c410]: add esp, 0x10> <CsInsn 0x8049300 [8945e0]: mov dword ptr [ebp - 0x20], eax> <CsInsn 0x8049303 [83ec0c]: sub esp, 0xc> <CsInsn 0x8049306 [8d85dcfdffff]: lea eax, [ebp - 0x224]> <CsInsn 0x804930c [50]: push eax> <CsInsn 0x804930d [e84efdffff]: call 0x8049060> <CsInsn 0x8049312 [83c410]: add esp, 0x10> <CsInsn 0x8049315 [8945dc]: mov dword ptr [ebp - 0x24], eax> <CsInsn 0x8049318 [c745f400000000]: mov dword ptr [ebp - 0xc], 0> <CsInsn 0x804931f [c745f0c8000000]: mov dword ptr [ebp - 0x10], 0xc8> <CsInsn 0x8049326 [eb2c]: jmp 0x8049354> We find the three calls we already saw. Note Since we are using capstone disassembly here, we don't resolve the call target. However, using func.get_instruction(0x80492e3).call_target.name allows us to recover it! Let's examine this extract: <CsInsn 0x80492eb [c745e4a0b00408]: mov dword ptr [ebp - 0x1c], 0x804b0a0> [...] <CsInsn 0x80492f5 [ff75e4]: push dword ptr [ebp - 0x1c]> <CsInsn 0x80492f8 [e863fdffff]: call 0x8049060> We load a data and push it on the stack before calling a function. We can ask quokka to help us to identify the calling convention used by the binary in two ways: from quokka.analysis import Environment , Platform env = Environment ( Platform . LINUX , prog . arch ) print ( env . calling_convention ) # Or ask IDA # This uses the protobuf directly because no accessor is yet available. print ( prog . proto . meta . calling_convention ) In cdecl , arguments are pushed on the stack. So, we see that the argument of the strlen call is the data loaded from memory. inst = func . get_instruction ( 0x80492eb ) print ( inst . string ) The argument used by the second call at strlen is the result of the get_input function. Let's consider the next block: first = func . get_block ( func . start ) next_block = func . get_block ( next ( first . successors ())) We know there is only one successor because either : - the first block disassembly ends with an unconditional jump - func.graph[first.start] lists an Unconditional Edge - sum(1 for _ in first.successors()) is 1 Our new block has two predecessors: we are in a loop! list ( next_block . predecessors ()) From now on, we can just navigate in the CFG and see what are the conditions to complete to solve the level. Final words This toy example is maybe not the best display on why quokka could be useful, but highlights some possibilities.","title":"7 - Going further"},{"location":"tutorials/qb-crackme/07_solving/#solving-the-crackme","text":"As you have already seen, the sample we use since the beginning of this tutorial is a (simple) crackme. Let's try to see how we can start to solve it with quokka .","title":"Solving the crackme"},{"location":"tutorials/qb-crackme/07_solving/#finding-the-challenges","text":"import quokka prog = quokka . Program ( 'docs/samples/qb-crackme.Quokka' , 'docs/samples/qb-crackme' ) # Get the functions name for func in prog . fun_names : if func . startswith ( \"level\" ): print ( prog . fun_names [ func ]) It yields to the following results! <Function level0 at 0x80492bc> <Function level1 at 0x80494e8> <Function level2 at 0x8049568> <Function level3 at 0x80495c3> <Function level4 at 0x80496f0> <Function level5 at 0x804980c> <Function level6 at 0x804987e> <Function level7 at 0x80499af> <Function level8 at 0x8049b69> <Function level9 at 0x8049cfe> Great, we have about 10 levels to solve. Let start by the first one.","title":"Finding the challenges"},{"location":"tutorials/qb-crackme/07_solving/#level-0","text":"First, get the function: func = prog . fun_names [ \"level0\" ] Then, let's examine it: # Get the size print ( len ( func )) # 1 Chunk print ( len ( func [ func . start ])) # 7 basic blocks We see that the functions have 3 strings: for str in func . strings : print ( str ) 0;-LS|iX|:rlAy1ZWr;|+Ab1S3},IV.z*t:%|pHyY_9&AuW*.jJX`<5]z{nB``mEdntH5f#`n={JPGLF0r>ua!ObZE?y.VjfpsZ6rTvD|Y--9E~AXeuY9I2&[iNTIr^]!%dAu-m82$CF#[of+]7RcgdKd.W&~D01j^fI}=Cda+7W)zg:m1[=!]JdiUaq({@H:)+/JZ.z0(!?ekIV55oq-6an3Ag8o)5k-mu,RH1z7fSy:s@K4oQ.TkYg7^i F00d1e What's the flag? And it's calling 3 functions: for chunk in func . calls : print ( chunk . name ) get_input _strlen _strlen Let's now print the disassembly of the first block to understand what's happening: for inst in func . get_block ( func . start ): print ( inst . cs_inst ) <CsInsn 0x80492bc [55]: push ebp> <CsInsn 0x80492bd [89e5]: mov ebp, esp> <CsInsn 0x80492bf [81ec28020000]: sub esp, 0x228> <CsInsn 0x80492c5 [c745ec88b00408]: mov dword ptr [ebp - 0x14], 0x804b088> <CsInsn 0x80492cc [c745e88fb00408]: mov dword ptr [ebp - 0x18], 0x804b08f> <CsInsn 0x80492d3 [83ec04]: sub esp, 4> <CsInsn 0x80492d6 [8d85dcfdffff]: lea eax, [ebp - 0x224]> <CsInsn 0x80492dc [50]: push eax> <CsInsn 0x80492dd [ff75e8]: push dword ptr [ebp - 0x18]> <CsInsn 0x80492e0 [ff75ec]: push dword ptr [ebp - 0x14]> <CsInsn 0x80492e3 [e888ffffff]: call 0x8049270> <CsInsn 0x80492e8 [83c410]: add esp, 0x10> <CsInsn 0x80492eb [c745e4a0b00408]: mov dword ptr [ebp - 0x1c], 0x804b0a0> <CsInsn 0x80492f2 [83ec0c]: sub esp, 0xc> <CsInsn 0x80492f5 [ff75e4]: push dword ptr [ebp - 0x1c]> <CsInsn 0x80492f8 [e863fdffff]: call 0x8049060> <CsInsn 0x80492fd [83c410]: add esp, 0x10> <CsInsn 0x8049300 [8945e0]: mov dword ptr [ebp - 0x20], eax> <CsInsn 0x8049303 [83ec0c]: sub esp, 0xc> <CsInsn 0x8049306 [8d85dcfdffff]: lea eax, [ebp - 0x224]> <CsInsn 0x804930c [50]: push eax> <CsInsn 0x804930d [e84efdffff]: call 0x8049060> <CsInsn 0x8049312 [83c410]: add esp, 0x10> <CsInsn 0x8049315 [8945dc]: mov dword ptr [ebp - 0x24], eax> <CsInsn 0x8049318 [c745f400000000]: mov dword ptr [ebp - 0xc], 0> <CsInsn 0x804931f [c745f0c8000000]: mov dword ptr [ebp - 0x10], 0xc8> <CsInsn 0x8049326 [eb2c]: jmp 0x8049354> We find the three calls we already saw. Note Since we are using capstone disassembly here, we don't resolve the call target. However, using func.get_instruction(0x80492e3).call_target.name allows us to recover it! Let's examine this extract: <CsInsn 0x80492eb [c745e4a0b00408]: mov dword ptr [ebp - 0x1c], 0x804b0a0> [...] <CsInsn 0x80492f5 [ff75e4]: push dword ptr [ebp - 0x1c]> <CsInsn 0x80492f8 [e863fdffff]: call 0x8049060> We load a data and push it on the stack before calling a function. We can ask quokka to help us to identify the calling convention used by the binary in two ways: from quokka.analysis import Environment , Platform env = Environment ( Platform . LINUX , prog . arch ) print ( env . calling_convention ) # Or ask IDA # This uses the protobuf directly because no accessor is yet available. print ( prog . proto . meta . calling_convention ) In cdecl , arguments are pushed on the stack. So, we see that the argument of the strlen call is the data loaded from memory. inst = func . get_instruction ( 0x80492eb ) print ( inst . string ) The argument used by the second call at strlen is the result of the get_input function. Let's consider the next block: first = func . get_block ( func . start ) next_block = func . get_block ( next ( first . successors ())) We know there is only one successor because either : - the first block disassembly ends with an unconditional jump - func.graph[first.start] lists an Unconditional Edge - sum(1 for _ in first.successors()) is 1 Our new block has two predecessors: we are in a loop! list ( next_block . predecessors ()) From now on, we can just navigate in the CFG and see what are the conditions to complete to solve the level.","title":"Level 0"},{"location":"tutorials/qb-crackme/07_solving/#final-words","text":"This toy example is maybe not the best display on why quokka could be useful, but highlights some possibilities.","title":"Final words"},{"location":"tutorials/qb-crackme/SUMMARY/","text":"0 - Introduction 1 - Loading 2 - Functions 3 - Blocks 4 - Instructions 5 - References 6 - Others 7 - Going further","title":"SUMMARY"}]}