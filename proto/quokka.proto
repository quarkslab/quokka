syntax = "proto3";
package quokka;

message Quokka {
  message ExporterMeta {
    enum Mode {
      MODE_LIGHT = 0;
      MODE_SELF_CONTAINED = 1;
    }

    Mode mode = 1;
    string version = 2;  // Quokka version
  }

  enum AddressSize {
    ADDR_UNK = 0;
    ADDR_32 = 1;
    ADDR_64 = 2;
  }

  message Meta {
    enum ISA {
      PROC_INTEL = 0;
      PROC_ARM = 1;
      PROC_DALVIK = 2;
      PROC_PPC = 3;
      PROC_MIPS = 4;
      PROC_UNK = 5;
    }

    enum Endianess {
      END_LE = 0;
      END_BE = 1;
      END_UNK = 2;
    }

    enum Compiler {
      COMP_GCC = 0;
      COMP_MS = 1;
      COMP_BC = 2;
      COMP_WATCOM = 3;
      COMP_VISAGE = 4;
      COMP_BP = 5;
      COMP_UNK = 6;
    }

    enum CallingConvention {
      CC_UNK = 0;
      CC_CDECL = 1;
      CC_ELLIPSIS = 2;
      CC_STDCALL = 3;
      CC_PASCAL = 4;
      CC_FASTCALL = 5;
      CC_THISCALL = 6;
    }

    message Hash {
      enum HashType {
        HASH_NONE = 0;
        HASH_SHA256 = 1;
        HASH_MD5 = 2;
      }

      HashType hash_type = 1;
      string hash_value = 2;
    }

    message Backend {
      string name = 1;

      // The version is stored as a string but it might have different meaning
      // depending on the actual backend used.
      // For example on IDA, the version is the IDA_SDK_VERSION constant.
      string version = 2;
    }

    // Executable name : only the basename
    string executable_name = 1;

    // The following fields are set using IDA detection rules
    ISA isa = 2;
    Compiler compiler = 3;
    CallingConvention calling_convention = 4;
    Hash hash = 5;
    Endianess endianess = 6;
    AddressSize address_size = 7;

    Backend backend = 8;
  }

  message Operand {
    enum OperandType {
      OPERAND_REGISTER = 0;
      OPERAND_IMMEDIATE = 1;
      OPERAND_MEMORY = 2;
      OPERAND_OTHER = 3;
    }

    OperandType type = 1;

    oneof Value {
      string register_index = 2;
      int64 value = 3;  // TODO merge with address below?
      int64 address = 4;
      string other = 5;  // TODO umbrella value for whatever operand
    }

    // Optionally encodes disassembler specific data
    optional bytes specific_info = 6;
  }

  message Instruction {
    uint32 size = 1;
    uint32 mnemonic_index = 2;
    repeated uint32 operand_index = 3;
    bool is_thumb = 4;
  }

  message Function {
    message Edge {
      enum EdgeType {
        TYPE_UNCONDITIONAL = 0;
        TYPE_TRUE = 1;
        TYPE_FALSE = 2;
        TYPE_DYNAMIC = 3;  // Like a switch jump table
      }

      EdgeType edge_type = 1;
      uint32 source = 2;       // Block index source
      uint32 destination = 3;  // Block index destination

      bool user_defined = 4;
    }

    message Block {
      enum BlockType {
        BLOCK_TYPE_NORMAL = 0;
        BLOCK_TYPE_INDJUMP = 1;
        BLOCK_TYPE_RET = 2;
        BLOCK_TYPE_NORET = 3;
        BLOCK_TYPE_CNDRET = 4;
        BLOCK_TYPE_ENORET = 5;
        BLOCK_TYPE_EXTERN = 6;
        BLOCK_TYPE_ERROR = 7;
        BLOCK_TYPE_FAKE = 8;
      }

      uint32 segment_index = 1;
      uint32 file_offset = 2;
      BlockType block_type = 3;

      // TODO optimize for more than 4 billions 1 byte instructions?
      repeated uint64 instruction_index = 4;

      uint32 size = 5;  // The size in terms of bytes

      // Whether the first instruction of the BB is in thumb mode
      bool is_thumb = 6;
    }

    enum FunctionType {
      TYPE_NORMAL = 0;
      TYPE_IMPORTED = 1;
      TYPE_LIBRARY = 2;
      TYPE_THUNK = 3;
      TYPE_INVALID = 4;
    }

    message Position {
      enum PositionType {
        CENTER = 0;
        TOP_LEFT = 1;
      }

      int32 x = 1;
      int32 y = 2;
      PositionType position_type = 3;
    }

    message BlockPosition {
      uint32 block_id = 1;
      Position position = 2;
    }

    uint32 segment_index = 1;
    uint32 file_offset = 2;

    repeated Block blocks = 3;
    repeated Edge edges = 4;

    FunctionType function_type = 5;
    string name = 6;

    repeated BlockPosition block_positions = 7;

    // Optional mangled name, it is non-null only if different from `name`
    string mangled_name = 8;

    optional string decompilation = 9;
  }

  message Layout {
    message AddressRange {
      uint64 start_address = 1;
      uint64 size = 2;
    }

    enum LayoutType {
      LAYOUT_UNK = 0;
      LAYOUT_CODE = 1;
      LAYOUT_DATA = 2;
      LAYOUT_GAP = 3;
    }

    AddressRange address_range = 1;
    LayoutType layout_type = 2;
  }

  enum DataType {
    TYPE_UNK = 0;
    TYPE_B = 1;
    TYPE_W = 2;
    TYPE_DW = 3;
    TYPE_QW = 4;
    TYPE_OW = 5;
    TYPE_FLOAT = 6;
    TYPE_DOUBLE = 7;
    TYPE_ASCII = 8;
    TYPE_STRUCT = 9;
    TYPE_ALIGN = 10;
    TYPE_POINTER = 11;
    TYPE_ENUM = 12;
    TYPE_UNION = 13;
  }

  message Data {
    uint32 segment_index = 1;
    uint32 file_offset = 2;
    DataType type = 3;
    // In case the type is composite or enum and there is a custom type
    // exported, this variable is referencing it
    optional uint32 type_index = 9;

    oneof DataSize {
      uint32 size = 4;
      bool no_size = 5;
    }

    string name = 6;
    bool not_initialized = 7;
  }

  message CompositeType {
    message Member {
      uint32 offset = 1;
      string name = 2;
      DataType type = 3;
      optional uint32 type_index = 4;  // Only if the type is composite or enum
      uint32 size = 5;
    }

    enum CompositeSubType {
      TYPE_STRUCT = 0;
      TYPE_UNION = 1;
      TYPE_UNK = 2;
    }

    string name = 1;
    CompositeSubType type = 2;
    uint32 size = 3;
    repeated Member members = 4;
  }

  message EnumType {
    message EnumValue {
      string name = 1;
      int64 value = 2;
    }
    string name = 1;
    repeated EnumValue values = 2;
  }

  message CompositeDataTypeIdentifier {
    uint32 data_type_index = 1;
    oneof MemberIndex {
      uint32 member_index = 2;
      bool no_member = 3;  // Identify the whole data type
    }
  }

  message DataIdentifier {
    uint32 data_index = 1;
    // Optionally, if the data is composite, a list of member indices is
    // provided. For example to identify data `a.b.c.d` the indices [#b, #c, #d]
    // will be stored in member_chain.
    repeated uint32 member_chain = 2;
  }

  message InstructionIdentifier {
    uint32 function_index = 1;
    uint32 block_index = 2;
    // Offset (in bytes) of the instruction within the basic block
    uint32 offset = 3;
  }

  message Comment {
    enum CommentType {
      COMMENT_INSTRUCTION = 0;
      COMMENT_FUNCTION = 1;
      COMMENT_DATA = 2;
      COMMENT_DATA_TYPE = 3;
      COMMENT_INVALID = 4;
    }

    CommentType type = 1;
    string content = 2;
    oneof Location {
      InstructionIdentifier instruction_id = 3;
      uint32 function_index = 4;
      DataIdentifier data_id = 5;
      CompositeDataTypeIdentifier data_type_id = 6;
    }
  }

  message Reference {
    enum ReferenceType {
      REF_CODE = 0;
      REF_DATA = 1;
      REF_UNK = 2;
    }

    // TODO merge Origin and Target into a single Location?
    message ReferenceOrigin {
      oneof Type {
        InstructionIdentifier instruction_id = 1;
        DataIdentifier data_index = 2;
      }
    }

    message ReferenceTarget {
      oneof Type {
        InstructionIdentifier instruction_id = 1;
        DataIdentifier data_index = 2;
        // Works only for composite data types
        CompositeDataTypeIdentifier data_type_index = 3;
      }
    }

    // The location that reference (for ex: an instruction)
    ReferenceOrigin source = 1;
    // The location that is referenced (for ex: data)
    ReferenceTarget destination = 2;
    ReferenceType reference_type = 3;
  }

  message Segment {
    enum Type {
      SEGMENT_UNK = 0;
      SEGMENT_CODE = 1;
      SEGMENT_DATA = 2;
      SEGMENT_BSS = 3;
      SEGMENT_NULL = 4;
      SEGMENT_EXTERN = 5;
      SEGMENT_NORMAL = 6;
      SEGMENT_ABSOLUTE_SYMBOLS = 7;
    }

    enum Bitness {
      BITNESS_64 = 0;
      BITNESS_32 = 1;
      BITNESS_16 = 2;
      BITNESS_UNKNOWN = 3;
    }

    string name = 1;
    uint64 virtual_addr = 2;
    uint64 size = 3;
    uint32 permissions = 4;
    Type type = 5;
    AddressSize address_size = 6;

    // File offset of the start address of the segment
    oneof offset_type {
      uint64 file_offset = 7;
      bool no_offset = 8;
    }
  }

  Meta meta = 1;
  ExporterMeta exporter_meta = 2;

  repeated Layout layout = 3;
  repeated Data data = 4;
  repeated CompositeType composite_types = 5;
  repeated EnumType enums = 6;

  repeated Instruction instructions = 7;
  repeated string mnemonics = 8;

  repeated Function functions = 9;
  repeated Reference references = 10;

  repeated string register_table = 11;
  repeated Operand operands = 12;

  repeated string comment_table = 13;
  repeated Comment comments = 14;

  repeated Segment segments = 15;
}
